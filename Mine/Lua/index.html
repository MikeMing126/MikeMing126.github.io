<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Lua | Ming Blog</title><meta name="robots" content="noindex"><meta name="author" content="Ming"><meta name="copyright" content="Ming"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Lua数据类型Lua 数据类型nilbooleannumberstringfunctionuserdata  表示任意存储在变量中的C数据结构thread 执行的独立线路，用于执行协同程序table 表 实际上为“关联数组”  对于连续的数组类型，可以用#获取长度，否则要pairs遍历获取长度。  变长参数使用select来避免nil的问题。Lua - 函数进阶（一）可变参数 function T">
<meta property="og:type" content="article">
<meta property="og:title" content="Lua">
<meta property="og:url" content="https://mikeming126.github.io/Mine/Lua/index.html">
<meta property="og:site_name" content="Ming Blog">
<meta property="og:description" content="Lua数据类型Lua 数据类型nilbooleannumberstringfunctionuserdata  表示任意存储在变量中的C数据结构thread 执行的独立线路，用于执行协同程序table 表 实际上为“关联数组”  对于连续的数组类型，可以用#获取长度，否则要pairs遍历获取长度。  变长参数使用select来避免nil的问题。Lua - 函数进阶（一）可变参数 function T">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mikeming126.github.io/img/head.png">
<meta property="article:published_time" content="2025-10-05T12:30:06.418Z">
<meta property="article:modified_time" content="2025-10-05T14:49:49.387Z">
<meta property="article:author" content="Ming">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mikeming126.github.io/img/head.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Lua",
  "url": "https://mikeming126.github.io/Mine/Lua/",
  "image": "https://mikeming126.github.io/img/head.png",
  "datePublished": "2025-10-05T12:30:06.418Z",
  "dateModified": "2025-10-05T14:49:49.387Z",
  "author": [
    {
      "@type": "Person",
      "name": "Ming",
      "url": "https://mikeming126.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://mikeming126.github.io/Mine/Lua/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":4,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Lua',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/starBg2.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/starBg2.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Ming Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Lua</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Lua</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-05T12:30:06.418Z" title="发表于 2025-10-05 20:30:06">2025-10-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-05T14:49:49.387Z" title="更新于 2025-10-05 22:49:49">2025-10-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>17分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><a target="_blank" rel="noopener" href="https://www.runoob.com/lua/lua-data-types.html">Lua 数据类型</a><br>nil<br>boolean<br>number<br>string<br>function<br>userdata  表示任意存储在变量中的C数据结构<br>thread 执行的独立线路，用于执行协同程序<br>table 表 实际上为“关联数组”</p>
<ul>
<li>对于连续的数组类型，可以用#获取长度，否则要pairs遍历获取长度。</li>
</ul>
<h3 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h3><p>使用select来避免nil的问题。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhanxxiao/article/details/106595773">Lua - 函数进阶（一）可变参数</a></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TestFun</span><span class="params">(...)</span></span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">pairs</span>(&#123;...&#125;) <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">local</span> k,v = i,j</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">local</span> argsNum = <span class="built_in">select</span>(<span class="string">&#x27;#&#x27;</span>,...) <span class="comment">--获取参数个数</span></span><br><span class="line">   <span class="keyword">for</span> i = <span class="number">1</span>, argsNum <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">local</span> oneArg = <span class="built_in">select</span>(i,...) <span class="comment">--这里实际上是返回i之后的参数</span></span><br><span class="line">      <span class="built_in">print</span>(oneArg)</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- If index is a number, returns all arguments after argument number index;</span></span><br><span class="line"><span class="comment">-- a negative number indexes from the end (-1 is the last argument).</span></span><br><span class="line"><span class="comment">-- Otherwise, index must be the string &quot;#&quot;, and select returns the total number of extra arguments it received.</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6989056581157519368">Lua—String拼接几种方式及相应性能权衡</a></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>使用拼接符..</span><br><span class="line">str1 .. str2  <span class="comment">-- 频繁使用时会有大量字符串创建和内存分配</span></span><br><span class="line"><span class="number">2.</span>使用<span class="built_in">table</span>.<span class="built_in">concat</span></span><br><span class="line">infos = &#123;<span class="string">&quot;str1&quot;</span>,<span class="string">&quot;str2&quot;</span>&#125;</span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">concat</span>(infos,<span class="string">&quot;,&quot;</span>)</span><br><span class="line"><span class="number">3.</span>使用格式化</span><br><span class="line"><span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%s%s&quot;</span>,str1,str2)</span><br><span class="line"></span><br><span class="line">一般开销上 <span class="number">2</span> 好于 <span class="number">1</span> 好于 <span class="number">3</span>。</span><br></pre></td></tr></table></figure>


<h2 id="元表-Metatable-元方法-Metamethod"><a href="#元表-Metatable-元方法-Metamethod" class="headerlink" title="元表 Metatable 元方法 Metamethod"></a>元表 Metatable 元方法 Metamethod</h2><p><a target="_blank" rel="noopener" href="https://www.runoob.com/lua/lua-metatables.html">Lua 元表(Metatable)</a><br>元表：table of a table<br>用于定义或扩展其他表的行为。</p>
<p>Lua默认新表没有元表</p>
<p>相关函数.</p>
<ul>
<li>设置元表:setmetatable(targetTable,metatable)</li>
<li>获取元表:getmetatable(targetTable)</li>
</ul>
<h3 id="元方法"><a href="#元方法" class="headerlink" title="元方法"></a>元方法</h3><p>元方法是元表中的特殊字段，用于定义表在特定操作下的行为。常见的元方法包括：<br>加减乘除、字典的设置和访问不存在的对象(__index和__newindex)</p>
<table>
<thead>
<tr>
<th>元方法</th>
<th>触发场景</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>__add</code></td>
<td>表相加（<code>+</code>）</td>
<td><code>a + b</code></td>
</tr>
<tr>
<td><code>__sub</code></td>
<td>表相减（<code>-</code>）</td>
<td><code>a - b</code></td>
</tr>
<tr>
<td><code>__mul</code></td>
<td>表相乘（<code>*</code>）</td>
<td><code>a * b</code></td>
</tr>
<tr>
<td><code>__div</code></td>
<td>表相除（<code>/</code>）</td>
<td><code>a / b</code></td>
</tr>
<tr>
<td><code>__index</code></td>
<td>访问不存在的键</td>
<td><code>a.key</code></td>
</tr>
<tr>
<td><code>__newindex</code></td>
<td>设置不存在的键</td>
<td><code>a.key = value</code></td>
</tr>
<tr>
<td><code>__tostring</code></td>
<td>表被转换为字符串（如 <code>print</code>）</td>
<td><code>print(a)</code></td>
</tr>
</tbody></table>
<p>其他运算符:<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/blueberryzzz/p/8947446.html">元表的作用</a></p>
<p>具体说明：</p>
<h4 id="index-与-newindex"><a href="#index-与-newindex" class="headerlink" title="__index 与 __newindex"></a>__index 与 __newindex</h4><p>若setmetatable(B,A)：</p>
<ol>
<li><p>可以是函数：<br>A中有元方法__index,B不存在键key,则在调用B[key]时会调用A.__index。<br>__index &#x3D; function(t,k) t:table k:key<br>__newindex &#x3D; function(t,k,v) t:table k:key v:value</p>
</li>
<li><p>也可以是table。<br>__index：查找__index元方法表，若有该索引，则返回对应的值，否则返回nil。<br>__newindex：为表中不存在的索引赋值会将该索引和值赋到__newindex所指向的表中，不对原来的表进行改变。举例:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">mymetatable = &#123;&#125;</span><br><span class="line">mytable = <span class="built_in">setmetatable</span>(&#123;key1 = <span class="string">&quot;value1&quot;</span>&#125;, &#123; <span class="built_in">__newindex</span> = mymetatable &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mytable.key1)</span><br><span class="line"></span><br><span class="line">//由于metaTable，会直接设置到metaTable中</span><br><span class="line">mytable.newkey = <span class="string">&quot;新值2&quot;</span></span><br><span class="line"><span class="built_in">print</span>(mytable.newkey,mymetatable.newkey)</span><br><span class="line"></span><br><span class="line">mytable.key1 = <span class="string">&quot;新值1&quot;</span></span><br><span class="line"><span class="built_in">print</span>(mytable.key1,mymetatable.key1)</span><br><span class="line">//////</span><br><span class="line">输出:</span><br><span class="line">value1</span><br><span class="line"><span class="literal">nil</span>    新值<span class="number">2</span></span><br><span class="line">新值<span class="number">1</span>    <span class="literal">nil</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果不想触发元方法，则可以考虑rawget和rawset。</p>
</li>
</ol>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>进阶的话可以读读这篇文章：<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/623172037">一文帮你一劳永逸解决Lua面向对象</a></p>
<p>使用table + function来模拟类<br>使用metatable模拟继承（不推荐用，只模拟最基本的对象大部分实现够用了）。</p>
<p>类代码:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">ClassName = &#123;&#125;  <span class="comment">-- 创建一个表作为类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassName:new</span><span class="params">(...)</span></span></span><br><span class="line">    <span class="keyword">local</span> obj = &#123;&#125;  <span class="comment">-- 创建一个新的空表作为对象</span></span><br><span class="line">    <span class="built_in">setmetatable</span>(obj, <span class="built_in">self</span>)  <span class="comment">-- 设置元表，使对象继承类的方法</span></span><br><span class="line">    <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span>  <span class="comment">-- 设置索引元方法</span></span><br><span class="line">    <span class="comment">-- 初始化对象的属性</span></span><br><span class="line">    obj:init(...)  <span class="comment">-- 可选：调用初始化函数</span></span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>注意，由于元方法__index的特性：<br>在继承或创建对象时，如果类中有table类型的变量，需要重新进行初始化和赋值。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>和创建对象类似。且基类new中如果用的时self，也无需重写new方法。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">ClassName = &#123;&#125;</span><br><span class="line">//和上面代码一致，略。</span><br><span class="line"></span><br><span class="line">//继承类创建</span><br><span class="line">SubClassName = ClassName:new()</span><br><span class="line">//重写init函数即可</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClassName:init</span><span class="params">(...)</span></span></span><br><span class="line">&#123;</span><br><span class="line">   //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="私有实现"><a href="#私有实现" class="headerlink" title="私有实现"></a>私有实现</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/638232769">Lua中私有性的实现与应用</a></p>
<ol>
<li>local局部变量限制作用域</li>
<li>使用闭包实现私有<br>项目中简单的方法就是加一个内部属性private &#x3D; {}.这样封装一层外部一般也不会直接用到了。</li>
</ol>
<h3 id="方法调用-与"><a href="#方法调用-与" class="headerlink" title="方法调用 .与:"></a>方法调用 .与:</h3><p>.和:<br>:调用函数会传入一个self变量，同C++的this指针一般。<br>语法糖而已。<br>ObjectA.func1(self,num)<br>ObjectA:func1(num)</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/494191824">理解Lua的闭包机制</a><br>Lua中，函数是严格遵循词法定界的第一类值。<br>词法定界:函数可以访问包含其自身的外部函数中的变量。<br>第一类值：函数和其他常见类型的值具有同等权限。</p>
<p>闭包：<br>一个函数外加能够使得该函数正确访问非局部变量所需的其他机制。</p>
<p>捕获<br>沿着函数层级逐步向上搜索变量的过程，可以称为捕获，而被捕获的变量，在Lua中被称为上值，也就是Upvalue。</p>
<p>从技术上讲，Lua只有闭包，而没有函数。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在Lua编译器解析这段代码的时候，应该先将函数部分拆出来。</span></span><br><span class="line"><span class="comment">-- function() </span></span><br><span class="line"><span class="comment">--     print(&quot;hello world&quot;)</span></span><br><span class="line"><span class="comment">-- end</span></span><br><span class="line"><span class="comment">-- 存到一个常量表中，返回一个Id号，（假设是0）</span></span><br><span class="line"><span class="comment">-- 然后在代码运行的时候，将Id号的函数写入到test变量中</span></span><br></pre></td></tr></table></figure>
<p>一个函数在定义完成后，可以赋值给test等任何一个合法变量。而在赋值之前，称之为“函数原型”。</p>
<p>当Lua执行一个function…end时，创建一个新的对象，包含函数原型的引用、环境(用来查找全局变量的表)的引用，以及一个由所有upvalue引用组成的数组。</p>
<p>多个闭包可共用一个upvalue</p>
<h3 id="闭包的本质"><a href="#闭包的本质" class="headerlink" title="闭包的本质"></a>闭包的本质</h3><p>让我们把函数原型换成类，把闭包换成对象。一切就都可以解释了，无论什么时候，把一个函数原型赋值给一个变量时，<strong>Lua都会将这个函数原型实例化为一个闭包对象</strong>，无论这个闭包对象是否真的用到了所谓的上值表。当在Lua中调用函数或者传递函数对象时，都是在传递闭包对象，而非传递函数原型。</p>
<p>所以说白了，闭包就是函数原型的一个实例</p>
<p>所以它为什么叫闭包呢？就是因为当实例化一个函数原型为一个闭包时，这个函数原型已经捕获到了自己需要所有的上值对象，此后不会再进行任何其他捕获行为。它形成了一个自洽的体系，<strong>有自己内部的常量表，上值表，变量表</strong>。</p>
<p>这就是Lua的闭包机制，一种用到了OOP思想的机制。</p>
<h2 id="Lua-GC过程"><a href="#Lua-GC过程" class="headerlink" title="Lua GC过程"></a>Lua GC过程</h2><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/tardis/zm/art/133939450?source_id=1005">Lua GC机制分析与理解-上</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kekec/p/14151606.html">Lua GC基础</a><br>GC算法:<br><strong>Mark and Sweep 标记清除</strong></p>
<p>标记：每次执行GC时，先以若干<strong>根节点</strong>开始，逐个把直接或间接和它们相关的节点都做上标记；<br>清除：当标记完成后，遍历整个对象链表，把被标记为需要删除的节点一一删除即可。</p>
<p>标记 - 白 灰 黑<br>白：分为白1和白2。<strong>初始创建的对象为白1</strong>，在遍历清理后会变为白2。<strong>白2为可回收状态</strong>。<br>灰：中间状态。<br>黑：不可回收状态。</p>
<p>伪代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">每个新创建的对象颜色为白色(white)</span><br><span class="line"></span><br><span class="line">// 初始化阶段</span><br><span class="line">遍历在root节点中引用的对象从白色(white)置为灰色(gray),并且放入到灰色节点列表中.</span><br><span class="line"></span><br><span class="line">// 标记阶段</span><br><span class="line">当灰色链表中还有未扫描的元素:</span><br><span class="line">    从中取出一个对象,标记为黑色(black)</span><br><span class="line">    遍历这个对象关联的其他所有对象:</span><br><span class="line">        如果是白色(white):</span><br><span class="line">            标记为灰色(gray),加入灰色链表</span><br><span class="line"></span><br><span class="line">// 回收阶段</span><br><span class="line">遍历所有对象:</span><br><span class="line">    如果为白色(white):</span><br><span class="line">        这些对象都是没有被引用的对象,逐个回收</span><br><span class="line">    否则:</span><br><span class="line">        重新加入对象链表中等待下一轮的GC检查</span><br></pre></td></tr></table></figure>

<p>GC链条和数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CommonHeader </span></span><br><span class="line">GCObject *next; lu_byte tt; lu_byte marked</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Common type has only the common header</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GCObject</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Tagged Values. This is the basic representation of values in Lua,</span></span><br><span class="line"><span class="comment">** an actual value plus a tag with its type.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Union of all Lua values</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">Value</span> &#123;</span></span><br><span class="line">  GCObject *gc;    <span class="comment">/* collectable objects */</span></span><br><span class="line">  <span class="type">void</span> *p;         <span class="comment">/* light userdata */</span></span><br><span class="line">  <span class="type">int</span> b;           <span class="comment">/* booleans */</span></span><br><span class="line">  lua_CFunction f; <span class="comment">/* light C functions */</span></span><br><span class="line">  lua_Integer i;   <span class="comment">/* integer numbers */</span></span><br><span class="line">  lua_Number n;    <span class="comment">/* float numbers */</span></span><br><span class="line">&#125; Value;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TValuefields  Value value_; int tt_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lua_TValue</span> &#123;</span></span><br><span class="line">  TValuefields;</span><br><span class="line">&#125; TValue;</span><br></pre></td></tr></table></figure>
<p>其中next链接下一个GCObject，tt表明数据类型，marked用于存储之前提到的颜色。</p>
<h3 id="GCObject对象创建"><a href="#GCObject对象创建" class="headerlink" title="GCObject对象创建"></a>GCObject对象创建</h3><p>GCObject的初始化:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">以Table为例，会依次调用： （lvm.c）[luaV_execute]-&gt;(ltable.c)[luaH_new]-&gt;(lgc.c)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** create a new collectable object (with given type and size) and link</span></span><br><span class="line"><span class="comment">** it to &#x27;allgc&#x27; list.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">GCObject *<span class="title function_">luaC_newobj</span> <span class="params">(lua_State *L, <span class="type">int</span> tt, <span class="type">size_t</span> sz)</span> &#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  GCObject *o = cast(GCObject *, luaM_newobject(L, novariant(tt), sz));</span><br><span class="line">  o-&gt;marked = luaC_white(g);</span><br><span class="line">  o-&gt;tt = tt;</span><br><span class="line">  o-&gt;next = g-&gt;allgc;</span><br><span class="line">  g-&gt;allgc = o;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">global_State</span> &#123;</span></span><br><span class="line">   ......</span><br><span class="line">   GCObject *allgc;  <span class="comment">/* list of all collectable objects */</span></span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码可以看出来是一个GC对象链条。</p>
<h3 id="GC触发条件"><a href="#GC触发条件" class="headerlink" title="GC触发条件"></a>GC触发条件</h3><p>Lua分为自动、手动两种GC方式。 手动式。<br>自动见 lgc.h中luaC_condGC。<br>手动为collectgarbage的调用。<br>目前可以概括的说明luaGC的触发条件：当lua使用的内存达到阀值，便会触发GC。当然这个阀值是动态设定的。</p>
<h3 id="双白色"><a href="#双白色" class="headerlink" title="双白色"></a>双白色</h3><p>简单的说，Lua中的白色分为”当前白色(currentwhite)”和”非当前白色(otherwhite)”。</p>
<p>这两种白色的状态交替使用，第N次GC使用的是第一种白色，那么下一次就是另外一种，以此类推…</p>
<p>代码在回收时候会做判断，如果某个对象的白色不是此次GC回收使用的白色状态将不会被认为是没有被引用的对象而回收。</p>
<h3 id="GC函数状态机"><a href="#GC函数状态机" class="headerlink" title="GC函数状态机"></a>GC函数状态机</h3><p>三色表示使得GC可以分步进行，提高实时性。<br>相关原理可以看之前提到的伪代码。</p>
<p>GC流程见lgc.h的singlestep</p>
<table>
<thead>
<tr>
<th>状态（State）</th>
<th>分步（Step）</th>
<th>说明（Description）</th>
</tr>
</thead>
<tbody><tr>
<td>GCSpause<br>（GC开始阶段）</td>
<td>不分步（原子操作）</td>
<td>- 开启新一轮 GC。<br>- 从 root 节点开始遍历并标记（mark）。<br>- <code>table</code>、<code>proto</code>、<code>closure</code>、<code>thread</code> 对象标记为 <strong>gray</strong>，加入 <code>g-&gt;gray</code> 链表。<br>- <code>string</code>、<code>userdata</code> 对象直接标记为 <strong>黑色</strong>。<br>- 遍历完成后，切换到 <code>GCSpropagate</code>。</td>
</tr>
<tr>
<td>GCSpropagate<br>（扫描标记阶段）</td>
<td>分步</td>
<td>- 每次从 <code>g-&gt;gray</code> 链表取出一个对象，先标记为 <strong>black</strong>。<br>- 若对象是弱表或 thread，加入 <code>g-&gt;grayagain</code> 链表。<br>- 遍历该对象的子项，对未标记的对象进行 mark，并加入 <code>g-&gt;gray</code>。<br>- 重复直到 <code>g-&gt;gray</code> 为空，切换到 <code>GCSatomic</code>。</td>
</tr>
<tr>
<td>GCSatomic<br>（再次标记、处理 finalizer 和弱表）</td>
<td>不分步（原子操作）</td>
<td>- 再次从 root 节点遍历，重新标记（mark），处理 <code>GCSpropagate</code> 期间可能的变化。未标记的对象加入 <code>g-&gt;gray</code>。<br>- 遍历 <code>g-&gt;gray</code> 完成所有对象标记。<br>- 遍历 <code>g-&gt;grayagain</code> 完成标记。<br>- 遍历弱表，将白色项置为 <code>nil</code>。<br>- 遍历 <code>g-&gt;finobj</code>，将白色对象移至 <code>g-&gt;tobefnz</code>。<br>- 遍历 <code>g-&gt;tobefnz</code>，完成标记。<br>- 切换当前白色到另一种白色。·<br>- 切换到 <code>GCSswpallgc</code>。</td>
</tr>
<tr>
<td>GCSswpallgc<br>（清除阶段：普通对象）</td>
<td>分步</td>
<td>- 每次从 <code>g-&gt;allgc</code> 链表取最多 <code>GCSWEEPMAX</code>（100）个对象。<br>- 清理仍为“上一种白色”的对象（即未被标记的对象）。<br>- 将黑色对象重新标记为当前白色。<br>- 遍历完成后，切换到 <code>GCSswpfinobj</code>。</td>
</tr>
<tr>
<td>GCSswpfinobj<br>（清除阶段：带 finalizer 的对象）</td>
<td>分步</td>
<td>- 每次从 <code>g-&gt;finobj</code> 链表取最多 <code>GCSWEEPMAX</code>（100）个对象。<br>- 清理仍为“上一种白色”的对象。<br>- 将黑色对象标记为当前白色。<br>- 遍历完成后，切换到 <code>GCSswptobefnz</code>。</td>
</tr>
<tr>
<td>GCSswptobefnz<br>（清除阶段：待执行 finalizer 的对象）</td>
<td>分步</td>
<td>- 每次从 <code>g-&gt;tobefnz</code> 链表取最多 <code>GCSWEEPMAX</code>（100）个对象。<br>- 清理仍为“上一种白色”的对象。<br>- 将黑色对象标记为当前白色。<br>- 遍历完成后，切换到 <code>GCSswpend</code>。</td>
</tr>
<tr>
<td>GCSswpend<br>（结束清除）</td>
<td>不分步（原子操作）</td>
<td>- 收缩全局字符串哈希表（string table），确保哈希桶利用率 &gt; 1&#x2F;4。<br>- 切换到 <code>GCScallfin</code>。</td>
</tr>
<tr>
<td>GCScallfin<br>（执行 finalizer）</td>
<td>分步</td>
<td>- 每次从 <code>g-&gt;tobefnz</code> 链表取最多 <code>GCFINMAX</code>（10）个对象。<br>- 执行其 <code>__gc</code> 元方法（finalizer）。<br>- 执行后将对象标记为白色，并加入 <code>g-&gt;allgc</code>，等待下一轮 GC 清理。<br>- 当 <code>g-&gt;tobefnz</code> 为空时，切换回 <code>GCSpause</code>，完成一轮 GC。</td>
</tr>
</tbody></table>
<p>g-&gt;allgc: 所有可回收的对象链表。<br>g-&gt;finobj: 带__gc元方法的对象链表。<br>g-&gt;tobefnz: 没有引用的带 __gc元方法的对象链表。<br>新建对象时，对象会加入 g-&gt;allgc 链表，当对象设置 __gc元方法时，这个对象会从 g-&gt;allgc 移到 g-&gt;finobj 链表，当这个对象不再引用后，从 g-&gt;finobj 移到 g-&gt;tobefnz，执行 __gc元方法后，对象再移回到 g-&gt;allgc，等下一次 gc 清理。</p>
<h3 id="分代GC-（Lua5-4）"><a href="#分代GC-（Lua5-4）" class="headerlink" title="分代GC （Lua5.4）"></a>分代GC （Lua5.4）</h3><p>经验表明，大部分对象在被分配之后很快就被回收掉了（如栈上的临时变量），长时间存活的对象很大可能会一直存活下去。所以，垃圾回收可以集中精力去回收刚刚造出来的对象。</p>
<p>将所有gc对象分成两种，young和old；过程也分为minor（浅扫描，或次级收集周期）和major（深扫描，或主收集周期）。</p>
<p>对象创建时标记为young，minor过程扫描young对象，当young节点活过了两次gc过程，就会标记成old对象 。</p>
<h2 id="C-和Lua通信-Lua堆栈"><a href="#C-和Lua通信-Lua堆栈" class="headerlink" title="C++和Lua通信 Lua堆栈"></a>C++和Lua通信 Lua堆栈</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq826364410/article/details/88624824">C++和Lua交互总结</a><br>Lua提供一个<strong>虚拟的堆栈</strong>来进行数据交互</p>
<p>Lua中，对虚拟栈提供正向索引和反向索引两种索引方式，区别是：正数索引1永远表示栈底，负数索引-1永远表示栈顶。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了能够正确实现C++ 代码调用其他C语言代码。</span></span><br><span class="line"><span class="comment">//加上extern “C”后，会指示编译器这部分代码按c语言的进行编译，而不是C++</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lua.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lauxlib.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lualib.h&quot;</span>  </span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//1.创建一个state  </span></span><br><span class="line">   <span class="comment">// luaL_newstate返回一个指向堆栈的指针</span></span><br><span class="line">   lua_State *L = <span class="built_in">luaL_newstate</span>();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.入栈操作  </span></span><br><span class="line">   <span class="built_in">lua_pushstring</span>(L, <span class="string">&quot;I am so cool~&quot;</span>);</span><br><span class="line">   <span class="built_in">lua_pushnumber</span>(L, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.取值操作  </span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">lua_isstring</span>(L, <span class="number">1</span>)) &#123;             <span class="comment">//判断是否可以转为string  </span></span><br><span class="line">      cout &lt;&lt; <span class="built_in">lua_tostring</span>(L, <span class="number">1</span>) &lt;&lt; endl;  <span class="comment">//转为string并返回  </span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">lua_isnumber</span>(L, <span class="number">2</span>)) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="built_in">lua_tonumber</span>(L, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//4.关闭state  </span></span><br><span class="line">   <span class="built_in">lua_close</span>(L);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的交互方式可以参考对应的博客。</p>
<h2 id="异常捕获pcall和xpcall-堆栈信息"><a href="#异常捕获pcall和xpcall-堆栈信息" class="headerlink" title="异常捕获pcall和xpcall 堆栈信息"></a>异常捕获pcall和xpcall 堆栈信息</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/CSDN_HZW/article/details/138195616">lua中的pcall和xpcall和直接调用一个函数的区别</a><br><a target="_blank" rel="noopener" href="https://plumephp.com/lua%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B2.3%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E6%8D%95%E6%8D%89%E4%B8%8E%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/">《Lua高级编程》2.3 错误处理、异常捕捉与调试技巧</a></p>
<p>类似于try catch。xpcall可以指定错误处理函数。</p>
<h3 id="堆栈信息"><a href="#堆栈信息" class="headerlink" title="堆栈信息"></a>堆栈信息</h3><p>debug.traceback() - 获取当前的调用堆栈信息，对异常调试非常有用。<br>debug.getinfo() - 获取函数的调用信息，例如函数名称、定义位置、当前行号等。<br>可以结合xpcall来应用</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Table源码分析"><a href="#Table源码分析" class="headerlink" title="Table源码分析"></a>Table源码分析</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/295524176">【Lua源码赏析】第四章 Table 的实现</a></p>
<p>不同版本的源码有所不同。Table的部分可以见文件lobject.h<br>以下源码基于 Lua5.4.2</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Union of all Lua values</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">Value</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">GCObject</span> *<span class="title">gc</span>;</span>    <span class="comment">/* collectable objects */</span></span><br><span class="line">  <span class="type">void</span> *p;         <span class="comment">/* light userdata */</span></span><br><span class="line">  lua_CFunction f; <span class="comment">/* light C functions */</span></span><br><span class="line">  lua_Integer i;   <span class="comment">/* integer numbers */</span></span><br><span class="line">  lua_Number n;    <span class="comment">/* float numbers */</span></span><br><span class="line">&#125; Value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Tagged Values. This is the basic representation of values in Lua:</span></span><br><span class="line"><span class="comment">** an actual value plus a tag with its type.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TValuefields	Value value_; lu_byte tt_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TValue</span> &#123;</span></span><br><span class="line">  TValuefields;</span><br><span class="line">&#125; TValue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Nodes for Hash tables: A pack of two TValue&#x27;s (key-value pairs)</span></span><br><span class="line"><span class="comment">** plus a &#x27;next&#x27; field to link colliding entries. The distribution</span></span><br><span class="line"><span class="comment">** of the key&#x27;s fields (&#x27;key_tt&#x27; and &#x27;key_val&#x27;) not forming a proper</span></span><br><span class="line"><span class="comment">** &#x27;TValue&#x27; allows for a smaller size for &#x27;Node&#x27; both in 4-byte</span></span><br><span class="line"><span class="comment">** and 8-byte alignments.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">NodeKey</span> &#123;</span></span><br><span class="line">    TValuefields;  <span class="comment">/* fields for value */</span></span><br><span class="line">    lu_byte key_tt;  <span class="comment">/* key type */</span></span><br><span class="line">    <span class="type">int</span> next;  <span class="comment">/* for chaining */</span></span><br><span class="line">    Value key_val;  <span class="comment">/* key value */</span></span><br><span class="line">  &#125; u;</span><br><span class="line">  TValue i_val;  <span class="comment">/* direct access to node&#x27;s value as a proper &#x27;TValue&#x27; */</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  lu_byte flags;  <span class="comment">/* 1&lt;&lt;p means tagmethod(p) is not present */</span></span><br><span class="line">  lu_byte lsizenode;  <span class="comment">/* log2 of size of &#x27;node&#x27; array */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> alimit;  <span class="comment">/* &quot;limit&quot; of &#x27;array&#x27; array */</span></span><br><span class="line">  TValue *<span class="built_in">array</span>;  <span class="comment">/* array part */</span></span><br><span class="line">  Node *node;</span><br><span class="line">  Node *lastfree;  <span class="comment">/* any free position is before this position */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> *<span class="title">metatable</span>;</span></span><br><span class="line">  GCObject *gclist;</span><br><span class="line">&#125; Table;</span><br></pre></td></tr></table></figure>

<h4 id="存储部分"><a href="#存储部分" class="headerlink" title="存储部分"></a>存储部分</h4><p>Table的存储可以分为数组部分（TValue * array）和哈希部分（Node * node）。</p>
<ul>
<li><p>数组部分：</p>
<ul>
<li>从下标为1开始的，紧凑高效的随机访问。</li>
<li>长度见alimit.</li>
</ul>
</li>
<li><p>哈希部分：</p>
<ul>
<li>不支持nil作为键。</li>
<li>长度见lsizenode。可以看到其大小必定为2的整数次幂</li>
</ul>
</li>
</ul>
<p>每个 Table 结构，最多会由三块连续内存构成。</p>
<ul>
<li>一个 table 结构，</li>
<li>一块存放了连续整数索引的数组，</li>
<li>和一块大小为 2 的整数次幂的哈希表。</li>
</ul>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>读、写、迭代和获取长度。Lua没有删除操作，而仅仅把键对应的值设置为nil。<br>相关源码见ltable.c</p>
<ul>
<li>luaH_newkey</li>
<li>luaH_get<ul>
<li>当查询键为<strong>整数键且在数组范围内</strong>时，在数组部分查询。否则，根据键的哈希值去哈希表中查询。拥有相同哈希值的冲突键值对，在哈希表中由 Node 的 next 域单向链起来，所以遍历这个链表就可以了。</li>
</ul>
</li>
<li>扩容rehash和luaH_resize<ul>
<li>rehash 的主要工作是统计当前 table中到底有多少有效键值对，以及决定数组部分需要开辟多少空间。其原则是最终数组部分的利用率需要超过 50% （<strong>不仅会对数组扩容，也可能缩减数组</strong>）。</li>
<li>扩容大小见computesizes。扩容按2的幂次进行。</li>
</ul>
</li>
<li>迭代 luaH_next</li>
<li>获取长度 luaH_getn <ul>
<li>只对序列表有效。采用二分法。</li>
</ul>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li><p>在对table操作时，尽量不要触发rehash操作，因为这个开销是非常大的。在对table插入新的键值对时（也就是说key原来不在table中），可能会触发rehash操作，而直接修改已存在key对于的值，不会触发rehash操作的，包括赋值为nil。</p>
</li>
<li><p>在遍历一个table时，<strong>不允许插入</strong>一个新键，否则将无法预测后续的遍历行为，但lua允许在遍历过程中，修改table中已存在的<strong>键对应的值</strong>，包括修改后的值为nil，也是允许的。</p>
</li>
<li><p>table中要想删除一个元素等同于向对应key赋值为nil，等待<strong>垃圾回收</strong>。但是删除table一个元素时候，并不会触发表重构行为，即不会触发rehash操作。</p>
</li>
<li><p>为了减少rehash操作，当构造一个数组时，如果预先知道其大小，可以预分配数组大小。在脚本层可以使用local t &#x3D; {nil,nil,nil}来预分配数组大小。在C语言层，可以使用接口void lua_createtable (lua_State *L, int narr, int nrec);来预分配数组大小。</p>
</li>
<li><p>注意在使用长度操作符#对数组其长度时，数组不应该包含nil值，否则很容易出错。</p>
</li>
</ul>
<!-- flag of hidden posts --></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://MikeMing126.github.io">Ming</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mikeming126.github.io/Mine/Lua/">https://mikeming126.github.io/Mine/Lua/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://MikeMing126.github.io" target="_blank">Ming Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/head.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Ming</div><div class="author-info-description">我们都在奔赴各自的人生，但你依旧是你</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Lua"><span class="toc-number">1.</span> <span class="toc-text">Lua</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">变长参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="toc-number">1.1.2.</span> <span class="toc-text">字符串拼接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E8%A1%A8-Metatable-%E5%85%83%E6%96%B9%E6%B3%95-Metamethod"><span class="toc-number">1.2.</span> <span class="toc-text">元表 Metatable 元方法 Metamethod</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">元方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#index-%E4%B8%8E-newindex"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">__index 与 __newindex</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.3.1.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text">私有实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8-%E4%B8%8E"><span class="toc-number">1.3.3.</span> <span class="toc-text">方法调用 .与:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">1.4.</span> <span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">闭包的本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lua-GC%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.</span> <span class="toc-text">Lua GC过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GCObject%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA"><span class="toc-number">1.5.1.</span> <span class="toc-text">GCObject对象创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.5.2.</span> <span class="toc-text">GC触发条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E7%99%BD%E8%89%B2"><span class="toc-number">1.5.3.</span> <span class="toc-text">双白色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%E5%87%BD%E6%95%B0%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">1.5.4.</span> <span class="toc-text">GC函数状态机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E4%BB%A3GC-%EF%BC%88Lua5-4%EF%BC%89"><span class="toc-number">1.5.5.</span> <span class="toc-text">分代GC （Lua5.4）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%92%8CLua%E9%80%9A%E4%BF%A1-Lua%E5%A0%86%E6%A0%88"><span class="toc-number">1.6.</span> <span class="toc-text">C++和Lua通信 Lua堆栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7pcall%E5%92%8Cxpcall-%E5%A0%86%E6%A0%88%E4%BF%A1%E6%81%AF"><span class="toc-number">1.7.</span> <span class="toc-text">异常捕获pcall和xpcall 堆栈信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%E4%BF%A1%E6%81%AF"><span class="toc-number">1.7.1.</span> <span class="toc-text">堆栈信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.8.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Table%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.8.1.</span> <span class="toc-text">Table源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E9%83%A8%E5%88%86"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">存储部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.8.1.3.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/PostProcessing/" title="Unity PostProcessing">Unity PostProcessing</a><time datetime="2025-10-05T09:10:14.356Z" title="发表于 2025-10-05 17:10:14">2025-10-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/Shadow/" title="Unity Shadow">Unity Shadow</a><time datetime="2025-10-05T07:56:07.434Z" title="发表于 2025-10-05 15:56:07">2025-10-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/SRP/" title="Unity SRP">Unity SRP</a><time datetime="2025-10-02T06:15:27.265Z" title="发表于 2025-10-02 14:15:27">2025-10-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/AsyncOp/" title="Unity异步操作">Unity异步操作</a><time datetime="2025-09-14T08:01:59.349Z" title="发表于 2025-09-14 16:01:59">2025-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/Physics/" title="Unity Physics">Unity Physics</a><time datetime="2025-09-14T08:01:59.345Z" title="发表于 2025-09-14 16:01:59">2025-09-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/starBg2.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2025 By Ming</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23liMdTJDdBPikGC2F',
      clientSecret: 'eed0ab3cb8494f9e22f7a8bb469c58cc7e6fbaea',
      repo: 'BlogComment',
      owner: 'MikeMing126',
      admin: ['MikeMing126'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'e52d8839398095884992dac35e2e4ab9'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script src="/script/APlayerHolder.js"></script><div class="aplayer" data-id="13402811242" data-server="netease" data-type="playlist" data-fixed="true" data-loop="all" data-autoplay="true" data-order="random" data-theme="#3F51B5"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>