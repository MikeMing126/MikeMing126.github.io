<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Unity DOTS | Ming Blog</title><meta name="robots" content="noindex"><meta name="author" content="Ming"><meta name="copyright" content="Ming"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="DOTS Unity Data-Oriented Technology StackDOTS官方文档 概述 Unity ECS重点组件系统。面向数据框架。注意这个数据。因此很多实现，是基于struct而非class。 Burst Compiler编译器，使用LLVM从IL&#x2F;.NET字节码转换为高度优化的本机代码的编译器。 Job System利用多核、多线程。  JobSystemUnit">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity DOTS">
<meta property="og:url" content="https://mikeming126.github.io/Mine/Unity/DOTS/index.html">
<meta property="og:site_name" content="Ming Blog">
<meta property="og:description" content="DOTS Unity Data-Oriented Technology StackDOTS官方文档 概述 Unity ECS重点组件系统。面向数据框架。注意这个数据。因此很多实现，是基于struct而非class。 Burst Compiler编译器，使用LLVM从IL&#x2F;.NET字节码转换为高度优化的本机代码的编译器。 Job System利用多核、多线程。  JobSystemUnit">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mikeming126.github.io/img/head.png">
<meta property="article:published_time" content="2025-09-14T08:01:59.348Z">
<meta property="article:modified_time" content="2025-09-14T08:04:35.434Z">
<meta property="article:author" content="Ming">
<meta property="article:tag" content="Unity">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mikeming126.github.io/img/head.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Unity DOTS",
  "url": "https://mikeming126.github.io/Mine/Unity/DOTS/",
  "image": "https://mikeming126.github.io/img/head.png",
  "datePublished": "2025-09-14T08:01:59.348Z",
  "dateModified": "2025-09-14T08:04:35.434Z",
  "author": [
    {
      "@type": "Person",
      "name": "Ming",
      "url": "https://mikeming126.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://mikeming126.github.io/Mine/Unity/DOTS/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":4,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Unity DOTS',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/starBg2.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/starBg2.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Ming Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Unity DOTS</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Unity DOTS</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-14T08:01:59.348Z" title="发表于 2025-09-14 16:01:59">2025-09-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-14T08:04:35.434Z" title="更新于 2025-09-14 16:04:35">2025-09-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Unity/">Unity</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">5.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>DOTS Unity Data-Oriented Technology Stack<br><a target="_blank" rel="noopener" href="https://unity.com/dots">DOTS官方文档</a></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>Unity ECS<br>重点组件系统。面向数据框架。注意这个数据。因此很多实现，是基于struct而非class。</li>
<li>Burst Compiler<br>编译器，使用LLVM从IL&#x2F;.NET字节码转换为高度优化的本机代码的编译器。</li>
<li>Job System<br>利用多核、多线程。</li>
</ul>
<h1 id="JobSystem"><a href="#JobSystem" class="headerlink" title="JobSystem"></a>JobSystem</h1><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7528436312074043438">Unity入门教程之异步篇第四节：Unity 高性能计算？Job System 与 Burst Compiler!</a><br>对于异步操作有UniTask。但是直接使用UniTask进行多线程编程也存在一些问题：</p>
<ul>
<li>线程安全的复杂性：需要手动处理临界资源，管理锁、原子操作、线程安全集合等。</li>
<li>需要处理和主线程通信的逻辑</li>
<li>性能瓶颈 即便多线程，如果数据结构不优化，CPU 缓存命中率低，或者没有利用好 SIMD 指令，也无法达到极致性能。</li>
</ul>
<p>JobSystem优势：</p>
<ul>
<li>零GC分配</li>
<li>自动并行化处理，无需关心线程管理。</li>
<li>安全系统，避免冲突问题</li>
</ul>
<h2 id="官方案例"><a href="#官方案例" class="headerlink" title="官方案例"></a>官方案例</h2><p><a target="_blank" rel="noopener" href="https://github.com/Unity-Technologies/EntityComponentSystemSamples">GitHub - EntityComponentSystemSamples</a><br>其中的JobSystem101.<br>实际PC上，即便是单线程任务，其也能提升许多效率。</p>
<h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/job-system-overview.html">官方Doc - JobSystem Overview</a></p>
<p>可以单独使用JobSystem，但最好是一起用上Burst Compiler。(which is specifically designed to compile jobs for Unity’s job system)</p>
<ul>
<li>Multithreading</li>
<li>Work stealing<ul>
<li>平衡各个工作线程共享的任务量</li>
</ul>
</li>
<li>Safety System<ul>
<li>检测竞争条件。处理依赖关系。</li>
<li>使用主线程数据时，不是引用而是副本，从而避免竞争</li>
<li>只能访问可直接复制的数据类型(Only Access blittable data types)<ul>
<li>具体而言，其在托管内存和非托管内存中具有通用的表示形式。<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Blittable_types">Wikipedia</a></li>
<li>大部分非用户定义的值类型，但是不包含Boolean,Char。</li>
</ul>
</li>
<li>使用memcpy复制blittable types。在managed and native parts之间传输。<ul>
<li><blockquote>
<p>It uses memcpy to put data into native memory when scheduling jobs and gives the managed side access to that copy when executing jobs.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Jobs"><a href="#Jobs" class="headerlink" title="Jobs"></a>Jobs</h2><p>Job - 执行一项特定任务的最小单元。可以独立或者依赖于其他Job。<br>注意，是实现了特定接口的<strong>结构体</strong>。</p>
<blockquote>
<p>In Unity, a job refers to any <strong>struct</strong> that implements the IJob interface.</p>
</blockquote>
<p>关键点：</p>
<ul>
<li><strong>仅主线程可以调度和完成Jobs</strong> Only the main thread can schedule and complete jobs. </li>
<li><strong>主线程不能访问运行中的Jobs的内容</strong> It can’t access the content of any running jobs</li>
<li><strong>两个Jobs之间不能同时访问相同的内容</strong> Two jobs can’t access the contents of a job at the same time. </li>
<li>To ensure efficient running of jobs, you can make them dependent on each other. Unity’s job system allows you to create complex dependency chains to ensure that your jobs complete in the correct order.</li>
</ul>
<h3 id="Job定义"><a href="#Job定义" class="headerlink" title="Job定义"></a>Job定义</h3><p>类型:</p>
<ol>
<li>IJob - Runs a single task on a job thread.</li>
<li>IJobParallelFor - Runs a task in parallel. Each worker thread that runs in parallel <strong>has an exclusive index</strong> to access <strong>shared data</strong> between worker threads safely.</li>
<li>IJobParallelForTransform - Runs a task in parallel. Each worker thread running in parallel <strong>has an exclusive Transform</strong> from the transform hierarchy to operate on.</li>
<li>IJobFor - The same as IJobParallelFor, but <strong>allows you to schedule the job so that it doesn’t run in parallel</strong>.</li>
</ol>
<h3 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h3><blockquote>
<p>The job system works best when you use it with the Burst compiler. Because Burst doesn’t support managed objects, you need to use unmanaged types to access the data in jobs. You can do this with blittable types, or use Unity’s built-in NativeContainer objects.</p>
</blockquote>
<ul>
<li>使用NativeArray<T> 避免数据复制。NativeArray将数据存储在非托管内容（因此原始的Job的都指向同一内存），且JobSystem确保不会同时读写。（确保数据访问线程安全）<ul>
<li>其他还有NativeList,NativeQueue,NativeHashMap,NativeHashSet等等。</li>
<li>对于不需写的数据，使用属性[ReadOnly]进行标记。</li>
<li>注意用Dispose进行内存释放。</li>
<li>参考文档<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/job-system-native-container.html">NativeContainer</a></li>
</ul>
</li>
<li>不要访问非只读数据和可修改的静态数据。</li>
<li>A job should not perform I&#x2F;O.</li>
<li>A job should not access managed objects.</li>
</ul>
<blockquote>
<p>Important: There’s no protection against accessing non-readonly or mutable static data from within a job. Accessing this kind of data circumvents all safety systems and might crash your application or the Unity Editor.</p>
</blockquote>
<h3 id="调度流程"><a href="#调度流程" class="headerlink" title="调度流程"></a>调度流程</h3><p>1.创建Job，实现对应的Job接口，如IJob，实现Execute方法。<br>2.调度Job，调用Schedule。（Jobs Run 用来在主线程立即执行，用于调试）<br>3.完成，读取数据。在JobHandle调用Complete方法。记得要调用Complete，否则可能会存在内存泄漏。 - It’s best practice to call Complete as late as possible in your code. </p>
<p>Best Practices For Schedule and Complete：</p>
<ul>
<li>一旦数据准备好，就调用Schedule。</li>
<li>在需要结果之前，不要调用Complete。</li>
<li>进行作业分配，考虑把不太重要的作业安排在框架的某个部分。</li>
<li>避免长时间的作业，因为一旦开始，其必须完成，不会放弃。将长时作业分为多个小的，互相依赖的作业。</li>
</ul>
<h4 id="Complete"><a href="#Complete" class="headerlink" title="Complete"></a>Complete</h4><p>可以通过JobHandle的IsComplete方法判断是否完成。<br>Complete会强制等待Job完成。如果 Job 尚未完成，调用 Complete() 会阻塞主线程直到Job完成。通常在需要读取 Job 结果前调用。</p>
<p>其执行逻辑如下:</p>
<ul>
<li>Completes all dependencies of the job (including the dependencies of the dependencies, recursively).</li>
<li>Waits for the job to finish execution (if it hasn’t finished already).</li>
<li>Removes all remaining references to the job from the job queue.</li>
</ul>
<p>对于已经完成的JobHandle调用Complete不会有影响，也不会抛出错误。</p>
<h3 id="依赖-Dependecy"><a href="#依赖-Dependecy" class="headerlink" title="依赖 Dependecy"></a>依赖 Dependecy</h3><ul>
<li>在Schedule时传入JobHandle作为依赖</li>
<li>使用JobHandle.CombineDependencies合并多个依赖的JobHandle</li>
</ul>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//GetHandle</span><br><span class="line">JobHandle tempJobHandle = testIJob1.Schedule();</span><br><span class="line">JobHandle tempJobHandle2 = testIJob2.Schedule();</span><br><span class="line"></span><br><span class="line">//CombineHandle</span><br><span class="line">//JobHandle CombinedJobHandle = JobHandle.CombineDependencies(tempJobHandle, tempJobHandle2);</span><br><span class="line">NativeArray&lt;JobHandle&gt; jobHandleArray = new NativeArray&lt;JobHandle&gt;(10, Allocator.Temp);</span><br><span class="line">jobHandleArray[0] = tempJobHandle;</span><br><span class="line">jobHandleArray[1] = tempJobHandle2;</span><br><span class="line">JobHandle CombinedJobHandle = JobHandle.CombineDependencies(jobHandleArray);</span><br><span class="line"></span><br><span class="line">//ScheduleJobWithDependence</span><br><span class="line">DJob1 DpJob = new DJob1() &#123; nativeIntArray1 = this.nativeIntArray ,nativeIntArray2 = tempArray&#125;;</span><br><span class="line">JobHandle dpJobHandle = DpJob.Schedule(CombinedJobHandle);</span><br></pre></td></tr></table></figure>

<h3 id="并行作业-Parallel-Job"><a href="#并行作业-Parallel-Job" class="headerlink" title="并行作业 Parallel Job"></a>并行作业 Parallel Job</h3><p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/job-system-parallel-for-jobs.html">Parallel jobs 并行作业</a><br>IJobParallelFor</p>
<blockquote>
<p>A ParallelFor job <strong>uses a NativeArray of data to act on as its data source</strong>. ParallelFor jobs run across multiple CPU cores. There’s one job per core, with each handling a subset of the workload.</p>
</blockquote>
<p>其Execute针对数据源中的每个项目执行一次。此外，Execute还有一个整数参数索引，用于访问和操作单个数据源。</p>
<p>测试案例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct PJob1: IJobParallelFor</span><br><span class="line">&#123;</span><br><span class="line">    public NativeArray&lt;float&gt; inValueArray1;</span><br><span class="line">    [ReadOnly] //由于多个Jobs可能同时读取同一个位置的值 必须加上ReadOnly</span><br><span class="line">    public NativeArray&lt;float&gt; inValueArray2;</span><br><span class="line">    </span><br><span class="line">    public NativeArray&lt;float&gt; resultArray;</span><br><span class="line"></span><br><span class="line">    public void Execute (int index)</span><br><span class="line">    &#123;</span><br><span class="line">        float addValue = 0;</span><br><span class="line">        addValue = (index %2==0)?inValueArray2[index]:inValueArray2[index+1];</span><br><span class="line">        resultArray[index] = inValueArray1[index] + addValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//...</span><br><span class="line">void TestFunForParral()</span><br><span class="line">&#123;</span><br><span class="line">    NativeArray&lt;float&gt; inValueArray1 = new NativeArray&lt;float&gt;(5, Allocator.TempJob);</span><br><span class="line">    NativeArray&lt;float&gt; inValueArray2 = new NativeArray&lt;float&gt;(10, Allocator.TempJob);</span><br><span class="line">    NativeArray&lt;float&gt; resultArray = new NativeArray&lt;float&gt;(5, Allocator.TempJob);</span><br><span class="line"></span><br><span class="line">    for (int a = 0; a &lt; 5; a++)</span><br><span class="line">    &#123;</span><br><span class="line">        inValueArray1[a] = a+1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int a = 0; a &lt; 10; a++)</span><br><span class="line">    &#123;</span><br><span class="line">        inValueArray2[a] = (a+1)*10;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    PJob1 pJob = new PJob1()</span><br><span class="line">    &#123;</span><br><span class="line">        inValueArray1 = inValueArray1,</span><br><span class="line">        inValueArray2 = inValueArray2,</span><br><span class="line">        resultArray = resultArray</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    //第二个参数BatchSize处理如何分批。实际测试后设置值。</span><br><span class="line">    // The second parameter is the batch size,</span><br><span class="line">    // essentially the no-overhead innerloop that just invokes Execute(i) in a loop.</span><br><span class="line">    // When there is a lot of work in each iteration then a value of 1 can be sensible.</span><br><span class="line">    // When there is very little work values of 32 or 64 can make sense.</span><br><span class="line">    JobHandle handle = pJob.Schedule(resultArray.Length, 32);</span><br><span class="line">    </span><br><span class="line">    handle.Complete();</span><br><span class="line">    for (int i = 0; i &lt; resultArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError($&quot;resultArray[&#123;i&#125;]=&#123;resultArray[i]&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    inValueArray1.Dispose();</span><br><span class="line">    inValueArray2.Dispose();</span><br><span class="line">    resultArray.Dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ParallelForTransform"><a href="#ParallelForTransform" class="headerlink" title="ParallelForTransform"></a>ParallelForTransform</h4><p>设计专门用于操作Transform.<br>由于 Transform 是 Unity 场景中最频繁被修改的组件之一，这个 Job 类型在性能优化上意义重大。<br>使用TransformAccessArray来传递TransformArray。</p>
<p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Jobs.IJobParallelForTransform.html">官方示例</a></p>
<h1 id="Burst-Compiler"><a href="#Burst-Compiler" class="headerlink" title="Burst Compiler"></a>Burst Compiler</h1><blockquote>
<p>Compile compatible sections of your C# code into highly-optimized native CPU code.</p>
</blockquote>
<p>一般针对JobSystem。也可以用于编译静态方法。<br>只需要在对应的Job数据结构&#x2F;静态方法上加上属性[BurstCompile]即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[BurstCompile]</span><br><span class="line">struct MyJob : IJob</span><br><span class="line">&#123;</span><br><span class="line">    public NativeArray&lt;int&gt; nativeIntArray;</span><br><span class="line">    public void Execute()</span><br><span class="line">    &#123;</span><br><span class="line">        nativeIntArray[0] = nativeIntArray[0] + 10;</span><br><span class="line">        Debug.LogError(&quot;ExecuteJob&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ECS"><a href="#ECS" class="headerlink" title="ECS"></a>ECS</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>添加Package：</p>
<ul>
<li>com.unity.entities</li>
<li>com.unity.entities.graphics</li>
</ul>
<p>设置禁用 重新加载域<br>ProjectSettings-&gt;Editor:<br>EnterPlayerMode ✔<br>Reload Domain ×<br>Reload Scene ×</p>
<p>ECS相关的信息都需要单独查看。<br>Window - Entities - 各类窗口</p>
<h3 id="常用包"><a href="#常用包" class="headerlink" title="常用包"></a>常用包</h3><ul>
<li>entities</li>
<li>C# JobSystem</li>
<li>Burst Compiler</li>
<li>Collections: A set of unmanaged collection types.</li>
<li>Mathematics:针对Burst-compiled做了优化的数学库</li>
</ul>
<h2 id="WorkFlow"><a href="#WorkFlow" class="headerlink" title="WorkFlow"></a>WorkFlow</h2><ul>
<li>Subscene 子场景。将GameObjects和MonoBehaviour添加到子场景中，将转换为实体Entites和对应的ECS components。</li>
<li>Entity 对应GameObject</li>
<li>Component 对应MonoBehaviour，可以创建专门的Baker用于转换MonoBehaviour为Component。（一般Component用Authoring作为结尾。）</li>
<li>System 默认情况下在主线程执行。需要多线程的可以用JobSystem。</li>
</ul>
<h3 id="了解Baking-Process"><a href="#了解Baking-Process" class="headerlink" title="了解Baking Process"></a>了解Baking Process</h3><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=r337nXZFYeA">官方Youtube视频</a><br>简而言之，虽然Editor里面还是GO和Component，但在Subscene下执行了Baking process后，实际上运行时都是对应的实体和组件。</p>
<p>运行时加载的其实是baking wrold。因此Baking Process中的序列化也是很重要的。</p>
<p>Baker其实是给对应的组件持有GameObject添加对应的Component。</p>
<h2 id="Entity-And-Component-概述"><a href="#Entity-And-Component-概述" class="headerlink" title="Entity And Component 概述"></a>Entity And Component 概述</h2><blockquote>
<p>a lightweight, unmanaged alternative to a GameObject.</p>
</blockquote>
<ul>
<li>非托管对象，仅是一个唯一的标识符编号</li>
<li>Components通常为struct values。</li>
<li>实体没有MonoBehavior那样的事件函数</li>
<li>单个实体不能持有多个同类型的组件</li>
<li>实体本身没有父级概念。标准的Parent Component包含一个另外实体的引用从而构成关系。</li>
</ul>
<h2 id="Component组件"><a href="#Component组件" class="headerlink" title="Component组件"></a>Component组件</h2><h3 id="基础组件-非托管组件-UnmanagedComponent"><a href="#基础组件-非托管组件-UnmanagedComponent" class="headerlink" title="基础组件 非托管组件 UnmanagedComponent"></a>基础组件 非托管组件 UnmanagedComponent</h3><p>实现IComponentData</p>
<ul>
<li>非托管结构体<ul>
<li>Blittable types</li>
<li>bool</li>
<li>char</li>
<li>BlobAssetReference<T>, a reference to a Blob data structure</li>
<li>Collections.FixedString, a fixed-sized character buffer</li>
<li>Collections.FixedList</li>
<li>Fixed array (only allowed in an unsafe context)</li>
<li>Other struct types that conform to these same restrictions.</li>
</ul>
</li>
<li>概念上pure data，no method,实际没有限制</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// an entity component type with two fields</span><br><span class="line">public struct Health : IComponentData</span><br><span class="line">&#123;</span><br><span class="line">public int HitPoints;</span><br><span class="line">public float ArmourRating:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="托管组件-ManagedComponent"><a href="#托管组件-ManagedComponent" class="headerlink" title="托管组件 ManagedComponent"></a>托管组件 ManagedComponent</h3><ul>
<li>支持任意类型数据</li>
<li>不允许在Jobs中进行访问</li>
<li>不能使用Burst Compile</li>
<li>需要进行GC</li>
<li>Must include a constructor with no parameters for serialization purposes.</li>
</ul>
<p>使用类来创建托管组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DirectoryManaged : IComponentData</span><br><span class="line">&#123;</span><br><span class="line">    public GameObject RotatorPrefab;</span><br><span class="line">    public Toggle RotationToggle;</span><br><span class="line"></span><br><span class="line">    // Every IComponentData class must have a no-arg constructor.</span><br><span class="line">    public DirectoryManaged()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RotatorGO : IComponentData</span><br><span class="line">&#123;</span><br><span class="line">    public GameObject Value;</span><br><span class="line"></span><br><span class="line">    public RotatorGO(GameObject value)</span><br><span class="line">    &#123;</span><br><span class="line">        Value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Every IComponentData class must have a no-arg constructor.</span><br><span class="line">    public RotatorGO()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Tag-Component"><a href="#Tag-Component" class="headerlink" title="Tag Component"></a>Tag Component</h3><blockquote>
<p>An IComponentData struct with no fields is called a tag component.<br>Useful for queries.<br>比如用于MonsterTag</p>
</blockquote>
<h3 id="DynamicBuffer-Component-动态缓冲区组件"><a href="#DynamicBuffer-Component-动态缓冲区组件" class="headerlink" title="DynamicBuffer Component 动态缓冲区组件"></a>DynamicBuffer Component 动态缓冲区组件</h3><p>因为ECS中的通用组件只能存储值类型，而没有引用类型 - 无法定义数组或列表。由此利用DynamicBuffer Component.</p>
<blockquote>
<p>A component type which is a resizable array.<br>实现IBufferElementData接口。</p>
</blockquote>
<p>每一个Buffer有一个长度Length、容量Capacity和一个指针。<br>关于这块，有属性InternalBufferCapacity可以指定容量，如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[InternalBufferCapacity(3)]</span><br><span class="line">public struct IntBufferElement : IBufferElementData</span><br><span class="line">&#123;</span><br><span class="line">    public int value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，如果设置的内容超过容量了，会在外部分配一个更大的新数组。这块可以参考这个文档中Dynamic Buffer的部分：<br><a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1R6E4IDpfLatwHITlCND0i5TuMVG0CMGsentFL-3RQT0/edit?usp=sharing">Entities 101</a></p>
<p>用于动态缓冲区的方法:</p>
<ul>
<li>AddComponent<T>:基本同AddBuffer</li>
<li>AddBuffer<T>：返回DynamicBuffer<T></li>
<li>RemoveComponent<T></li>
<li>HasBuffer<T></li>
<li>GetBuffer<T></li>
</ul>
<h4 id="DynamicBuffer"><a href="#DynamicBuffer" class="headerlink" title="DynamicBuffer"></a>DynamicBuffer</h4><p>动态缓冲区组件。类似于List般使用<br>主要方法：</p>
<ul>
<li>Length</li>
<li>Capacity</li>
<li>Item[Int32] 获取&#x2F;设定指定位置的元素</li>
<li>Add()</li>
<li>Insert()</li>
<li>RemoveAt()</li>
</ul>
<h3 id="层级关系"><a href="#层级关系" class="headerlink" title="层级关系"></a>层级关系</h3><p>ECS中实体的层级其实和Parent、Child组件有关。<br>对应的是实现IComponentData的Parent和实现ICleanupBufferElementData与IBufferElementData的Child。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//示例系统代码</span><br><span class="line">bool attached;</span><br><span class="line">float timer;</span><br><span class="line">const float interval = 0.7f;</span><br><span class="line"></span><br><span class="line">[BurstCompile]</span><br><span class="line">public void OnUpdate(ref SystemState state)</span><br><span class="line">&#123;</span><br><span class="line">    timer -= SystemAPI.Time.DeltaTime;</span><br><span class="line">    if (timer &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    timer = interval;</span><br><span class="line"></span><br><span class="line">    //用组件来获取单例实体</span><br><span class="line">    var rotatorEntity = SystemAPI.GetSingletonEntity&lt;RotationSpeed&gt;();</span><br><span class="line">    var ecb = new EntityCommandBuffer(Allocator.Temp);</span><br><span class="line">    if (attached)</span><br><span class="line">    &#123;</span><br><span class="line">        // Detach all children from the rotator by removing the Parent component from the children.</span><br><span class="line">        // (The next time TransformSystemGroup updates, it will update the Child buffer and transforms accordingly.)</span><br><span class="line"></span><br><span class="line">        DynamicBuffer&lt;Child&gt; children = SystemAPI.GetBuffer&lt;Child&gt;(rotatorEntity);</span><br><span class="line">        for (int i = 0; i &lt; children.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            // Using an ECB is the best option here because calling EntityManager.RemoveComponent()</span><br><span class="line">            // instead would invalidate the DynamicBuffer, meaning we&#x27;d have to re-retrieve</span><br><span class="line">            // the DynamicBuffer after every EntityManager.RemoveComponent() call.</span><br><span class="line">            //依旧是延后执行</span><br><span class="line">            ecb.RemoveComponent&lt;Parent&gt;(children[i].Value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Alternative solution instead of the above loop:</span><br><span class="line">        // A single call that removes the Parent component from all entities in the array.</span><br><span class="line">        // Because the method expects a NativeArray&lt;Entity&gt;, we create a NativeArray&lt;Entity&gt; alias of the DynamicBuffer.</span><br><span class="line">        </span><br><span class="line">        // ecb.RemoveComponent&lt;Parent&gt;(children.AsNativeArray().Reinterpret&lt;Entity&gt;());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        // Attach all the small cubes to the rotator by adding a Parent component to the cubes.</span><br><span class="line">        // (The next time TransformSystemGroup updates, it will update the Child buffer and transforms accordingly.)</span><br><span class="line"></span><br><span class="line">        foreach (var (transform, entity) in</span><br><span class="line">                  SystemAPI.Query&lt;RefRO&lt;LocalTransform&gt;&gt;()</span><br><span class="line">                      .WithNone&lt;RotationSpeed&gt;()</span><br><span class="line">                      .WithEntityAccess())</span><br><span class="line">        &#123;</span><br><span class="line">            ecb.AddComponent(entity, new Parent &#123; Value = rotatorEntity &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Alternative solution instead of the above loop:</span><br><span class="line">        // Add a Parent value to all entities matching a query.</span><br><span class="line">        /*</span><br><span class="line">        var query = SystemAPI.QueryBuilder().WithAll&lt;LocalTransform&gt;().WithNone&lt;RotationSpeed&gt;().Build();</span><br><span class="line">        ecb.AddComponent(query, new Parent &#123; Value = rotatorEntity &#125;);</span><br><span class="line">        */</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //执行缓存的指令</span><br><span class="line">    ecb.Playback(state.EntityManager);</span><br><span class="line"></span><br><span class="line">    attached = !attached;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较需要留意的就是添加&#x2F;删除组件会移动Entity到不同原型对应的chunk。且对于Dynamic Buffer而言也是的。</p>
<h3 id="可激活组件-IEnableableComponent"><a href="#可激活组件-IEnableableComponent" class="headerlink" title="可激活组件 IEnableableComponent"></a>可激活组件 IEnableableComponent</h3><p>在实现IComponentData以外，实现IEnableableComponent接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct RotationSpeed : IComponentData, IEnableableComponent</span><br><span class="line">&#123;</span><br><span class="line">    public float RadiansPerSecond;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置组件启用:<br>SetComponentEnabled<RotationSpeed>(entity,enabled);</p>
<p>组件的启用&#x2F;禁用-&gt; 影响查询状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[BurstCompile]</span><br><span class="line">public void OnUpdate(ref SystemState state)</span><br><span class="line">&#123;</span><br><span class="line">    float deltaTime = SystemAPI.Time.DeltaTime;</span><br><span class="line">    timer -= deltaTime;</span><br><span class="line"></span><br><span class="line">    // Toggle the enabled state of every RotationSpeed</span><br><span class="line">    if (timer &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      //处理EnableState的启用/禁用</span><br><span class="line">      //WithOptions来包含禁用的组件</span><br><span class="line">      foreach (EnabledRefRW&lt;RotationSpeed&gt; rotationSpeedEnabled in</span><br><span class="line">                SystemAPI.Query&lt;EnabledRefRW&lt;RotationSpeed&gt;&gt;()</span><br><span class="line">                    .WithOptions(EntityQueryOptions.IgnoreComponentEnabledState))</span><br><span class="line">      &#123;</span><br><span class="line">          rotationSpeedEnabled.ValueRW = !rotationSpeedEnabled.ValueRO;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      timer = interval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The query only matches entities whose RotationSpeed is enabled.</span><br><span class="line">    foreach (var (transform, speed) in</span><br><span class="line">              SystemAPI.Query&lt;RefRW&lt;LocalTransform&gt;, RefRO&lt;RotationSpeed&gt;&gt;())</span><br><span class="line">    &#123;</span><br><span class="line">      transform.ValueRW = transform.ValueRO.RotateY(</span><br><span class="line">          speed.ValueRO.RadiansPerSecond * deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="Entity-Worlds-And-EntityManagers"><a href="#Entity-Worlds-And-EntityManagers" class="headerlink" title="Entity Worlds And EntityManagers"></a>Entity Worlds And EntityManagers</h2><h3 id="世界World"><a href="#世界World" class="headerlink" title="世界World"></a>世界World</h3><ul>
<li>实体的集合。在其中每个实体有着唯一ID。</li>
<li>持有一组系统</li>
</ul>
<h3 id="EntityManager"><a href="#EntityManager" class="headerlink" title="EntityManager"></a>EntityManager</h3><p>管理实体的创建、销毁和修改。</p>
<ul>
<li>CreateEntity()</li>
<li>Instantiate(): Creates a new entity with a copy of all the components of an existing entity.</li>
<li>DestroyEntity(): Destroys an existing entity.</li>
<li>AddComponent<T>()</li>
<li>RemoveComponent<T>()</li>
<li>HasComponent<T>()</li>
<li>GetComponent<T>()</li>
<li>SetComponent<T>(): Overwrites the value of an entity’s component of type T.</li>
</ul>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//加载对象示例代码。留意GameObject到Entity的转换。</span><br><span class="line">// An authoring component is just a normal MonoBehavior that has a Baker&lt;T&gt; class.</span><br><span class="line">public class SpawnerAuthoring : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public GameObject Prefab;</span><br><span class="line"></span><br><span class="line">    // In baking, this Baker will run once for every SpawnerAuthoring instance in a subscene.</span><br><span class="line">    // (Note that nesting an authoring component&#x27;s Baker class inside the authoring MonoBehaviour class</span><br><span class="line">    // is simply an optional matter of style.)</span><br><span class="line">    class Baker : Baker&lt;SpawnerAuthoring&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        public override void Bake(SpawnerAuthoring authoring)</span><br><span class="line">        &#123;</span><br><span class="line">            var entity = GetEntity(TransformUsageFlags.None);</span><br><span class="line">            AddComponent(entity, new Spawner</span><br><span class="line">            &#123;</span><br><span class="line">                Prefab = GetEntity(authoring.Prefab, TransformUsageFlags.Dynamic)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Spawner : IComponentData</span><br><span class="line">&#123;</span><br><span class="line">    public Entity Prefab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//System代码</span><br><span class="line">[BurstCompile]</span><br><span class="line">public void OnUpdate(ref SystemState state)</span><br><span class="line">&#123;</span><br><span class="line">    // Create a query that matches all entities having a RotationSpeed component.</span><br><span class="line">    // (The query is cached in source generation, so this does not incur a cost of recreating it every update.)</span><br><span class="line">    EntityQuery spinningCubesQuery = SystemAPI.QueryBuilder().WithAll&lt;RotationSpeed,LocalTransform&gt;().Build();</span><br><span class="line">    </span><br><span class="line">    // Only spawn cubes when no cubes currently exist.</span><br><span class="line">    if (spinningCubesQuery.IsEmpty)</span><br><span class="line">    &#123;</span><br><span class="line">      //获取单个组件（场景中存在多个的情况下会报错）</span><br><span class="line">      Entity prefab = SystemAPI.GetSingleton&lt;Spawner&gt;().Prefab;</span><br><span class="line"></span><br><span class="line">      //通过State获取EntityManager 然后进行预设的实例化</span><br><span class="line">      // Instantiating an entity creates copy entities with the same component types and values.</span><br><span class="line">      NativeArray&lt;Entity&gt; instances = state.EntityManager.Instantiate(prefab, 500, Allocator.Temp);</span><br><span class="line"></span><br><span class="line">      // Unlike new Random(), CreateFromIndex() hashes the random seed</span><br><span class="line">      // so that similar seeds don&#x27;t produce similar results.</span><br><span class="line">      var random = Random.CreateFromIndex(updateCounter++);</span><br><span class="line"></span><br><span class="line">      foreach (Entity entity in instances)</span><br><span class="line">      &#123;</span><br><span class="line">          // Update the entity&#x27;s LocalTransform component with the new position.</span><br><span class="line">          var transform = SystemAPI.GetComponentRW&lt;LocalTransform&gt;(entity);</span><br><span class="line">          transform.ValueRW.Position = (random.NextFloat3() - new float3(0.5f, 0, 0.5f)) * 20;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //Better Way</span><br><span class="line">      //单个实体组件的查询开销更高 内存布局问题</span><br><span class="line">      foreach (var (transform, rotationSpeed) in SystemAPI.Query&lt;RefRW&lt;LocalTransform&gt;, RefRO&lt;RotationSpeed&gt;&gt;())</span><br><span class="line">      &#123;</span><br><span class="line">          transform.ValueRW.Position = (random.NextFloat3() - new float3(0.5f, 0, 0.5f)) * 20;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Archetypes-原型"><a href="#Archetypes-原型" class="headerlink" title="Archetypes 原型"></a>Archetypes 原型</h3><blockquote>
<p>Represents a particular unique combination of component types in a world: all of the entities in a world with a certain set of component types are stored together in the same archetype. </p>
</blockquote>
<p>特定的组件组合 - 构成Archetype。不同的实体基于自己的组件类型位于不同的原型之下。这块可以去了解一下ECS的内存。</p>
<p>相关原型的创建、实体原型的切换等都有EntityManager处理。但是，即使所有的实体都从原型中移除，原型要直到世界销毁才会销毁。</p>
<h3 id="Chunks-实体内存分布"><a href="#Chunks-实体内存分布" class="headerlink" title="Chunks 实体内存分布"></a>Chunks 实体内存分布</h3><p>可以结合团结演讲的图一起理解:<br><a target="_blank" rel="noopener" href="https://developer.unity.cn/projects/677ca79dedbc2a001f135aec">团结引擎高性能ECS架构</a><br>The entities of an archetype are stored in <strong>16KiB</strong> blocks of memory belonging to the archetype called chunks. Each chunk stores up to <strong>128</strong> entities. (In an archetype where the space required for each entity exceeds 16KiB &#x2F; 128, the max number of entities per chunk will be lower).</p>
<h3 id="Queries"><a href="#Queries" class="headerlink" title="Queries"></a>Queries</h3><p>使用EntityQuery。高效的查找所有具有指定组件类型集合的实体。<br>本质上是利用原型。</p>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><h5 id="SystemAPI-Query"><a href="#SystemAPI-Query" class="headerlink" title="SystemAPI.Query"></a>SystemAPI.Query</h5><p>一般的使用SystemAPI.Query来执行操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foreach (var (transform, speed) in</span><br><span class="line">            SystemAPI.Query&lt;RefRW&lt;LocalTransform&gt;, RefRO&lt;RotationSpeed&gt;&gt;())</span><br><span class="line">&#123;</span><br><span class="line">    transform.ValueRW = transform.ValueRO.RotateY(speed.ValueRO.RadiansPerSecond * deltaTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="EntityQuery"><a href="#EntityQuery" class="headerlink" title="EntityQuery"></a>EntityQuery</h5><p>使用SystemAPI来构建:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EntityQuery spinningCubesQuery = SystemAPI.QueryBuilder().WithAll&lt;RotationSpeed,LocalTransform&gt;().Build();</span><br></pre></td></tr></table></figure>

<p>WithAll和WithEntityAccess<br>对于不需要实际访问的组件可以用WithAll来进行判断。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// WithAll() includes RotationSpeed in the query, but</span><br><span class="line">// the RotationSpeed component values will not be accessed.</span><br><span class="line">// WithEntityAccess() includes the Entity ID as the last element of the tuple.</span><br><span class="line">foreach (var (transform, entity) in</span><br><span class="line">          SystemAPI.Query&lt;RefRW\&lt;LocalTransform&gt;&gt;()</span><br><span class="line">              .WithAll&lt;RotationSpeed&gt;()</span><br><span class="line">              .WithEntityAccess())</span><br></pre></td></tr></table></figure>

<h4 id="IAspect-抽象封装"><a href="#IAspect-抽象封装" class="headerlink" title="IAspect 抽象封装"></a>IAspect 抽象封装</h4><p>可以创建实现IAspect的struct，来封装要查询的对象和执行的逻辑。<br>不过在使用Aspect进行抽象封装的时候，注意readonly和partial。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//System逻辑</span><br><span class="line">[BurstCompile]</span><br><span class="line">public void OnUpdate(ref SystemState state)</span><br><span class="line">&#123;</span><br><span class="line">    float deltaTime = SystemAPI.Time.DeltaTime;</span><br><span class="line">    double elapsedTime = SystemAPI.Time.ElapsedTime;</span><br><span class="line"></span><br><span class="line">    // Rotate the cube directly without using the aspect.</span><br><span class="line">    // The query matches all entities having the LocalTransform and RotationSpeed components.</span><br><span class="line">    foreach (var (transform, speed) in</span><br><span class="line">              SystemAPI.Query&lt;RefRW&lt;LocalTransform&gt;, RefRO&lt;RotationSpeed&gt;&gt;())</span><br><span class="line">    &#123;</span><br><span class="line">        transform.ValueRW = transform.ValueRO.RotateY(speed.ValueRO.RadiansPerSecond * deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Rotate the cube using the aspect.</span><br><span class="line">    // The query will include all components of VerticalMovementAspect.</span><br><span class="line">    // Note that, unlike components, aspect type params of SystemAPI.Query are not wrapped in a RefRW or RefRO.</span><br><span class="line">    foreach (var movement in</span><br><span class="line">              SystemAPI.Query&lt;VerticalMovementAspect&gt;())</span><br><span class="line">    &#123;</span><br><span class="line">        movement.Move(elapsedTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Aspect封装 - 多个组件类型的封装</span><br><span class="line">// An instance of this aspect wraps the LocalTransform and RotationSpeed components of a single entity.</span><br><span class="line">// (This trivial example is arguably not a worthwhile use case for aspects, but larger examples better demonstrate their utility.)</span><br><span class="line">readonly partial struct VerticalMovementAspect : IAspect</span><br><span class="line">&#123;</span><br><span class="line">    readonly RefRW&lt;LocalTransform&gt; m_Transform;</span><br><span class="line">    readonly RefRO&lt;RotationSpeed&gt; m_Speed;</span><br><span class="line"></span><br><span class="line">    public void Move(double elapsedTime)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Transform.ValueRW.Position.y = (float)math.sin(elapsedTime * m_Speed.ValueRO.RadiansPerSecond);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ECB-EntityCommandBuffer"><a href="#ECB-EntityCommandBuffer" class="headerlink" title="ECB EntityCommandBuffer"></a>ECB EntityCommandBuffer</h3><p>延后指令执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// An EntityCommandBuffer created from EntityCommandBufferSystem.Singleton will be</span><br><span class="line">// played back and disposed by the EntityCommandBufferSystem when it next updates.</span><br><span class="line">var ecbSingleton = SystemAPI.GetSingleton&lt;BeginSimulationEntityCommandBufferSystem.Singleton&gt;();</span><br><span class="line">EntityCommandBuffer ecb = ecbSingleton.CreateCommandBuffer(state.WorldUnmanaged);</span><br><span class="line"></span><br><span class="line">// Downward vector</span><br><span class="line">var movement = new float3(0, -SystemAPI.Time.DeltaTime * 5f, 0);</span><br><span class="line"></span><br><span class="line">// WithAll() includes RotationSpeed in the query, but</span><br><span class="line">// the RotationSpeed component values will not be accessed.</span><br><span class="line">// WithEntityAccess() includes the Entity ID as the last element of the tuple.</span><br><span class="line">foreach (var (transform, entity) in</span><br><span class="line">          SystemAPI.Query&lt;RefRW&lt;LocalTransform&gt;&gt;()</span><br><span class="line">              .WithAll&lt;RotationSpeed&gt;()</span><br><span class="line">              .WithEntityAccess())</span><br><span class="line">&#123;</span><br><span class="line">    transform.ValueRW.Position += movement;</span><br><span class="line">    if (transform.ValueRO.Position.y &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        // Making a structural change would invalidate the query we are iterating through,</span><br><span class="line">        // so instead we record a command to destroy the entity later.</span><br><span class="line">        ecb.DestroyEntity(entity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Entities-Meta-Data"><a href="#Entities-Meta-Data" class="headerlink" title="Entities Meta Data"></a>Entities Meta Data</h3><p>Each world keeps track of its entities in a single,large array.<br>包含</p>
<ul>
<li>Chunk指针</li>
<li>Index in chunk</li>
<li>Version number</li>
</ul>
<h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><p>A Unit Of Code.<br>实现ISystem接口。</p>
<p>关键方法：</p>
<ul>
<li>OnCreate:Called before the first call to OnUpdate and whenever a system resumes running.</li>
<li><ul>
<li>OnUpdate</li>
</ul>
</li>
<li>OnDestroy:Called when a system is destroyed.<br>这三个方法都会传递一个SystemState参数。</li>
</ul>
<p>Enabled属性，决定是否会Update。</p>
<p>可选实现接口:ISystemStartStop</p>
<ul>
<li>OnStartRunning()</li>
<li>OnStopRunning()</li>
</ul>
<h3 id="System-Group"><a href="#System-Group" class="headerlink" title="System Group"></a>System Group</h3><p>分组确定了System在哪个阶段执行Update，以及各个System之间的Update顺序。</p>
<p>使用属性来确保顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[UpdateBefore(typeof(Tutorials.Firefighters.SpawnSystem))]</span><br><span class="line">//[UpdateAfter(typeof(Tutorials.Firefighters.SpawnSystem))]</span><br><span class="line">//[UpdateInGroup(typeof(FixedStepSimulationSystemGroup))]</span><br><span class="line">[BurstCompile]</span><br><span class="line">public partial struct MySystem : ISystem</span><br><span class="line">&#123;</span><br><span class="line">    [BurstCompile]</span><br><span class="line">    public void OnUpdate(ref SystemState state)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(&quot;MySystem Update&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于分组这块，可以看到对应的System Window。<br>Window - Entities - System<br>ECS相关的信息都需要单独查看。</p>
<h2 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h2><p>World持有一个Time属性，TimeData Struct。</p>
<h2 id="Jobs-1"><a href="#Jobs-1" class="headerlink" title="Jobs"></a>Jobs</h2><p>两个用于访问实体的接口：</p>
<ul>
<li>IJobEntity：对于符合查询条件的实体，调用一次Execute</li>
<li>IJobChunk：对于符合查询条件的块(Chunk)，调用一次Execute<ul>
<li>具体而言，是原型的Chunk。直接对Chunk数据流操作，需要通过一些Handle来定位对应的数据。可以看官方的Entities 101示例。</li>
</ul>
</li>
</ul>
<p>IJobEntity实际上底层实现也是会转换为IJobChunk。不过一般IJobEntity使用起来更为便利。</p>
<p>多线程调用的话用 ScheduleParallel而非Schedule。</p>
<h3 id="IJobEntity示例"><a href="#IJobEntity示例" class="headerlink" title="IJobEntity示例"></a>IJobEntity示例</h3><p>可以看到官方的Entities 101示例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//System调用</span><br><span class="line">[BurstCompile]</span><br><span class="line">public void OnUpdate(ref SystemState state)</span><br><span class="line">&#123;</span><br><span class="line">    var job = new RotateAndScaleJob</span><br><span class="line">    &#123;</span><br><span class="line">        deltaTime = SystemAPI.Time.DeltaTime,</span><br><span class="line">        elapsedTime = (float)SystemAPI.Time.ElapsedTime</span><br><span class="line">    &#125;;</span><br><span class="line">    job.Schedule();//这里的调度存在语法糖，实际相当于下面，会维护依赖关系。</span><br><span class="line">    //state.Dependency = job.Schedule(state.Dependency);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//IJob定义</span><br><span class="line">[BurstCompile]</span><br><span class="line">partial struct RotateAndScaleJob : IJobEntity</span><br><span class="line">&#123;</span><br><span class="line">    public float deltaTime;</span><br><span class="line">    public float elapsedTime;</span><br><span class="line"></span><br><span class="line">    // In source generation, a query is created from the parameters of Execute().</span><br><span class="line">    // Here, the query will match all entities having a LocalTransform, PostTransformMatrix, and RotationSpeed component.</span><br><span class="line">    // (In the scene, the root cube has a non-uniform scale, so it is given a PostTransformMatrix component in baking.)</span><br><span class="line">    void Execute(ref LocalTransform transform, ref PostTransformMatrix postTransform, in RotationSpeed speed)</span><br><span class="line">    &#123;</span><br><span class="line">        transform = transform.RotateY(speed.RadiansPerSecond * deltaTime);</span><br><span class="line">        postTransform.Value = float4x4.Scale(1, math.sin(elapsedTime), 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IJobEntity的Execute本身会作为一个Filter。</p>
<h3 id="IJobChunk示例"><a href="#IJobChunk示例" class="headerlink" title="IJobChunk示例"></a>IJobChunk示例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//System</span><br><span class="line">[BurstCompile]</span><br><span class="line">public void OnUpdate(ref SystemState state)</span><br><span class="line">&#123;</span><br><span class="line">    var spinningCubesQuery = SystemAPI.QueryBuilder().WithAll&lt;RotationSpeed, LocalTransform&gt;().Build();</span><br><span class="line"></span><br><span class="line">    var job = new RotationJob</span><br><span class="line">    &#123;</span><br><span class="line">        TransformTypeHandle = SystemAPI.GetComponentTypeHandle&lt;LocalTransform&gt;(),</span><br><span class="line">        //传入true代表Readonly</span><br><span class="line">        RotationSpeedTypeHandle = SystemAPI.GetComponentTypeHandle&lt;RotationSpeed&gt;(true),</span><br><span class="line">        DeltaTime = SystemAPI.Time.DeltaTime</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // Unlike an IJobEntity, an IJobChunk must be manually passed a query.</span><br><span class="line">    // Furthermore, IJobChunk does not pass and assign the state.Dependency JobHandle implicitly.</span><br><span class="line">    // (This pattern of passing and assigning state.Dependency ensures that the entity jobs scheduled</span><br><span class="line">    // in different systems will depend upon each other as needed.)</span><br><span class="line">    state.Dependency = job.Schedule(spinningCubesQuery, state.Dependency);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Job定义</span><br><span class="line">[BurstCompile]</span><br><span class="line">struct RotationJob : IJobChunk</span><br><span class="line">&#123;</span><br><span class="line">    public ComponentTypeHandle&lt;LocalTransform&gt; TransformTypeHandle;</span><br><span class="line">    [ReadOnly] public ComponentTypeHandle&lt;RotationSpeed&gt; RotationSpeedTypeHandle;</span><br><span class="line">    public float DeltaTime;</span><br><span class="line"></span><br><span class="line">    public void Execute(in ArchetypeChunk chunk, int unfilteredChunkIndex, bool useEnabledMask,</span><br><span class="line">        in v128 chunkEnabledMask)</span><br><span class="line">    &#123;</span><br><span class="line">        // The useEnableMask parameter is true when one or more entities in</span><br><span class="line">        // the chunk have components of the query that are disabled.</span><br><span class="line">        // If none of the query component types implement IEnableableComponent,</span><br><span class="line">        // we can assume that useEnabledMask will always be false.</span><br><span class="line">        // However, it&#x27;s good practice to add this guard check just in case</span><br><span class="line">        // someone later changes the query or component types.</span><br><span class="line">        //可以看看源码对于useEnabledMask的解释。主要是对于部分实体会把组件disable的情况（IEnableableComponent）</span><br><span class="line">        //不过注意 Burst情况下Asset有问题 建议Debug时不要Burst。</span><br><span class="line">        Assert.IsFalse(useEnabledMask);</span><br><span class="line">        </span><br><span class="line">        //获取组件NativeArray</span><br><span class="line">        //注意ComponentTypeHandle为struct</span><br><span class="line">        NativeArray&lt;LocalTransform&gt; transforms = chunk.GetNativeArray(ref TransformTypeHandle);</span><br><span class="line">        NativeArray&lt;RotationSpeed&gt; rotationSpeeds = chunk.GetNativeArray(ref RotationSpeedTypeHandle);</span><br><span class="line">        for (int i = 0, chunkEntityCount = chunk.Count; i &lt; chunkEntityCount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            transforms[i] = transforms[i].RotateY(rotationSpeeds[i].RadiansPerSecond * DeltaTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>必须传入对于的Query确定。</li>
<li>不会隐式设置Dependence，需要显示设置。</li>
<li>使用ComponentTypeHandle，用于在Chunk中定位组件数据位置</li>
</ul>
<h3 id="同步点"><a href="#同步点" class="headerlink" title="同步点"></a>同步点</h3><p>部分函数会触发同步，以完成对某些组件的Job。</p>
<p>如：</p>
<ul>
<li>EntityManager.AddComponent<T>()：完成所有访问T组件的Jobs</li>
<li>EntityQuery的ToComponentDataArray<T>()</li>
<li>EntityQuery的ToEntityArray()</li>
<li>EntityQuery的ToArchetypeChunkArray()</li>
</ul>
<p>注意不同Jobs之间的依赖关系。<br>SystemState中有一个JobHandle:Dependency。这个仅用于components type。</p>
<p>两个规则：</p>
<ul>
<li>All jobs scheduled in a system update should (directly or indirectly) depend upon the job handle that was assigned to Dependency right before the update.</li>
<li>Before a system update returns, the Dependency property should be assigned a handle that includes all the jobs scheduled in that update.（即在调用Jobs之后给state的Dependency赋值）</li>
</ul>
<h3 id="组件访问"><a href="#组件访问" class="headerlink" title="组件访问"></a>组件访问</h3><p>Jobs内部一般不能直接用EntityManager，可以考虑ComponentLookup<T>。以及BufferLookup<T>。</p>
<h2 id="ECS和Mono交互"><a href="#ECS和Mono交互" class="headerlink" title="ECS和Mono交互"></a>ECS和Mono交互</h2><p>可以参考Entities 101的GameObjectSync。</p>
<h1 id="官方视频记录"><a href="#官方视频记录" class="headerlink" title="官方视频记录"></a>官方视频记录</h1><p>GameObject</p>
<ul>
<li>Managed Objects, Not able to use Burst compiler</li>
<li>有GC。创建和销毁代价较高。</li>
<li>内存分散 Cache Miss</li>
</ul>
<p>World<br>EntityManager<br>Archetype<br>Chunk</p>
<p>Automatic bootstrapping - by default. All the systems will automatically get added into a default world at the start of play mode.</p>
<!-- flag of hidden posts --></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://MikeMing126.github.io">Ming</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mikeming126.github.io/Mine/Unity/DOTS/">https://mikeming126.github.io/Mine/Unity/DOTS/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://MikeMing126.github.io" target="_blank">Ming Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Unity/">Unity</a></div><div class="post-share"><div class="social-share" data-image="/img/head.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/Mine/Unity/AsyncOp/" title="Unity异步操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-14</div><div class="info-item-2">Unity异步操作</div></div><div class="info-2"><div class="info-item-1">异步操作可以参考这篇文章Unity入门教程之异步篇第二节：协程 or UniTask？Unity 中异步流程到底怎么选Unity异步扩展实践（一）——以UniTask库为参考 关于临界资源问题Unity入门教程之异步篇第三节：多线程初探？理解并发与线程安全 协程 - 逻辑异步 - 单线程协程这块较为通用可以另外参考之前记录。 UniTask本质上是利用C#的Task。但是使用原生的async&#x2F;await和Task存在一些问题：  GC和性能开销(Task本身是引用类型，且async&#x2F;await产生状态机对象和闭包) 线程切换不一定对。且Unity大部分API只能在主线程使用。 任务的生命周期管理问题:任务不会因为对象被销毁而自动停止 平台多线程限制（如WebGL）  因此有UniTaskGitHub优势和注意事项：  零GC 主线程调度。默认完全在Unity的PlayerLoop上运行，因此不使用Thread。在 .NET 实现中，执行 await 语句之前和之后代码的线程是有可能不同的。虽然有线程切换，但我们不需要关心其中的细节，.NET...</div></div></div></a><a class="pagination-related" href="/Mine/Unity/Animation/" title="Unity Animation"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-14</div><div class="info-item-2">Unity Animation</div></div><div class="info-2"><div class="info-item-1">动画 Unity动画系统基于Animation Clips的概念 Animation Clip  包含对象随着事件如何改变位置、旋转或其他属性的相关信息。  Animation Controller  动画状态机 当前播放的Clip，何时改变以及混合。  Animator组件  Animation Clip、Animator Controller and Avatar  </div></div></div></a><a class="pagination-related" href="/Mine/Unity/Physics/" title="Unity Physics"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-14</div><div class="info-item-2">Unity Physics</div></div><div class="info-2"><div class="info-item-1">物理Unity物理系统由浅入深第一节：Unity 物理系统基础与应用 RigidBody 刚体 - 赋予物理属性 Collider 碰撞体 - 碰撞形状 Physic Material 物理材质 - 定义交互特性定义碰撞体之间的摩檫力和弹性。分配给Collider。 碰撞事件  Collision Callbacks 适用于两个非触发器（至少一个带RigidBody）之间的物理碰撞 Trigger Callbacks 至少一个Collider为Is Trigger的情况下，检测到物体进入&#x2F;离开&#x2F;停留在区域内 只有当碰撞中一个Collider附加了Rigidbody或者其为KinematicRigidbody上的Colider时，才能触发对应的回调。(对于KinematicRigidbody，不会触发CollisionCallback，需要用TriggerCallback)  射线检测 Raycast形状检测 Shape Cast </div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Ming</div><div class="author-info-description">我们都在奔赴各自的人生，但你依旧是你</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JobSystem"><span class="toc-number">2.</span> <span class="toc-text">JobSystem</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%98%E6%96%B9%E6%A1%88%E4%BE%8B"><span class="toc-number">2.1.</span> <span class="toc-text">官方案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">2.2.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Jobs"><span class="toc-number">2.3.</span> <span class="toc-text">Jobs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Job%E5%AE%9A%E4%B9%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">Job定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE"><span class="toc-number">2.3.2.</span> <span class="toc-text">数据访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B"><span class="toc-number">2.3.3.</span> <span class="toc-text">调度流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Complete"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">Complete</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96-Dependecy"><span class="toc-number">2.3.4.</span> <span class="toc-text">依赖 Dependecy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E4%BD%9C%E4%B8%9A-Parallel-Job"><span class="toc-number">2.3.5.</span> <span class="toc-text">并行作业 Parallel Job</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ParallelForTransform"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">ParallelForTransform</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Burst-Compiler"><span class="toc-number">3.</span> <span class="toc-text">Burst Compiler</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ECS"><span class="toc-number">4.</span> <span class="toc-text">ECS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">4.1.</span> <span class="toc-text">准备工作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%8C%85"><span class="toc-number">4.1.1.</span> <span class="toc-text">常用包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WorkFlow"><span class="toc-number">4.2.</span> <span class="toc-text">WorkFlow</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3Baking-Process"><span class="toc-number">4.2.1.</span> <span class="toc-text">了解Baking Process</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Entity-And-Component-%E6%A6%82%E8%BF%B0"><span class="toc-number">4.3.</span> <span class="toc-text">Entity And Component 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Component%E7%BB%84%E4%BB%B6"><span class="toc-number">4.4.</span> <span class="toc-text">Component组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6-%E9%9D%9E%E6%89%98%E7%AE%A1%E7%BB%84%E4%BB%B6-UnmanagedComponent"><span class="toc-number">4.4.1.</span> <span class="toc-text">基础组件 非托管组件 UnmanagedComponent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%98%E7%AE%A1%E7%BB%84%E4%BB%B6-ManagedComponent"><span class="toc-number">4.4.2.</span> <span class="toc-text">托管组件 ManagedComponent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tag-Component"><span class="toc-number">4.4.3.</span> <span class="toc-text">Tag Component</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DynamicBuffer-Component-%E5%8A%A8%E6%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E7%BB%84%E4%BB%B6"><span class="toc-number">4.4.4.</span> <span class="toc-text">DynamicBuffer Component 动态缓冲区组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DynamicBuffer"><span class="toc-number">4.4.4.1.</span> <span class="toc-text">DynamicBuffer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB"><span class="toc-number">4.4.5.</span> <span class="toc-text">层级关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%BF%80%E6%B4%BB%E7%BB%84%E4%BB%B6-IEnableableComponent"><span class="toc-number">4.4.6.</span> <span class="toc-text">可激活组件 IEnableableComponent</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Entity-Worlds-And-EntityManagers"><span class="toc-number">4.5.</span> <span class="toc-text">Entity Worlds And EntityManagers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%96%E7%95%8CWorld"><span class="toc-number">4.5.1.</span> <span class="toc-text">世界World</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EntityManager"><span class="toc-number">4.5.2.</span> <span class="toc-text">EntityManager</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">4.5.2.1.</span> <span class="toc-text">示例代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Archetypes-%E5%8E%9F%E5%9E%8B"><span class="toc-number">4.5.3.</span> <span class="toc-text">Archetypes 原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chunks-%E5%AE%9E%E4%BD%93%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83"><span class="toc-number">4.5.4.</span> <span class="toc-text">Chunks 实体内存分布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Queries"><span class="toc-number">4.5.5.</span> <span class="toc-text">Queries</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#API"><span class="toc-number">4.5.5.1.</span> <span class="toc-text">API</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SystemAPI-Query"><span class="toc-number">4.5.5.1.1.</span> <span class="toc-text">SystemAPI.Query</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#EntityQuery"><span class="toc-number">4.5.5.1.2.</span> <span class="toc-text">EntityQuery</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IAspect-%E6%8A%BD%E8%B1%A1%E5%B0%81%E8%A3%85"><span class="toc-number">4.5.5.2.</span> <span class="toc-text">IAspect 抽象封装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ECB-EntityCommandBuffer"><span class="toc-number">4.5.6.</span> <span class="toc-text">ECB EntityCommandBuffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Entities-Meta-Data"><span class="toc-number">4.5.7.</span> <span class="toc-text">Entities Meta Data</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System"><span class="toc-number">4.6.</span> <span class="toc-text">System</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#System-Group"><span class="toc-number">4.6.1.</span> <span class="toc-text">System Group</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Time"><span class="toc-number">4.7.</span> <span class="toc-text">Time</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Jobs-1"><span class="toc-number">4.8.</span> <span class="toc-text">Jobs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IJobEntity%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.8.1.</span> <span class="toc-text">IJobEntity示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IJobChunk%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.8.2.</span> <span class="toc-text">IJobChunk示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E7%82%B9"><span class="toc-number">4.8.3.</span> <span class="toc-text">同步点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E8%AE%BF%E9%97%AE"><span class="toc-number">4.8.4.</span> <span class="toc-text">组件访问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ECS%E5%92%8CMono%E4%BA%A4%E4%BA%92"><span class="toc-number">4.9.</span> <span class="toc-text">ECS和Mono交互</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%98%E6%96%B9%E8%A7%86%E9%A2%91%E8%AE%B0%E5%BD%95"><span class="toc-number">5.</span> <span class="toc-text">官方视频记录</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/AsyncOp/" title="Unity异步操作">Unity异步操作</a><time datetime="2025-09-14T08:01:59.349Z" title="发表于 2025-09-14 16:01:59">2025-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/Physics/" title="Unity Physics">Unity Physics</a><time datetime="2025-09-14T08:01:59.345Z" title="发表于 2025-09-14 16:01:59">2025-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/Animation/" title="Unity Animation">Unity Animation</a><time datetime="2025-09-14T08:01:59.343Z" title="发表于 2025-09-14 16:01:59">2025-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/UE/Share/25ShangHaiFest/" title="2025 - UE - ShangHaiFest">2025 - UE - ShangHaiFest</a><time datetime="2025-08-22T11:09:27.474Z" title="发表于 2025-08-22 19:09:27">2025-08-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Books/Tech/%E9%87%8D%E6%9E%84/" title="重构:改善既有代码的设计">重构:改善既有代码的设计</a><time datetime="2025-07-14T13:43:14.158Z" title="发表于 2025-07-14 21:43:14">2025-07-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/starBg2.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2025 By Ming</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23liMdTJDdBPikGC2F',
      clientSecret: 'eed0ab3cb8494f9e22f7a8bb469c58cc7e6fbaea',
      repo: 'BlogComment',
      owner: 'MikeMing126',
      admin: ['MikeMing126'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '2f95c7541bd8bec4326addc65592d7ce'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script src="/script/APlayerHolder.js"></script><div class="aplayer" data-id="13402811242" data-server="netease" data-type="playlist" data-fixed="true" data-loop="all" data-autoplay="true" data-order="random" data-theme="#3F51B5"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>