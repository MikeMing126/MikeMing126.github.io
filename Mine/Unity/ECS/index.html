<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Unity ECS | Ming Blog</title><meta name="robots" content="noindex"><meta name="author" content="Ming"><meta name="copyright" content="Ming"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="ECS前言Unity的ECS要从整个逻辑触发，所有皆为ECS。当然，也可以仅部分逻辑使用ECS，其他部分使用传统的MonoBehavior。那么，非常关键的一点便是两者的交互方式。 准备工作添加Package：  com.unity.entities com.unity.entities.graphics  设置禁用 重新加载域ProjectSettings-&gt;Editor:EnterPla">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity ECS">
<meta property="og:url" content="https://mikeming126.github.io/Mine/Unity/ECS/index.html">
<meta property="og:site_name" content="Ming Blog">
<meta property="og:description" content="ECS前言Unity的ECS要从整个逻辑触发，所有皆为ECS。当然，也可以仅部分逻辑使用ECS，其他部分使用传统的MonoBehavior。那么，非常关键的一点便是两者的交互方式。 准备工作添加Package：  com.unity.entities com.unity.entities.graphics  设置禁用 重新加载域ProjectSettings-&gt;Editor:EnterPla">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mikeming126.github.io/img/head.png">
<meta property="article:published_time" content="2025-09-18T08:46:58.080Z">
<meta property="article:modified_time" content="2025-09-28T07:09:22.137Z">
<meta property="article:author" content="Ming">
<meta property="article:tag" content="Unity">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mikeming126.github.io/img/head.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Unity ECS",
  "url": "https://mikeming126.github.io/Mine/Unity/ECS/",
  "image": "https://mikeming126.github.io/img/head.png",
  "datePublished": "2025-09-18T08:46:58.080Z",
  "dateModified": "2025-09-28T07:09:22.137Z",
  "author": [
    {
      "@type": "Person",
      "name": "Ming",
      "url": "https://mikeming126.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://mikeming126.github.io/Mine/Unity/ECS/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":4,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Unity ECS',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/starBg2.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/starBg2.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Ming Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Unity ECS</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Unity ECS</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-18T08:46:58.080Z" title="发表于 2025-09-18 16:46:58">2025-09-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-28T07:09:22.137Z" title="更新于 2025-09-28 15:09:22">2025-09-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Unity/">Unity</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="ECS"><a href="#ECS" class="headerlink" title="ECS"></a>ECS</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Unity的ECS要从整个逻辑触发，所有皆为ECS。<br>当然，也可以仅部分逻辑使用ECS，其他部分使用传统的MonoBehavior。<br>那么，非常关键的一点便是两者的交互方式。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>添加Package：</p>
<ul>
<li>com.unity.entities</li>
<li>com.unity.entities.graphics</li>
</ul>
<p>设置禁用 重新加载域<br>ProjectSettings-&gt;Editor:<br>EnterPlayerMode ✔<br>Reload Domain ×<br>Reload Scene ×</p>
<p>ECS相关的信息都需要单独查看。<br>Window - Entities - 各类窗口</p>
<h3 id="常用包"><a href="#常用包" class="headerlink" title="常用包"></a>常用包</h3><ul>
<li>entities</li>
<li>C# JobSystem</li>
<li>Burst Compiler</li>
<li>Collections: A set of unmanaged collection types.</li>
<li>Mathematics:针对Burst-compiled做了优化的数学库</li>
</ul>
<h2 id="WorkFlow-And-Basic"><a href="#WorkFlow-And-Basic" class="headerlink" title="WorkFlow And Basic"></a>WorkFlow And Basic</h2><ul>
<li>Subscene 子场景。将GameObjects和MonoBehaviour添加到子场景中，将转换为实体Entites和对应的ECS components。</li>
<li>Entity 对应GameObject</li>
<li>Component 对应MonoBehaviour，可以创建专门的Baker用于转换MonoBehaviour为Component。（一般Component用Authoring作为结尾。）</li>
<li>System 默认情况下在主线程执行。需要多线程的可以用JobSystem。</li>
</ul>
<h3 id="Baking-Process"><a href="#Baking-Process" class="headerlink" title="Baking Process"></a>Baking Process</h3><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=r337nXZFYeA">官方Youtube视频</a><br>简而言之，虽然Editor里面还是GO和Component，但在Subscene下执行了Baking process后，实际上运行时都是对应的实体和组件。</p>
<p>运行时加载的其实是baking wrold。因此Baking Process中的序列化也是很重要的。<br>这里也有一点注意，运行时不要勾选subscene，否则层级可能存在问题。</p>
<p>Baker其实是给对应的组件持有GameObject添加对应的Component。</p>
<h3 id="Structural-change"><a href="#Structural-change" class="headerlink" title="Structural change"></a>Structural change</h3><p>ECS是基于数据的。</p>
<blockquote>
<p>Operations that cause Unity to <strong>reorganize chunks of memory or the contents of chunks in memory</strong> are called structural changes. </p>
</blockquote>
<p>造成Structural Change的操作：</p>
<ul>
<li>创建&#x2F;销毁实体</li>
<li>添加&#x2F;删除组件</li>
<li>设置共享组件值</li>
</ul>
<p>造成后果：</p>
<ul>
<li>对于组件数据的引用会失效</li>
<li>造成同步点(Sync Point)，需要等待所有Jobs完成。这意味着对应的任务无法并行。</li>
</ul>
<p>优化方式:<br>使用ECB Entity Commond Buffers,延后执行。用的时候可以需要再具体了解看看。</p>
<h2 id="Entity-And-Component-概述"><a href="#Entity-And-Component-概述" class="headerlink" title="Entity And Component 概述"></a>Entity And Component 概述</h2><blockquote>
<p>a lightweight, unmanaged alternative to a GameObject.</p>
</blockquote>
<ul>
<li>非托管对象，仅是一个唯一的标识符编号</li>
<li>Components通常为struct values。</li>
<li>实体没有MonoBehavior那样的事件函数</li>
<li>单个实体不能持有多个同类型的组件</li>
<li>实体本身没有父级概念。标准的Parent Component包含一个另外实体的引用从而构成关系。</li>
</ul>
<h2 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h2><h3 id="子场景GO烘培Entity"><a href="#子场景GO烘培Entity" class="headerlink" title="子场景GO烘培Entity"></a>子场景GO烘培Entity</h3><p>默认在子场景中的，含有对应Baker组件的GameObject会转换为Entity。<br>可以查看EntityBakingPreview来确定。如果对应的GameObject没有进行烘培，则不会转为Entity。在处理Subscene的时候也不会进行处理。</p>
<h3 id="烘培过程"><a href="#烘培过程" class="headerlink" title="烘培过程"></a>烘培过程</h3><p>在Authoring中重写的Baker函数，可以通过GetEntity方法将对应的GameObject转换为Entity。</p>
<p>这里额外提一点，对于引用Prefab的GameObject,也可以通过GetEntity的方式转换为IComponentData中的数据。用于之后使用EntityManager生成实体的模板。</p>
<p>可以参考Entities101 中的CrossQuery的SpawnSystem的处理逻辑。</p>
<h2 id="Component组件"><a href="#Component组件" class="headerlink" title="Component组件"></a>Component组件</h2><h3 id="前言和总结"><a href="#前言和总结" class="headerlink" title="前言和总结"></a>前言和总结</h3><p>理解多种多样Component的一个关键重点是其是否托管以及内存分布。</p>
<h3 id="基础组件-非托管组件-UnmanagedComponent"><a href="#基础组件-非托管组件-UnmanagedComponent" class="headerlink" title="基础组件 非托管组件 UnmanagedComponent"></a>基础组件 非托管组件 UnmanagedComponent</h3><p>实现IComponentData</p>
<ul>
<li>非托管结构体<ul>
<li>Blittable types</li>
<li>bool</li>
<li>char</li>
<li>BlobAssetReference<T>, a reference to a Blob data structure</li>
<li>Collections.FixedString, a fixed-sized character buffer</li>
<li>Collections.FixedList</li>
<li>Fixed array (only allowed in an unsafe context)</li>
<li>Other struct types that conform to these same restrictions.</li>
</ul>
</li>
<li>概念上pure data，no method,实际没有限制</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// an entity component type with two fields</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Health : IComponentData</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> HitPoints;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> ArmourRating:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="托管组件-ManagedComponent"><a href="#托管组件-ManagedComponent" class="headerlink" title="托管组件 ManagedComponent"></a>托管组件 ManagedComponent</h3><ul>
<li>支持任意类型数据</li>
<li>不允许在Jobs中进行访问</li>
<li>不能使用Burst Compile</li>
<li>需要进行GC</li>
<li>Must include a constructor with no parameters for serialization purposes.</li>
</ul>
<p>使用类class来创建托管组件</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DirectoryManaged</span> : <span class="title">IComponentData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject RotatorPrefab;</span><br><span class="line">    <span class="keyword">public</span> Toggle RotationToggle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Every IComponentData class must have a no-arg constructor.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectoryManaged</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RotatorGO</span> : <span class="title">IComponentData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject Value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RotatorGO</span>(<span class="params">GameObject <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Value = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Every IComponentData class must have a no-arg constructor.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RotatorGO</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从实践上来说，最佳实践是实现ICloneable和IDisposable接口，用于处理复制和销毁相关的逻辑处理。</p>
<h4 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h4><blockquote>
<p>Unlike unmanaged components, Unity doesn’t store managed components directly in chunks. Instead, Unity stores them in <strong>one big array</strong> for the whole World. Chunks then store the array indices of the relevant managed components. This means when you access a managed component of an entity, Unity processes an extra index lookup. This makes managed components less optimal than unmanaged components.</p>
</blockquote>
<p>并不存放在Chunk中，而是单独的数组。</p>
<h3 id="Tag-Component"><a href="#Tag-Component" class="headerlink" title="Tag Component"></a>Tag Component</h3><blockquote>
<p>An IComponentData struct with no fields is called a tag component.<br>Useful for queries.<br>比如用于MonsterTag</p>
</blockquote>
<h3 id="DynamicBuffer-Component-动态缓冲区组件"><a href="#DynamicBuffer-Component-动态缓冲区组件" class="headerlink" title="DynamicBuffer Component 动态缓冲区组件"></a>DynamicBuffer Component 动态缓冲区组件</h3><p>因为ECS中的通用组件只能存储值类型，而没有引用类型 - 无法定义数组或列表。由此利用DynamicBuffer Component。<br>对于组件中的数据，可以考虑Collection包的Native Container相关内容。</p>
<blockquote>
<p>A component type which is a resizable array.</p>
</blockquote>
<p>实现IBufferElementData接口。</p>
<p>每一个Buffer有一个长度Length、容量Capacity和一个指针。<br>关于这块，有属性InternalBufferCapacity可以指定容量，如</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">InternalBufferCapacity(3)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> IntBufferElement : IBufferElementData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，总占用为128字节。因此容量为128&#x2F;sizeof(T)<br>不过，如果设置的内容超过容量了，会在外部分配一个更大的新数组。这块可以参考这个文档中Dynamic Buffer的部分：<br><a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1R6E4IDpfLatwHITlCND0i5TuMVG0CMGsentFL-3RQT0/edit?usp=sharing">Entities 101</a></p>
<blockquote>
<p>If the length of a dynamic buffer is ever greater than the capacity, Unity <strong>copies the dynamic buffer data to an array outside of the chunk</strong>. If the length of the dynamic buffer later shrinks to less than the capacity, Unity <strong>still stores the data outside of the chunk</strong>; if Unity moves dynamic buffer data outside of a chunk, it never moves the data back into the chunk.</p>
</blockquote>
<p>因此，最好还是规定好对应的容量，不要超了。但对于长度变化很大的，Unity的建议是直接使用外部存储，不存储在块中:</p>
<blockquote>
<p>If the size of a dynamic buffer changes too much, it’s best practice to store its data outside of the chunk. To do this, set the InternalBufferCapacity to 0.</p>
</blockquote>
<p>用于动态缓冲区的方法:</p>
<ul>
<li>AddComponent<T>:基本同AddBuffer</li>
<li>AddBuffer<T>：返回DynamicBuffer<T></li>
<li>RemoveComponent<T></li>
<li>HasBuffer<T></li>
<li>GetBuffer<T></li>
</ul>
<h4 id="DynamicBuffer"><a href="#DynamicBuffer" class="headerlink" title="DynamicBuffer"></a>DynamicBuffer</h4><p>动态缓冲区组件。类似于List般使用<br>主要方法：</p>
<ul>
<li>Length</li>
<li>Capacity</li>
<li>Item[Int32] 获取&#x2F;设定指定位置的元素</li>
<li>Add()</li>
<li>Insert()</li>
<li>RemoveAt()</li>
</ul>
<h3 id="层级关系"><a href="#层级关系" class="headerlink" title="层级关系"></a>层级关系</h3><p>ECS中实体的层级其实和Parent、Child组件有关。<br>对应的是实现IComponentData的Parent和实现ICleanupBufferElementData与IBufferElementData的Child。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例系统代码</span></span><br><span class="line"><span class="built_in">bool</span> attached;</span><br><span class="line"><span class="built_in">float</span> timer;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">float</span> interval = <span class="number">0.7f</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">BurstCompile</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"><span class="keyword">ref</span> SystemState state</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    timer -= SystemAPI.Time.DeltaTime;</span><br><span class="line">    <span class="keyword">if</span> (timer &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    timer = interval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用组件来获取单例实体</span></span><br><span class="line">    <span class="keyword">var</span> rotatorEntity = SystemAPI.GetSingletonEntity&lt;RotationSpeed&gt;();</span><br><span class="line">    <span class="keyword">var</span> ecb = <span class="keyword">new</span> EntityCommandBuffer(Allocator.Temp);</span><br><span class="line">    <span class="keyword">if</span> (attached)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Detach all children from the rotator by removing the Parent component from the children.</span></span><br><span class="line">        <span class="comment">// (The next time TransformSystemGroup updates, it will update the Child buffer and transforms accordingly.)</span></span><br><span class="line"></span><br><span class="line">        DynamicBuffer&lt;Child&gt; children = SystemAPI.GetBuffer&lt;Child&gt;(rotatorEntity);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; children.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Using an ECB is the best option here because calling EntityManager.RemoveComponent()</span></span><br><span class="line">            <span class="comment">// instead would invalidate the DynamicBuffer, meaning we&#x27;d have to re-retrieve</span></span><br><span class="line">            <span class="comment">// the DynamicBuffer after every EntityManager.RemoveComponent() call.</span></span><br><span class="line">            <span class="comment">//依旧是延后执行</span></span><br><span class="line">            ecb.RemoveComponent&lt;Parent&gt;(children[i].Value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Alternative solution instead of the above loop:</span></span><br><span class="line">        <span class="comment">// A single call that removes the Parent component from all entities in the array.</span></span><br><span class="line">        <span class="comment">// Because the method expects a NativeArray&lt;Entity&gt;, we create a NativeArray&lt;Entity&gt; alias of the DynamicBuffer.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ecb.RemoveComponent&lt;Parent&gt;(children.AsNativeArray().Reinterpret&lt;Entity&gt;());</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Attach all the small cubes to the rotator by adding a Parent component to the cubes.</span></span><br><span class="line">        <span class="comment">// (The next time TransformSystemGroup updates, it will update the Child buffer and transforms accordingly.)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> (transform, entity) <span class="keyword">in</span></span><br><span class="line">                  SystemAPI.Query&lt;RefRO&lt;LocalTransform&gt;&gt;()</span><br><span class="line">                      .WithNone&lt;RotationSpeed&gt;()</span><br><span class="line">                      .WithEntityAccess())</span><br><span class="line">        &#123;</span><br><span class="line">            ecb.AddComponent(entity, <span class="keyword">new</span> Parent &#123; Value = rotatorEntity &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Alternative solution instead of the above loop:</span></span><br><span class="line">        <span class="comment">// Add a Parent value to all entities matching a query.</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        var query = SystemAPI.QueryBuilder().WithAll&lt;LocalTransform&gt;().WithNone&lt;RotationSpeed&gt;().Build();</span></span><br><span class="line"><span class="comment">        ecb.AddComponent(query, new Parent &#123; Value = rotatorEntity &#125;);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行缓存的指令</span></span><br><span class="line">    ecb.Playback(state.EntityManager);</span><br><span class="line"></span><br><span class="line">    attached = !attached;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较需要留意的就是添加&#x2F;删除组件会移动Entity到不同原型对应的chunk。且对于Dynamic Buffer而言也是的。</p>
<h3 id="可激活组件-IEnableableComponent"><a href="#可激活组件-IEnableableComponent" class="headerlink" title="可激活组件 IEnableableComponent"></a>可激活组件 IEnableableComponent</h3><p><strong>组件的启用&#x2F;禁用-&gt; 影响查询状态。</strong></p>
<p>在实现IComponentData以外，实现IEnableableComponent接口</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> RotationSpeed : IComponentData, IEnableableComponent</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> RadiansPerSecond;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置组件启用:<br>SetComponentEnabled<RotationSpeed>(entity,enabled);</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">BurstCompile</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"><span class="keyword">ref</span> SystemState state</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">float</span> deltaTime = SystemAPI.Time.DeltaTime;</span><br><span class="line">    timer -= deltaTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Toggle the enabled state of every RotationSpeed</span></span><br><span class="line">    <span class="keyword">if</span> (timer &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//处理EnableState的启用/禁用</span></span><br><span class="line">      <span class="comment">//WithOptions来包含禁用的组件</span></span><br><span class="line">      <span class="comment">//或者是IgnoreFilter相关函数</span></span><br><span class="line">      <span class="keyword">foreach</span> (EnabledRefRW&lt;RotationSpeed&gt; rotationSpeedEnabled <span class="keyword">in</span></span><br><span class="line">                SystemAPI.Query&lt;EnabledRefRW&lt;RotationSpeed&gt;&gt;()</span><br><span class="line">                    .WithOptions(EntityQueryOptions.IgnoreComponentEnabledState))</span><br><span class="line">      &#123;</span><br><span class="line">          rotationSpeedEnabled.ValueRW = !rotationSpeedEnabled.ValueRO;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      timer = interval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The query only matches entities whose RotationSpeed is enabled.</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> (transform, speed) <span class="keyword">in</span></span><br><span class="line">              SystemAPI.Query&lt;RefRW&lt;LocalTransform&gt;, RefRO&lt;RotationSpeed&gt;&gt;())</span><br><span class="line">    &#123;</span><br><span class="line">      transform.ValueRW = transform.ValueRO.RotateY(</span><br><span class="line">          speed.ValueRO.RadiansPerSecond * deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a>同步问题</h4><p>由于组件是否激活会影响到查询，因此存在着对应的异步问题。</p>
<blockquote>
<p>All synchronous EntityQuery operations (except those which ignore filtering) automatically wait for any running jobs to complete which have write access to the query’s enableable components.All asynchronous EntityQuery operations (those ending in Async) automatically insert an input dependency on these running jobs as well.</p>
</blockquote>
<p>具体的可以看官方文档。<br><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/components-enableable-use.html#asynchronous-operations">Entities - Enableable components</a></p>
<h3 id="Shared-Component"><a href="#Shared-Component" class="headerlink" title="Shared Component"></a>Shared Component</h3><blockquote>
<p>De-duplication of data. Unity stores all entities of an archetype that have the same shared component values together. This removes repeated values across entities.</p>
</blockquote>
<p>支持Managed和UnManaged组件。非托管的可以使用Burst Compiler,具体的看官方文档。</p>
<h4 id="内存分布-1"><a href="#内存分布-1" class="headerlink" title="内存分布"></a>内存分布</h4><p>其数据也不存放在Chunk中。Chunk中只存handle用于定位。<br>但需要注意，对于Shared Component值的改变会触发Entity的移动：</p>
<blockquote>
<p>If you change the shared component value for an entity, Unity <strong>moves the entity to a chunk that uses the new shared component value</strong>. This means that changing a shared component value for an entity is a <strong>structural change</strong>. </p>
</blockquote>
<p>不仅是存储Shared Component的数组会有新的Component添加，对于的Entity也会移动到New Chunk。</p>
<h3 id="Chunk-Component"><a href="#Chunk-Component" class="headerlink" title="Chunk Component"></a>Chunk Component</h3><blockquote>
<p>Stores values per chunk instead of per entity</p>
</blockquote>
<p>有些类似于SharedComponent.<br>但从逻辑上讲，对于的数据属于Trunk而非Entity。</p>
<ul>
<li>Setting a chunk component value isn’t a structural change.</li>
<li>始终非托管。</li>
<li>与Shared Component不同,允许值重复，每个值在Chunk中有自己的单独副本。</li>
</ul>
<p>可以认为对应的数据属于某一个原型对应的Chunk，如果一个实体的原型改变，其移动后并不会改变对应的Chunk数据。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//The difference between chunk components and unmanaged components is how you add them to an entity.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> ExampleChunkComponent : IComponentData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Value;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//To use the unmanaged component as a chunk component</span></span><br><span class="line">    EntityManager.AddChunkComponentData&lt;ExampleChunkComponent&gt;(Entity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Singleton-components"><a href="#Singleton-components" class="headerlink" title="Singleton components"></a>Singleton components</h3><blockquote>
<p>Only one instance in a given world.</p>
</blockquote>
<p>类似于全局组件的概念。<br>有对应的API专门处理单例。<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/components-singleton.html">官方DOC</a></p>
<p>额外需要注意的是，在System中调用单例相关的API不一定确保依赖项。<br>需要手动调用对应的EntityManager.CompleteDependencyBeforeRO&#x2F;EntityManager.CompleteDependencyBeforeRW来进行同步。</p>
<p>在进行对应单例中的数据修改的时候，也需要考虑多线程和同步的问题。具体可以参考官方Doc。</p>
<h3 id="Cleanup-Component"><a href="#Cleanup-Component" class="headerlink" title="Cleanup Component"></a>Cleanup Component</h3><blockquote>
<p>When you destroy an entity that contains one, Unity removes all non-cleanup components instead. The entity still exists until you remove all cleanup components from it. This is useful to tag entities that require cleanup when destroyed.</p>
</blockquote>
<p>直到所有Cleanup组件被移除才会真正销毁实体。</p>
<h3 id="Native-Container"><a href="#Native-Container" class="headerlink" title="Native Container"></a>Native Container</h3><p>Collections包提供了一些Native Container,如NativeList、NativeHashMap以及非安全的UnsafeList。</p>
<p>这块的内存应该也不是存储于Chunk中的。待验证。</p>
<h2 id="Entity-Worlds-And-EntityManagers"><a href="#Entity-Worlds-And-EntityManagers" class="headerlink" title="Entity Worlds And EntityManagers"></a>Entity Worlds And EntityManagers</h2><h3 id="世界World"><a href="#世界World" class="headerlink" title="世界World"></a>世界World</h3><ul>
<li>实体的集合。在其中每个实体有着唯一ID。</li>
<li>持有一组系统</li>
</ul>
<h3 id="EntityManager"><a href="#EntityManager" class="headerlink" title="EntityManager"></a>EntityManager</h3><p>管理实体的创建、销毁和修改。</p>
<ul>
<li>CreateEntity()</li>
<li>Instantiate(): Creates a new entity with a copy of all the components of an existing entity.</li>
<li>DestroyEntity(): Destroys an existing entity.</li>
<li>AddComponent<T>()</li>
<li>RemoveComponent<T>()</li>
<li>HasComponent<T>()</li>
<li>GetComponent<T>()</li>
<li>SetComponent<T>(): Overwrites the value of an entity’s component of type T.</li>
</ul>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载对象示例代码。留意GameObject到Entity的转换。</span></span><br><span class="line"><span class="comment">// An authoring component is just a normal MonoBehavior that has a Baker&lt;T&gt; class.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SpawnerAuthoring</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject Prefab;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In baking, this Baker will run once for every SpawnerAuthoring instance in a subscene.</span></span><br><span class="line">    <span class="comment">// (Note that nesting an authoring component&#x27;s Baker class inside the authoring MonoBehaviour class</span></span><br><span class="line">    <span class="comment">// is simply an optional matter of style.)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Baker</span> : <span class="title">Baker</span>&lt;<span class="title">SpawnerAuthoring</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Bake</span>(<span class="params">SpawnerAuthoring authoring</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> entity = GetEntity(TransformUsageFlags.None);</span><br><span class="line">            AddComponent(entity, <span class="keyword">new</span> Spawner</span><br><span class="line">            &#123;</span><br><span class="line">                Prefab = GetEntity(authoring.Prefab, TransformUsageFlags.Dynamic)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Spawner : IComponentData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Entity Prefab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//System代码</span></span><br><span class="line">[<span class="meta">BurstCompile</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"><span class="keyword">ref</span> SystemState state</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create a query that matches all entities having a RotationSpeed component.</span></span><br><span class="line">    <span class="comment">// (The query is cached in source generation, so this does not incur a cost of recreating it every update.)</span></span><br><span class="line">    EntityQuery spinningCubesQuery = SystemAPI.QueryBuilder().WithAll&lt;RotationSpeed,LocalTransform&gt;().Build();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Only spawn cubes when no cubes currently exist.</span></span><br><span class="line">    <span class="keyword">if</span> (spinningCubesQuery.IsEmpty)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//获取单个组件（场景中存在多个的情况下会报错）</span></span><br><span class="line">      Entity prefab = SystemAPI.GetSingleton&lt;Spawner&gt;().Prefab;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//通过State获取EntityManager 然后进行预设的实例化</span></span><br><span class="line">      <span class="comment">// Instantiating an entity creates copy entities with the same component types and values.</span></span><br><span class="line">      NativeArray&lt;Entity&gt; instances = state.EntityManager.Instantiate(prefab, <span class="number">500</span>, Allocator.Temp);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Unlike new Random(), CreateFromIndex() hashes the random seed</span></span><br><span class="line">      <span class="comment">// so that similar seeds don&#x27;t produce similar results.</span></span><br><span class="line">      <span class="keyword">var</span> random = Random.CreateFromIndex(updateCounter++);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">foreach</span> (Entity entity <span class="keyword">in</span> instances)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// Update the entity&#x27;s LocalTransform component with the new position.</span></span><br><span class="line">          <span class="keyword">var</span> transform = SystemAPI.GetComponentRW&lt;LocalTransform&gt;(entity);</span><br><span class="line">          transform.ValueRW.Position = (random.NextFloat3() - <span class="keyword">new</span> float3(<span class="number">0.5f</span>, <span class="number">0</span>, <span class="number">0.5f</span>)) * <span class="number">20</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Better Way</span></span><br><span class="line">      <span class="comment">//单个实体组件的查询开销更高 内存布局问题</span></span><br><span class="line">      <span class="keyword">foreach</span> (<span class="keyword">var</span> (transform, rotationSpeed) <span class="keyword">in</span> SystemAPI.Query&lt;RefRW&lt;LocalTransform&gt;, RefRO&lt;RotationSpeed&gt;&gt;())</span><br><span class="line">      &#123;</span><br><span class="line">          transform.ValueRW.Position = (random.NextFloat3() - <span class="keyword">new</span> float3(<span class="number">0.5f</span>, <span class="number">0</span>, <span class="number">0.5f</span>)) * <span class="number">20</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Archetypes-原型"><a href="#Archetypes-原型" class="headerlink" title="Archetypes 原型"></a>Archetypes 原型</h3><blockquote>
<p>Represents a particular unique combination of component types in a world: all of the entities in a world with a certain set of component types are stored together in the same archetype. </p>
</blockquote>
<p>特定的组件组合 - 构成Archetype。不同的实体基于自己的组件类型位于不同的原型之下。这块可以去了解一下ECS的内存。</p>
<p>相关原型的创建、实体原型的切换等都有EntityManager处理。但是，即使所有的实体都从原型中移除，原型要直到世界销毁才会销毁。</p>
<h3 id="Chunks-实体内存分布"><a href="#Chunks-实体内存分布" class="headerlink" title="Chunks 实体内存分布"></a>Chunks 实体内存分布</h3><p>可以结合团结演讲的图一起理解:<br><a target="_blank" rel="noopener" href="https://developer.unity.cn/projects/677ca79dedbc2a001f135aec">团结引擎高性能ECS架构</a><br>The entities of an archetype are stored in <strong>16KiB</strong> blocks of memory belonging to the archetype called chunks. Each chunk stores up to <strong>128</strong> entities. (In an archetype where the space required for each entity exceeds 16KiB &#x2F; 128, the max number of entities per chunk will be lower).</p>
<h3 id="Queries"><a href="#Queries" class="headerlink" title="Queries"></a>Queries</h3><p>使用EntityQuery。高效的查找所有具有指定组件类型集合的实体。<br>本质上是利用原型。</p>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><h5 id="SystemAPI-Query"><a href="#SystemAPI-Query" class="headerlink" title="SystemAPI.Query"></a>SystemAPI.Query</h5><p>一般的使用SystemAPI.Query来执行操作。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> (transform, speed) <span class="keyword">in</span></span><br><span class="line">            SystemAPI.Query&lt;RefRW&lt;LocalTransform&gt;, RefRO&lt;RotationSpeed&gt;&gt;())</span><br><span class="line">&#123;</span><br><span class="line">    transform.ValueRW = transform.ValueRO.RotateY(speed.ValueRO.RadiansPerSecond * deltaTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="EntityQuery"><a href="#EntityQuery" class="headerlink" title="EntityQuery"></a>EntityQuery</h5><p>使用SystemAPI来构建:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">EntityQuery spinningCubesQuery = SystemAPI.QueryBuilder().WithAll&lt;RotationSpeed,LocalTransform&gt;().Build();</span><br></pre></td></tr></table></figure>

<p>WithAll和WithEntityAccess<br>对于不需要实际访问的组件可以用WithAll来进行判断。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WithAll() includes RotationSpeed in the query, but</span></span><br><span class="line"><span class="comment">// the RotationSpeed component values will not be accessed.</span></span><br><span class="line"><span class="comment">// WithEntityAccess() includes the Entity ID as the last element of the tuple.</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> (transform, entity) <span class="keyword">in</span></span><br><span class="line">          SystemAPI.Query&lt;RefRW\&lt;LocalTransform&gt;&gt;()</span><br><span class="line">              .WithAll&lt;RotationSpeed&gt;()</span><br><span class="line">              .WithEntityAccess())</span><br></pre></td></tr></table></figure>

<h4 id="IAspect-抽象封装"><a href="#IAspect-抽象封装" class="headerlink" title="IAspect 抽象封装"></a>IAspect 抽象封装</h4><p>可以创建实现IAspect的struct，来封装要查询的对象和执行的逻辑。<br>不过在使用Aspect进行抽象封装的时候，注意readonly和partial。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//System逻辑</span></span><br><span class="line">[<span class="meta">BurstCompile</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"><span class="keyword">ref</span> SystemState state</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">float</span> deltaTime = SystemAPI.Time.DeltaTime;</span><br><span class="line">    <span class="built_in">double</span> elapsedTime = SystemAPI.Time.ElapsedTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rotate the cube directly without using the aspect.</span></span><br><span class="line">    <span class="comment">// The query matches all entities having the LocalTransform and RotationSpeed components.</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> (transform, speed) <span class="keyword">in</span></span><br><span class="line">              SystemAPI.Query&lt;RefRW&lt;LocalTransform&gt;, RefRO&lt;RotationSpeed&gt;&gt;())</span><br><span class="line">    &#123;</span><br><span class="line">        transform.ValueRW = transform.ValueRO.RotateY(speed.ValueRO.RadiansPerSecond * deltaTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rotate the cube using the aspect.</span></span><br><span class="line">    <span class="comment">// The query will include all components of VerticalMovementAspect.</span></span><br><span class="line">    <span class="comment">// Note that, unlike components, aspect type params of SystemAPI.Query are not wrapped in a RefRW or RefRO.</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> movement <span class="keyword">in</span></span><br><span class="line">              SystemAPI.Query&lt;VerticalMovementAspect&gt;())</span><br><span class="line">    &#123;</span><br><span class="line">        movement.Move(elapsedTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Aspect封装 - 多个组件类型的封装</span></span><br><span class="line"><span class="comment">// An instance of this aspect wraps the LocalTransform and RotationSpeed components of a single entity.</span></span><br><span class="line"><span class="comment">// (This trivial example is arguably not a worthwhile use case for aspects, but larger examples better demonstrate their utility.)</span></span><br><span class="line"><span class="keyword">readonly</span> <span class="keyword">partial</span> <span class="keyword">struct</span> VerticalMovementAspect : IAspect</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">readonly</span> RefRW&lt;LocalTransform&gt; m_Transform;</span><br><span class="line">    <span class="keyword">readonly</span> RefRO&lt;RotationSpeed&gt; m_Speed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Move</span>(<span class="params"><span class="built_in">double</span> elapsedTime</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_Transform.ValueRW.Position.y = (<span class="built_in">float</span>)math.sin(elapsedTime * m_Speed.ValueRO.RadiansPerSecond);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ECB-EntityCommandBuffer"><a href="#ECB-EntityCommandBuffer" class="headerlink" title="ECB EntityCommandBuffer"></a>ECB EntityCommandBuffer</h3><p>延后指令执行</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An EntityCommandBuffer created from EntityCommandBufferSystem.Singleton will be</span></span><br><span class="line"><span class="comment">// played back and disposed by the EntityCommandBufferSystem when it next updates.</span></span><br><span class="line"><span class="keyword">var</span> ecbSingleton = SystemAPI.GetSingleton&lt;BeginSimulationEntityCommandBufferSystem.Singleton&gt;();</span><br><span class="line">EntityCommandBuffer ecb = ecbSingleton.CreateCommandBuffer(state.WorldUnmanaged);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Downward vector</span></span><br><span class="line"><span class="keyword">var</span> movement = <span class="keyword">new</span> float3(<span class="number">0</span>, -SystemAPI.Time.DeltaTime * <span class="number">5f</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// WithAll() includes RotationSpeed in the query, but</span></span><br><span class="line"><span class="comment">// the RotationSpeed component values will not be accessed.</span></span><br><span class="line"><span class="comment">// WithEntityAccess() includes the Entity ID as the last element of the tuple.</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> (transform, entity) <span class="keyword">in</span></span><br><span class="line">          SystemAPI.Query&lt;RefRW&lt;LocalTransform&gt;&gt;()</span><br><span class="line">              .WithAll&lt;RotationSpeed&gt;()</span><br><span class="line">              .WithEntityAccess())</span><br><span class="line">&#123;</span><br><span class="line">    transform.ValueRW.Position += movement;</span><br><span class="line">    <span class="keyword">if</span> (transform.ValueRO.Position.y &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Making a structural change would invalidate the query we are iterating through,</span></span><br><span class="line">        <span class="comment">// so instead we record a command to destroy the entity later.</span></span><br><span class="line">        ecb.DestroyEntity(entity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Entities-Meta-Data"><a href="#Entities-Meta-Data" class="headerlink" title="Entities Meta Data"></a>Entities Meta Data</h3><p>Each world keeps track of its entities in a single,large array.<br>包含</p>
<ul>
<li>Chunk指针</li>
<li>Index in chunk</li>
<li>Version number</li>
</ul>
<h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><p>A Unit Of Code.<br>实现ISystem接口。</p>
<p>关键方法：</p>
<ul>
<li>OnCreate:Called before the first call to OnUpdate and whenever a system resumes running.</li>
<li><ul>
<li>OnUpdate</li>
</ul>
</li>
<li>OnDestroy:Called when a system is destroyed.<br>这三个方法都会传递一个SystemState参数。</li>
</ul>
<p>Enabled属性，决定是否会Update。</p>
<p>可选实现接口:ISystemStartStop</p>
<ul>
<li>OnStartRunning()</li>
<li>OnStopRunning()</li>
</ul>
<h3 id="System-Update"><a href="#System-Update" class="headerlink" title="System Update"></a>System Update</h3><p>可以通过在OnCreate的时候，调用SystemState的RequireForUpdate函数来进行系统注册，确定系统的更新条件。</p>
<p>也可以通过state.Enabled来进行设置。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">BurstCompile</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnCreate</span>(<span class="params"><span class="keyword">ref</span> SystemState state</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// We need to wait for the scene to load before Updating, so we must RequireForUpdate at</span></span><br><span class="line">    <span class="comment">// least one component type loaded from the scene.</span></span><br><span class="line">    state.RequireForUpdate&lt;ExecuteGameObjectSync&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//直接设置更新</span></span><br><span class="line">    state.Enabled = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="System-Group"><a href="#System-Group" class="headerlink" title="System Group"></a>System Group</h3><p>分组确定了System在哪个阶段执行Update，以及各个System之间的Update顺序。</p>
<p>使用属性来确保顺序</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">UpdateBefore(typeof(Tutorials.Firefighters.SpawnSystem))</span>]</span><br><span class="line"><span class="comment">//[UpdateAfter(typeof(Tutorials.Firefighters.SpawnSystem))]</span></span><br><span class="line"><span class="comment">//[UpdateInGroup(typeof(FixedStepSimulationSystemGroup))]</span></span><br><span class="line">[<span class="meta">BurstCompile</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">struct</span> MySystem : ISystem</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">BurstCompile</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"><span class="keyword">ref</span> SystemState state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.LogError(<span class="string">&quot;MySystem Update&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于分组这块，可以看到对应的System Window。<br>Window - Entities - System<br>ECS相关的信息都需要单独查看。</p>
<h2 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h2><p>World持有一个Time属性，TimeData Struct。</p>
<h2 id="Jobs"><a href="#Jobs" class="headerlink" title="Jobs"></a>Jobs</h2><p>两个用于访问实体的接口：</p>
<ul>
<li>IJobEntity：对于符合查询条件的实体，调用一次Execute</li>
<li>IJobChunk：对于符合查询条件的块(Chunk)，调用一次Execute<ul>
<li>具体而言，是原型的Chunk。直接对Chunk数据流操作，需要通过一些Handle来定位对应的数据。可以看官方的Entities 101示例。</li>
</ul>
</li>
</ul>
<p>IJobEntity实际上底层实现也是会转换为IJobChunk。不过一般IJobEntity使用起来更为便利。</p>
<p>多线程调用的话用 ScheduleParallel而非Schedule。</p>
<h3 id="IJobEntity示例"><a href="#IJobEntity示例" class="headerlink" title="IJobEntity示例"></a>IJobEntity示例</h3><p>可以看到官方的Entities 101示例。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//System调用</span></span><br><span class="line">[<span class="meta">BurstCompile</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"><span class="keyword">ref</span> SystemState state</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> job = <span class="keyword">new</span> RotateAndScaleJob</span><br><span class="line">    &#123;</span><br><span class="line">        deltaTime = SystemAPI.Time.DeltaTime,</span><br><span class="line">        elapsedTime = (<span class="built_in">float</span>)SystemAPI.Time.ElapsedTime</span><br><span class="line">    &#125;;</span><br><span class="line">    job.Schedule();<span class="comment">//这里的调度存在语法糖，实际相当于下面，会维护依赖关系。</span></span><br><span class="line">    <span class="comment">//state.Dependency = job.Schedule(state.Dependency);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//IJob定义</span></span><br><span class="line">[<span class="meta">BurstCompile</span>]</span><br><span class="line"><span class="keyword">partial</span> <span class="keyword">struct</span> RotateAndScaleJob : IJobEntity</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> deltaTime;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> elapsedTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In source generation, a query is created from the parameters of Execute().</span></span><br><span class="line">    <span class="comment">// Here, the query will match all entities having a LocalTransform, PostTransformMatrix, and RotationSpeed component.</span></span><br><span class="line">    <span class="comment">// (In the scene, the root cube has a non-uniform scale, so it is given a PostTransformMatrix component in baking.)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="keyword">ref</span> LocalTransform transform, <span class="keyword">ref</span> PostTransformMatrix postTransform, <span class="keyword">in</span> RotationSpeed speed</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform = transform.RotateY(speed.RadiansPerSecond * deltaTime);</span><br><span class="line">        postTransform.Value = float4x4.Scale(<span class="number">1</span>, math.sin(elapsedTime), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IJobEntity的Execute本身会作为一个Filter。</p>
<h3 id="IJobChunk示例"><a href="#IJobChunk示例" class="headerlink" title="IJobChunk示例"></a>IJobChunk示例</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//System</span></span><br><span class="line">[<span class="meta">BurstCompile</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"><span class="keyword">ref</span> SystemState state</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> spinningCubesQuery = SystemAPI.QueryBuilder().WithAll&lt;RotationSpeed, LocalTransform&gt;().Build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> job = <span class="keyword">new</span> RotationJob</span><br><span class="line">    &#123;</span><br><span class="line">        TransformTypeHandle = SystemAPI.GetComponentTypeHandle&lt;LocalTransform&gt;(),</span><br><span class="line">        <span class="comment">//传入true代表Readonly</span></span><br><span class="line">        RotationSpeedTypeHandle = SystemAPI.GetComponentTypeHandle&lt;RotationSpeed&gt;(<span class="literal">true</span>),</span><br><span class="line">        DeltaTime = SystemAPI.Time.DeltaTime</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unlike an IJobEntity, an IJobChunk must be manually passed a query.</span></span><br><span class="line">    <span class="comment">// Furthermore, IJobChunk does not pass and assign the state.Dependency JobHandle implicitly.</span></span><br><span class="line">    <span class="comment">// (This pattern of passing and assigning state.Dependency ensures that the entity jobs scheduled</span></span><br><span class="line">    <span class="comment">// in different systems will depend upon each other as needed.)</span></span><br><span class="line">    state.Dependency = job.Schedule(spinningCubesQuery, state.Dependency);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Job定义</span></span><br><span class="line">[<span class="meta">BurstCompile</span>]</span><br><span class="line"><span class="keyword">struct</span> RotationJob : IJobChunk</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ComponentTypeHandle&lt;LocalTransform&gt; TransformTypeHandle;</span><br><span class="line">    [<span class="meta">ReadOnly</span>] <span class="keyword">public</span> ComponentTypeHandle&lt;RotationSpeed&gt; RotationSpeedTypeHandle;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> DeltaTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="keyword">in</span> ArchetypeChunk chunk, <span class="built_in">int</span> unfilteredChunkIndex, <span class="built_in">bool</span> useEnabledMask,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">in</span> v128 chunkEnabledMask</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The useEnableMask parameter is true when one or more entities in</span></span><br><span class="line">        <span class="comment">// the chunk have components of the query that are disabled.</span></span><br><span class="line">        <span class="comment">// If none of the query component types implement IEnableableComponent,</span></span><br><span class="line">        <span class="comment">// we can assume that useEnabledMask will always be false.</span></span><br><span class="line">        <span class="comment">// However, it&#x27;s good practice to add this guard check just in case</span></span><br><span class="line">        <span class="comment">// someone later changes the query or component types.</span></span><br><span class="line">        <span class="comment">//可以看看源码对于useEnabledMask的解释。主要是对于部分实体会把组件disable的情况（IEnableableComponent）</span></span><br><span class="line">        <span class="comment">//不过注意 Burst情况下Asset有问题 建议Debug时不要Burst。</span></span><br><span class="line">        Assert.IsFalse(useEnabledMask);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取组件NativeArray</span></span><br><span class="line">        <span class="comment">//注意ComponentTypeHandle为struct</span></span><br><span class="line">        NativeArray&lt;LocalTransform&gt; transforms = chunk.GetNativeArray(<span class="keyword">ref</span> TransformTypeHandle);</span><br><span class="line">        NativeArray&lt;RotationSpeed&gt; rotationSpeeds = chunk.GetNativeArray(<span class="keyword">ref</span> RotationSpeedTypeHandle);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>, chunkEntityCount = chunk.Count; i &lt; chunkEntityCount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            transforms[i] = transforms[i].RotateY(rotationSpeeds[i].RadiansPerSecond * DeltaTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>必须传入对于的Query确定。</li>
<li>不会隐式设置Dependence，需要显示设置。</li>
<li>使用ComponentTypeHandle，用于在Chunk中定位组件数据位置</li>
</ul>
<h3 id="同步点"><a href="#同步点" class="headerlink" title="同步点"></a>同步点</h3><p>部分函数会触发同步，以完成对某些组件的Job。</p>
<p>如：</p>
<ul>
<li>EntityManager.AddComponent<T>()：完成所有访问T组件的Jobs</li>
<li>EntityQuery的ToComponentDataArray<T>()</li>
<li>EntityQuery的ToEntityArray()</li>
<li>EntityQuery的ToArchetypeChunkArray()</li>
</ul>
<p>注意不同Jobs之间的依赖关系。<br>SystemState中有一个JobHandle:Dependency。这个仅用于components type。</p>
<p>两个规则：</p>
<ul>
<li>All jobs scheduled in a system update should (directly or indirectly) depend upon the job handle that was assigned to Dependency right before the update.</li>
<li>Before a system update returns, the Dependency property should be assigned a handle that includes all the jobs scheduled in that update.（即在调用Jobs之后给state的Dependency赋值）</li>
</ul>
<h3 id="组件访问"><a href="#组件访问" class="headerlink" title="组件访问"></a>组件访问</h3><p>Jobs内部一般不能直接用EntityManager，可以考虑ComponentLookup<T>。以及BufferLookup<T>。</p>
<h2 id="ECS和Mono交互"><a href="#ECS和Mono交互" class="headerlink" title="ECS和Mono交互"></a>ECS和Mono交互</h2><p>可以参考Entities 101的GameObjectSync。</p>
<p>System本身可以直接调用托管相关的代码。(调用的部分则不能进行BurstCompile)。</p>
<p>例如:在Update中调用GameObject.Find。<br>不过需要注意，ECS的Hierarchy和默认的Hierarchy并不相同。</p>
<h1 id="官方视频记录"><a href="#官方视频记录" class="headerlink" title="官方视频记录"></a>官方视频记录</h1><p>GameObject</p>
<ul>
<li>Managed Objects, Not able to use Burst compiler</li>
<li>有GC。创建和销毁代价较高。</li>
<li>内存分散 Cache Miss</li>
</ul>
<p>World<br>EntityManager<br>Archetype<br>Chunk</p>
<p>Automatic bootstrapping - by default. All the systems will automatically get added into a default world at the start of play mode.</p>
<!-- flag of hidden posts --></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://MikeMing126.github.io">Ming</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mikeming126.github.io/Mine/Unity/ECS/">https://mikeming126.github.io/Mine/Unity/ECS/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://MikeMing126.github.io" target="_blank">Ming Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Unity/">Unity</a></div><div class="post-share"><div class="social-share" data-image="/img/head.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/Mine/Unity/Animation/" title="Unity Animation"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-14</div><div class="info-item-2">Unity Animation</div></div><div class="info-2"><div class="info-item-1">Mecanim 动画系统Mecanim Animation SystemUnity6 动画系统 作用 Animate the properties of models and assets.  基础概念基于Animation Clips的概念。 Animation Clip包含对象随着事件如何改变位置、旋转或其他属性的相关信息。 外部导入或者Unity内部创建。Clip相关功能：  Transform信息 组件属性 Scripts中的属性 特定时间调用函数  Animation Event 仅支持单个参数的函数  用AnimationEvent Object来传递多个参数：支持一个int,一个float,一个string,一个GameObject引用。 Humanoid Avatar The rigged character model,has a specific configuration of bones mapped to Unity’s Avatar format.  为人形专门设定。Importing a model with humanoid...</div></div></div></a><a class="pagination-related" href="/Mine/Unity/AsyncOp/" title="Unity异步操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-14</div><div class="info-item-2">Unity异步操作</div></div><div class="info-2"><div class="info-item-1">异步操作可以参考这篇文章Unity入门教程之异步篇第二节：协程 or UniTask？Unity 中异步流程到底怎么选Unity异步扩展实践（一）——以UniTask库为参考 关于临界资源问题Unity入门教程之异步篇第三节：多线程初探？理解并发与线程安全 协程 - 逻辑异步 - 单线程协程这块较为通用可以另外参考之前记录。 UniTask本质上是利用C#的Task。但是使用原生的async&#x2F;await和Task存在一些问题：  GC和性能开销(Task本身是引用类型，且async&#x2F;await产生状态机对象和闭包) 线程切换不一定对。且Unity大部分API只能在主线程使用。 任务的生命周期管理问题:任务不会因为对象被销毁而自动停止 平台多线程限制（如WebGL）  因此有UniTaskGitHub优势和注意事项：  零GC 主线程调度。默认完全在Unity的PlayerLoop上运行，因此不使用Thread。在 .NET 实现中，执行 await 语句之前和之后代码的线程是有可能不同的。虽然有线程切换，但我们不需要关心其中的细节，.NET...</div></div></div></a><a class="pagination-related" href="/Mine/Unity/Physics/" title="Unity Physics"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-14</div><div class="info-item-2">Unity Physics</div></div><div class="info-2"><div class="info-item-1">物理 基础Unity物理系统由浅入深第一节：Unity 物理系统基础与应用 RigidBody 刚体 - 赋予物理属性 Collider 碰撞体 - 碰撞形状 Physic Material 物理材质 - 定义交互特性定义碰撞体之间的摩檫力和弹性。分配给Collider。 碰撞事件  Collision Callbacks 适用于两个非触发器（至少一个带RigidBody）之间的物理碰撞 Trigger Callbacks 至少一个Collider为Is Trigger的情况下，检测到物体进入&#x2F;离开&#x2F;停留在区域内 只有当碰撞中一个Collider附加了Rigidbody或者其为KinematicRigidbody上的Colider时，才能触发对应的回调。(对于KinematicRigidbody，不会触发CollisionCallback，需要用TriggerCallback)  射线检测 Raycast形状检测 Shape...</div></div></div></a><a class="pagination-related" href="/Mine/Unity/PostProcessing/" title="Unity PostProcessing"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-05</div><div class="info-item-2">Unity PostProcessing</div></div><div class="info-2"><div class="info-item-1">Introduction to post-processingUnity 后处理 在渲染管线之后，FrameBuffer上处理。后处理和全屏效果。 效果参考和支持Post-processing effect availability reference </div></div></div></a><a class="pagination-related" href="/Mine/Unity/SRP/" title="Unity SRP"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-02</div><div class="info-item-2">Unity SRP</div></div><div class="info-2"><div class="info-item-1">官方Doc Rendering paths in UnityUnity URP&#x2F;SRP 渲染管线浅入深出【匠】【Unity】SRP简单入门【Unity】SRP底层渲染流程及原理Scriptable Render Pipeline可编程渲染管线 Render Pipeline基础  A series of operations that take the contents of a scene, and displays them on a screen  在Unity的官方文档中定义为这么几个步骤：  Culling （Frustum Culling视锥体剔除 Occlusion Culling遮挡剔除） Rendering -&gt;To Pixel Buffers Post Processing -&gt;Modify Pixel Buffers  常用的  Built-in Render Pipeline： Universal Render Pipeline (URP) High Definition Render Pipeline...</div></div></div></a><a class="pagination-related" href="/Mine/Unity/Shadow/" title="Unity Shadow"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-05</div><div class="info-item-2">Unity Shadow</div></div><div class="info-2"><div class="info-item-1">阴影Shadow 光源可以产生两种阴影：  Real-time Shadows 实时阴影 Unity stores the shadows cast from each Light in shadow map textures. The textures update each frame; shadows move when the lights move.   Baked Shadows 烘培阴影 The Unity lightmapper stores the shadows received by each GameObject in static lightmap textures, shadow mask textures, or Light Probes. Shadows don’t move when the lights move.    物体的阴影投射：是否生成阴影除了和光源相关还和对应MeshRenderer的设置相关。可以在Mesh Renderer的Lighting内设置。 Shadow MappingUnity实时阴影实现——Shadow...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Ming</div><div class="author-info-description">我们都在奔赴各自的人生，但你依旧是你</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ECS"><span class="toc-number">1.</span> <span class="toc-text">ECS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.2.</span> <span class="toc-text">准备工作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%8C%85"><span class="toc-number">1.2.1.</span> <span class="toc-text">常用包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WorkFlow-And-Basic"><span class="toc-number">1.3.</span> <span class="toc-text">WorkFlow And Basic</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Baking-Process"><span class="toc-number">1.3.1.</span> <span class="toc-text">Baking Process</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Structural-change"><span class="toc-number">1.3.2.</span> <span class="toc-text">Structural change</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Entity-And-Component-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.4.</span> <span class="toc-text">Entity And Component 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Entity"><span class="toc-number">1.5.</span> <span class="toc-text">Entity</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E5%9C%BA%E6%99%AFGO%E7%83%98%E5%9F%B9Entity"><span class="toc-number">1.5.1.</span> <span class="toc-text">子场景GO烘培Entity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%83%98%E5%9F%B9%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.2.</span> <span class="toc-text">烘培过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Component%E7%BB%84%E4%BB%B6"><span class="toc-number">1.6.</span> <span class="toc-text">Component组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80%E5%92%8C%E6%80%BB%E7%BB%93"><span class="toc-number">1.6.1.</span> <span class="toc-text">前言和总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6-%E9%9D%9E%E6%89%98%E7%AE%A1%E7%BB%84%E4%BB%B6-UnmanagedComponent"><span class="toc-number">1.6.2.</span> <span class="toc-text">基础组件 非托管组件 UnmanagedComponent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%98%E7%AE%A1%E7%BB%84%E4%BB%B6-ManagedComponent"><span class="toc-number">1.6.3.</span> <span class="toc-text">托管组件 ManagedComponent</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">内存分布</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tag-Component"><span class="toc-number">1.6.4.</span> <span class="toc-text">Tag Component</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DynamicBuffer-Component-%E5%8A%A8%E6%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E7%BB%84%E4%BB%B6"><span class="toc-number">1.6.5.</span> <span class="toc-text">DynamicBuffer Component 动态缓冲区组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DynamicBuffer"><span class="toc-number">1.6.5.1.</span> <span class="toc-text">DynamicBuffer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB"><span class="toc-number">1.6.6.</span> <span class="toc-text">层级关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%BF%80%E6%B4%BB%E7%BB%84%E4%BB%B6-IEnableableComponent"><span class="toc-number">1.6.7.</span> <span class="toc-text">可激活组件 IEnableableComponent</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.7.1.</span> <span class="toc-text">同步问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shared-Component"><span class="toc-number">1.6.8.</span> <span class="toc-text">Shared Component</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83-1"><span class="toc-number">1.6.8.1.</span> <span class="toc-text">内存分布</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chunk-Component"><span class="toc-number">1.6.9.</span> <span class="toc-text">Chunk Component</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Singleton-components"><span class="toc-number">1.6.10.</span> <span class="toc-text">Singleton components</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cleanup-Component"><span class="toc-number">1.6.11.</span> <span class="toc-text">Cleanup Component</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Native-Container"><span class="toc-number">1.6.12.</span> <span class="toc-text">Native Container</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Entity-Worlds-And-EntityManagers"><span class="toc-number">1.7.</span> <span class="toc-text">Entity Worlds And EntityManagers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%96%E7%95%8CWorld"><span class="toc-number">1.7.1.</span> <span class="toc-text">世界World</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EntityManager"><span class="toc-number">1.7.2.</span> <span class="toc-text">EntityManager</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">示例代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Archetypes-%E5%8E%9F%E5%9E%8B"><span class="toc-number">1.7.3.</span> <span class="toc-text">Archetypes 原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Chunks-%E5%AE%9E%E4%BD%93%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83"><span class="toc-number">1.7.4.</span> <span class="toc-text">Chunks 实体内存分布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Queries"><span class="toc-number">1.7.5.</span> <span class="toc-text">Queries</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#API"><span class="toc-number">1.7.5.1.</span> <span class="toc-text">API</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SystemAPI-Query"><span class="toc-number">1.7.5.1.1.</span> <span class="toc-text">SystemAPI.Query</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#EntityQuery"><span class="toc-number">1.7.5.1.2.</span> <span class="toc-text">EntityQuery</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IAspect-%E6%8A%BD%E8%B1%A1%E5%B0%81%E8%A3%85"><span class="toc-number">1.7.5.2.</span> <span class="toc-text">IAspect 抽象封装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ECB-EntityCommandBuffer"><span class="toc-number">1.7.6.</span> <span class="toc-text">ECB EntityCommandBuffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Entities-Meta-Data"><span class="toc-number">1.7.7.</span> <span class="toc-text">Entities Meta Data</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System"><span class="toc-number">1.8.</span> <span class="toc-text">System</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#System-Update"><span class="toc-number">1.8.1.</span> <span class="toc-text">System Update</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#System-Group"><span class="toc-number">1.8.2.</span> <span class="toc-text">System Group</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Time"><span class="toc-number">1.9.</span> <span class="toc-text">Time</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Jobs"><span class="toc-number">1.10.</span> <span class="toc-text">Jobs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IJobEntity%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.10.1.</span> <span class="toc-text">IJobEntity示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IJobChunk%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.10.2.</span> <span class="toc-text">IJobChunk示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E7%82%B9"><span class="toc-number">1.10.3.</span> <span class="toc-text">同步点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E8%AE%BF%E9%97%AE"><span class="toc-number">1.10.4.</span> <span class="toc-text">组件访问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ECS%E5%92%8CMono%E4%BA%A4%E4%BA%92"><span class="toc-number">1.11.</span> <span class="toc-text">ECS和Mono交互</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%98%E6%96%B9%E8%A7%86%E9%A2%91%E8%AE%B0%E5%BD%95"><span class="toc-number">2.</span> <span class="toc-text">官方视频记录</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/PostProcessing/" title="Unity PostProcessing">Unity PostProcessing</a><time datetime="2025-10-05T09:10:14.356Z" title="发表于 2025-10-05 17:10:14">2025-10-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/Shadow/" title="Unity Shadow">Unity Shadow</a><time datetime="2025-10-05T07:56:07.434Z" title="发表于 2025-10-05 15:56:07">2025-10-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/SRP/" title="Unity SRP">Unity SRP</a><time datetime="2025-10-02T06:15:27.265Z" title="发表于 2025-10-02 14:15:27">2025-10-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/AsyncOp/" title="Unity异步操作">Unity异步操作</a><time datetime="2025-09-14T08:01:59.349Z" title="发表于 2025-09-14 16:01:59">2025-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/Physics/" title="Unity Physics">Unity Physics</a><time datetime="2025-09-14T08:01:59.345Z" title="发表于 2025-09-14 16:01:59">2025-09-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/starBg2.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2025 By Ming</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23liMdTJDdBPikGC2F',
      clientSecret: 'eed0ab3cb8494f9e22f7a8bb469c58cc7e6fbaea',
      repo: 'BlogComment',
      owner: 'MikeMing126',
      admin: ['MikeMing126'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '807b201705e4475df77d4b828fc117c1'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script src="/script/APlayerHolder.js"></script><div class="aplayer" data-id="13402811242" data-server="netease" data-type="playlist" data-fixed="true" data-loop="all" data-autoplay="true" data-order="random" data-theme="#3F51B5"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>