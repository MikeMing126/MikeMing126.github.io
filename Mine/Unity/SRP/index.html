<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Unity SRP | Ming Blog</title><meta name="author" content="Ming"><meta name="copyright" content="Ming"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="官方Doc Rendering paths in UnityUnity URP&#x2F;SRP 渲染管线浅入深出【匠】【Unity】SRP简单入门【Unity】SRP底层渲染流程及原理Scriptable Render Pipeline可编程渲染管线 Render Pipeline基础  A series of operations that take the contents of a sce">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity SRP">
<meta property="og:url" content="https://mikeming126.github.io/Mine/Unity/SRP/index.html">
<meta property="og:site_name" content="Ming Blog">
<meta property="og:description" content="官方Doc Rendering paths in UnityUnity URP&#x2F;SRP 渲染管线浅入深出【匠】【Unity】SRP简单入门【Unity】SRP底层渲染流程及原理Scriptable Render Pipeline可编程渲染管线 Render Pipeline基础  A series of operations that take the contents of a sce">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mikeming126.github.io/img/head.png">
<meta property="article:published_time" content="2025-10-02T06:15:27.265Z">
<meta property="article:modified_time" content="2025-10-13T03:42:12.623Z">
<meta property="article:author" content="Ming">
<meta property="article:tag" content="Unity">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mikeming126.github.io/img/head.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Unity SRP",
  "url": "https://mikeming126.github.io/Mine/Unity/SRP/",
  "image": "https://mikeming126.github.io/img/head.png",
  "datePublished": "2025-10-02T06:15:27.265Z",
  "dateModified": "2025-10-13T03:42:12.623Z",
  "author": [
    {
      "@type": "Person",
      "name": "Ming",
      "url": "https://mikeming126.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://mikeming126.github.io/Mine/Unity/SRP/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":4,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Unity SRP',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/starBg2.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/starBg2.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Ming Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Unity SRP</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Unity SRP</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-02T06:15:27.265Z" title="发表于 2025-10-02 14:15:27">2025-10-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-13T03:42:12.623Z" title="更新于 2025-10-13 11:42:12">2025-10-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Unity/">Unity</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>9分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/6000.0/Documentation/Manual/rendering-paths-introduction.html">官方Doc Rendering paths in Unity</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/353687806">Unity URP&#x2F;SRP 渲染管线浅入深出【匠】</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/378828898">【Unity】SRP简单入门</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/378781638">【Unity】SRP底层渲染流程及原理</a><br>Scriptable Render Pipeline<br>可编程渲染管线</p>
<h1 id="Render-Pipeline基础"><a href="#Render-Pipeline基础" class="headerlink" title="Render Pipeline基础"></a>Render Pipeline基础</h1><blockquote>
<p> A series of operations that take the contents of a scene, and displays them on a screen</p>
</blockquote>
<p>在Unity的官方文档中定义为这么几个步骤：</p>
<ul>
<li>Culling （Frustum Culling视锥体剔除 Occlusion Culling遮挡剔除）</li>
<li>Rendering -&gt;To Pixel Buffers</li>
<li>Post Processing -&gt;Modify Pixel Buffers</li>
</ul>
<p>常用的</p>
<ul>
<li>Built-in Render Pipeline：</li>
<li>Universal Render Pipeline (URP)</li>
<li>High Definition Render Pipeline (HDRP)</li>
</ul>
<p>URP、HDRP和自定义渲染管线都属于SRP。</p>
<h2 id="Rendering-Paths"><a href="#Rendering-Paths" class="headerlink" title="Rendering Paths"></a>Rendering Paths</h2><blockquote>
<p> The series of operations that draws and lights GameObjects the camera sees. </p>
</blockquote>
<p>主要分为两种类型</p>
<ul>
<li>Forward Rendering</li>
<li>Deferred Rendering</li>
</ul>
<p>默认使用的是Forward。</p>
<h3 id="Forward-Rendering"><a href="#Forward-Rendering" class="headerlink" title="Forward Rendering"></a>Forward Rendering</h3><p>工作原理：</p>
<ul>
<li>Unity lights each GameObject in turn.</li>
<li>Lighting has limits, for example how often or how well Unity can light each GameObject. These limits are different for each render pipeline.</li>
</ul>
<p>URP中还有一个Forward+ rendering path.其类似于Forward Rendering,但对于每个游戏对象的光源没有限制。</p>
<h3 id="Deferred-Rendering"><a href="#Deferred-Rendering" class="headerlink" title="Deferred Rendering"></a>Deferred Rendering</h3><p>工作原理：</p>
<ul>
<li>Unity first creates a <strong>geometry buffer (G-buffer)</strong>, which is a set of <strong>textures</strong> that stores data about the geometry and materials the camera sees.</li>
<li>Unity uses the data from the G-buffer to <strong>light all the GameObjects at once</strong>.</li>
<li>There are fewer limits on lighting, so GameObjects and shadows are more detailed. For example, normal maps and cookies work with all lights.</li>
</ul>
<p><strong>延迟渲染无法渲染透明对象</strong>。因此，在渲染路径的末尾，Unity使用Forward Render Pass 来渲染透明对象</p>
<h1 id="SRP"><a href="#SRP" class="headerlink" title="SRP"></a>SRP</h1><blockquote>
<p>A thin API layer that lets you schedule and configure rendering commands using C# scripts</p>
</blockquote>
<p>两大关键自定义元素：</p>
<ul>
<li>A Render Pipeline Instance<ul>
<li>定义渲染管线功能的类的实例。继承自RenderPipeline，重写Render方法。</li>
</ul>
</li>
<li>A Render Pipeline Asset<ul>
<li>存储Render Pipeline Instance的配置和其所用到的数据的资源。继承自RenderPipelineAsset,重写CreatePipeline方法。</li>
</ul>
</li>
</ul>
<p>ScriptableRenderContext：</p>
<blockquote>
<p>A class that acts as an interface between the custom C# code in the render pipeline and Unity’s low-level graphics code.</p>
</blockquote>
<p>使用其API来调度和执行渲染命令。</p>
<h2 id="光照处理"><a href="#光照处理" class="headerlink" title="光照处理"></a>光照处理</h2><p>内置渲染管线中，会用多个Pass来处理多个动态光。每多一个动态光就会多一个Pass。所以一般都是采用烘培Lightmap的方式。</p>
<p>URP中，全部动态光放在一个Pass中渲染。但限制在于需要限制灯光的数量。</p>
<h2 id="SRP-Batcher"><a href="#SRP-Batcher" class="headerlink" title="SRP Batcher"></a>SRP Batcher</h2><img src="/Mine/Unity/SRP/SRPBatcher.png" class="" title="SRPBatcher">

<p>本质上并不会减少DrawCall,但是可以减少SetPass.<br>相较于DrawCall,SetPass的开销会更高。一个参考指标是SetPassCall不要超过150</p>
<p>要求和说明：</p>
<ul>
<li>支持Mesh、Skinned Mesh Renderer</li>
<li>不支持Particle</li>
<li>不支持Material Property Block。</li>
</ul>
<p>SRP中，材质球在显存中占用固定的CBuffer(Constant Buffer)。其分为了Per Object Large Buffer用于存储对象属性和Material CBuffer用于存储材质信息。仅当材质信息改变时，才需要对Material CBuffer进行更新处理。</p>
<ul>
<li>中断SetPass的条件由Material Break 变为 Shader Variant Break。</li>
<li>减少了CBuffer的相关操作。</li>
</ul>
<h2 id="SRP-编写基础"><a href="#SRP-编写基础" class="headerlink" title="SRP 编写基础"></a>SRP 编写基础</h2><ul>
<li>创建SRP类，继承自RenderPipeline。<ul>
<li>重写Render方法。</li>
</ul>
</li>
<li>创建SRPAsset类，继承自RenderPipelineAsset。<ul>
<li>重写CreatePipeline方法。</li>
</ul>
</li>
</ul>
<h3 id="ScriptableRenderContext"><a href="#ScriptableRenderContext" class="headerlink" title="ScriptableRenderContext"></a>ScriptableRenderContext</h3><p>使用ScriptableRenderContext来处理相关的渲染。<br>可以结合CommondBuffer一起。</p>
<h2 id="SRP底层渲染流程及原理"><a href="#SRP底层渲染流程及原理" class="headerlink" title="SRP底层渲染流程及原理"></a>SRP底层渲染流程及原理</h2><img src="/Mine/Unity/SRP/image.png" class="" title="alt text">

<ul>
<li>Scriptable Culling<ul>
<li>ScriptableRenderContext.Cull</li>
</ul>
</li>
<li>Scriptable Draw<ul>
<li>CommondBuffer.Blit</li>
<li>CommondBuffer.DrawMesh</li>
<li>ScriptableRenderContext.DrawRenderers</li>
<li>ScriptableRenderContext.DrawShadows</li>
<li>…</li>
</ul>
</li>
<li>Scriptable Render Loop<ul>
<li>ScriptableRenderContext.Submit</li>
</ul>
</li>
</ul>
<h3 id="Scriptable-Culling"><a href="#Scriptable-Culling" class="headerlink" title="Scriptable Culling"></a>Scriptable Culling</h3><ul>
<li>Culling Process</li>
<li>RenderNode&#x2F;RenderNodeQueue</li>
</ul>
<h4 id="Shadow-Culling"><a href="#Shadow-Culling" class="headerlink" title="Shadow Culling"></a>Shadow Culling</h4><p>为产生阴影的灯光 创建对应的CullingJob。<br>例如：Shadows.CullShadowCastersDirectional<br>关于这块，几个影响因素：</p>
<ul>
<li>灯光数量 Light Count</li>
<li>哪些灯光会产生阴影 Light.shadows</li>
<li>哪些物体会有阴影（Cast Shadow）(Renderer.shadowCastingMode)</li>
</ul>
<h4 id="Dynamic-Objects-Culling"><a href="#Dynamic-Objects-Culling" class="headerlink" title="Dynamic Objects Culling"></a>Dynamic Objects Culling</h4><p>裁剪场景中的动态物体</p>
<ul>
<li>CullSceneDynamicObjects</li>
<li>IndexList (Unity维护场景中所有Renderer列表，而IndexList存着当前所有可见的Renderer的数组下标。但IndexList本身和Renderer列表登长 )</li>
</ul>
<img src="/Mine/Unity/SRP/image-1.png" class="" title="alt text">

<p>优势：</p>
<ul>
<li>每个CullJob可以分线程执行</li>
</ul>
<p>在CullJob完成后，会有Combine操作使其连续</p>
<h4 id="Extrat-RenderNode-Queue"><a href="#Extrat-RenderNode-Queue" class="headerlink" title="Extrat RenderNode Queue"></a>Extrat RenderNode Queue</h4><p>从内存角度，Renderer在内存中分布是杂乱的。因此在进行顺序读取时效率并不会很高。</p>
<p>为了连续，引入RenderNode。<br>RenderNode：Renderer对象的扁平化(Flatten)版本，将Renderer内数据展开变为一个大的Struct。</p>
<p>多个Node构成Queue。</p>
<ul>
<li>线程安全</li>
<li>Used by the rendering jobs to render the scene</li>
</ul>
<p>ExtraRenderNodeQueue：<br>遍历可见Renderer对象，并将数据拷贝到RenderNode的过程，然后组成RenderNodeQueue。</p>
<p>开销和场景内可见Renderer数量正相关</p>
<h3 id="Scriptable-Draw"><a href="#Scriptable-Draw" class="headerlink" title="Scriptable Draw"></a>Scriptable Draw</h3><ul>
<li>ScriptableRenderContext.ExecuteCommandBuffer</li>
<li>ScriptableRenderContext.DrawRenderers</li>
</ul>
<h4 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h4><p>引擎内部有4个Command存储</p>
<ul>
<li>dynamic_array&lt;ShadowDrawingSettings&gt; m_DrawShadowsCommands;</li>
<li>dynamic_array&lt;DrawRenderersCommand&gt; m_DrawRenderersCommands;</li>
<li>dynamic_array&lt;RenderingCommandBuffer*&gt; m_CommandBuffers;</li>
<li>dynamic_array&lt;Command&gt; m_Commands;</li>
</ul>
<p>以 DrawRenderersCommand为例子：<br>在调用产生DrawRenderersCommand的同时，也会产生一个Command放到m_Commands中</p>
<img src="/Mine/Unity/SRP/image-2.png" class="" title="alt text">

<p>实际上在调用context.DrawRenderers、context.DrawShadows、context.ExecuteCommandBuffer时，都不是立即执行的，而是生成对应的Command，存到队列中。在Submit才会执行。</p>
<h3 id="Submit"><a href="#Submit" class="headerlink" title="Submit"></a>Submit</h3><ul>
<li>PrepareDrawRenderersCommand</li>
<li>Execute commands</li>
</ul>
<h4 id="PrepareDrawRenderersCommand"><a href="#PrepareDrawRenderersCommand" class="headerlink" title="PrepareDrawRenderersCommand"></a>PrepareDrawRenderersCommand</h4><img src="/Mine/Unity/SRP/image-3.png" class="" title="alt text">

<p>问题：</p>
<ul>
<li>One renderer has more than one material</li>
<li>One material has more than one pass</li>
<li>Sort （决定哪些先画的问题）</li>
</ul>
<p>遍历每个renderNode,找到每个material。<br>遍历每个material，找到所有pass。每个pass生成一个ScriptableLoopObjectData。<br>然后对ScriptableLoopObjectData进行排序。确定渲染数据。</p>
<h4 id="ScriptableRenderLoop"><a href="#ScriptableRenderLoop" class="headerlink" title="ScriptableRenderLoop"></a>ScriptableRenderLoop</h4><img src="/Mine/Unity/SRP/image-4.png" class="" title="alt text">
<p>遍历Commands，依据类型获取数据，执行对应的逻辑。</p>
<p>ScriptableLoopObjectData中包含标识标识是否为SRP兼容，图中橙色为兼容，紫色为不兼容。</p>
<img src="/Mine/Unity/SRP/image-5.png" class="" title="alt text">
<p>依据兼容与否，走SRP batcher或普通的Draw。</p>
<h3 id="SRP-Batcher-1"><a href="#SRP-Batcher-1" class="headerlink" title="SRP Batcher"></a>SRP Batcher</h3><img src="/Mine/Unity/SRP/SRPBatcher.png" class="" title="SRPBatcher">
<p>对应流程:</p>
<img src="/Mine/Unity/SRP/image-6.png" class="" title="alt text">

<img src="/Mine/Unity/SRP/image-7.png" class="" title="alt text">
<p>因此可在Profile中看到多次ApplyShader和SRPBatcher.Flush。</p>
<p>传统的优化方案依旧适用于SRPBatcher，重点是让能Batch在一起的，尽可能在Sort的时候排在一起。</p>
<p>打断合批的原因</p>
<ul>
<li>kSRPBatchBreakDifferentShader</li>
<li>kSRPBatchBreakCauseMultiPassShader</li>
<li>kSRPBatchBreakKeywordsChange</li>
<li>kSRPBatchEndOfBatchFlush</li>
<li>kSRPBatchNotCompatibleNode</li>
<li>kSRPBatchMaterialNeedDeviceStateChange</li>
<li>kSRPBatchFirstCall</li>
<li>kSRPBatchMaterialBufferOverride</li>
</ul>
<p>使用FrameDebugger来查看并优化。</p>
<h4 id="buffer填充数据"><a href="#buffer填充数据" class="headerlink" title="buffer填充数据"></a>buffer填充数据</h4><p>PerObjectBuffer</p>
<img src="/Mine/Unity/SRP/image-8.png" class="" title="alt text">

<p>Shader有对应的Feature才会填充。<br>填充数据少则一次合批的数量可以更多。</p>
<p>在填充完PerObjectData后，组成一个大的CBuffer统一传到GPU</p>
<h1 id="Shader-And-Material"><a href="#Shader-And-Material" class="headerlink" title="Shader And Material"></a>Shader And Material</h1><p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/6000.2/Documentation/Manual/materials-and-shaders.html">UnityDoc Materials and shaders</a></p>
<blockquote>
<p>碎碎念：Unity竟然把Material的介绍放到Shader前面……</p>
</blockquote>
<h2 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h2><blockquote>
<p>A program that runs on a GPU</p>
</blockquote>
<p>Unity中将着色器分为三类：</p>
<ul>
<li>Part of the Graphics pipeline。用于计算像素的颜色。一般使用Shader objects。</li>
<li>Compute shaders在GPU的常规图形管线外执行计算。</li>
<li>Ray tracing处理光线追踪</li>
</ul>
<h3 id="SubShader-and-Pass"><a href="#SubShader-and-Pass" class="headerlink" title="SubShader and Pass"></a>SubShader and Pass</h3><h4 id="SubShader"><a href="#SubShader" class="headerlink" title="SubShader"></a>SubShader</h4><p>SubShader - 依据硬件条件确定执行的SubShader。只会有一个SubShader执行。Unity会按顺序尝试每一个SubShader，使用第一个能够在当前平台运行的。</p>
<p>可以为高低端GPU提供不同的实现。<br>可以为不同的渲染管线(前向&#x2F;延迟)提供不同的实现</p>
<h4 id="Pass"><a href="#Pass" class="headerlink" title="Pass"></a>Pass</h4><p>Pass - 每一个Pass都是一个渲染流程，用于实现不同的渲染效果。多Pass意味着多次从顶点处理、光栅化到像素处理的全过程。<br>多个Pass的混合通过帧缓冲区来处理。具体的机制取决于渲染状态的设置。如覆盖、透明度混合、加法混合。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 没有设置混合模式，默认是：Blend One Zero</span></span><br><span class="line">    <span class="comment">// 意味着：当前颜色 × 1 + 缓冲区颜色 × 0 = 完全覆盖</span></span><br><span class="line">&#125;</span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    Blend SrcAlpha OneMinusSrcAlpha <span class="comment">// 传统透明度混合</span></span><br><span class="line">    <span class="comment">// 当前颜色 × SrcAlpha + 缓冲区颜色 × (1 - SrcAlpha)</span></span><br><span class="line">&#125;</span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    Blend One One <span class="comment">// 加法混合</span></span><br><span class="line">    <span class="comment">// 当前颜色 × 1 + 缓冲区颜色 × 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Shader-Variant"><a href="#Shader-Variant" class="headerlink" title="Shader Variant"></a>Shader Variant</h3><p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/6000.2/Documentation/Manual/shader-variants.html">UnityDoc Reducing shader variants</a><br><a target="_blank" rel="noopener" href="https://developer.unity.cn/projects/67160447edbc2a9ccb33996c">Unity Shader 变体指南</a></p>
<blockquote>
<p>Shader variants(shader permutations) —— one way of introducing conditional behavior into shader code</p>
</blockquote>
<p>主要还是用于Shader代码中的条件处理。<br>Unity在对Shader源文件编译成Shader程序时，依据关键字，将生成一至多个Shader变体(依赖于不同的条件。每个都是独立的文件)。本质上是一种静态分支形式。</p>
<p>关键字:</p>
<ul>
<li>#pragma multi_compile<ul>
<li>会为所有关键字组合生成对应的着色器变体。</li>
<li>可能会有很长的编译时间。因为组合数量可能很恐怖</li>
<li>使用shader_feature或剥离着色器变体来优化。</li>
</ul>
</li>
<li>#pragma shader_feature<ul>
<li>仅需要着色器依据材质属性时。Unity会依据Build中的材质去生成对应的变体，不会生成多余的变体。</li>
<li>可以缩短构建时间并减少文件大小。</li>
<li>不太适合用于C#脚本。在运行时如果使用不在Build内的变体，Unity会尝试用与其最相似的一个来处理逻辑。</li>
</ul>
</li>
</ul>
<p>附：</p>
<ul>
<li>动态分支，关键字为#pragma dynamic_branch 则不会生成多个变体文件，但是会影响GPU的性能。</li>
</ul>
<p>优缺点：</p>
<ul>
<li>缺点<ul>
<li>大量着色器导致更长的构建时间</li>
<li>内存占用问题和着色器编译卡顿</li>
</ul>
</li>
<li>优点<ul>
<li>在不影响GPU性能的情况下，实现条件分支</li>
</ul>
</li>
</ul>
<h4 id="变体加载流程"><a href="#变体加载流程" class="headerlink" title="变体加载流程"></a>变体加载流程</h4><p>关于预编译相关的逻辑：<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/300ba79057c5">【Unity Shader】加载时机和预编译</a></p>
<p>这里其实是有两种情况的：</p>
<ol>
<li>着色器变种已经打包到APP中，只需要加载该变体，创建GPUProgram</li>
<li>着色器变种没用被打包，这时需要shaderlab文件进行解析和编译相应的变种，然后创建GPUProgram</li>
</ol>
<p>通过材质确定需要加载的着色器变体。从项目资源中加载所需的着色器。</p>
<p>如果该变体已经存在于内存中，Unity会直接使用它。</p>
<p>否则:</p>
<ul>
<li>若着色器已经在资源中（例如，在AB中或Resources文件夹中），Unity会从这些资源中加载着色器。如果之前已经编译了该着色器变体（例如，通过Shader Variant Collection），Unity会直接使用预编译的代码。预编译可以大大减少运行时编译的开销。（对应情况1） </li>
<li>否则进行动态编译（对应情况2）。<ol>
<li>解析着色器代码：读取HLSL代码和着色器的配置。</li>
<li>应用关键字和设置：根据材质的设置和启用的关键字，应用相应的变体配置。</li>
<li>生成GPU代码：将处理后的HLSL代码转换为GPU能够理解和执行的代码。</li>
</ol>
</li>
</ul>
<p>这里也要留意，加载变体本身也是有对应开销的。也有预加载对应的逻辑。</p>
<h4 id="Strip-Shader-Variants"><a href="#Strip-Shader-Variants" class="headerlink" title="Strip Shader Variants"></a>Strip Shader Variants</h4><p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/6000.2/Documentation/Manual/shader-variant-stripping.html">UnityDoc Strip shader variants</a></p>
<p>基础的思想还是尽可能的使用shader_feature而不是multi_compile。</p>
<p>或者使用关键字来限制对应的应用阶段。</p>
<p>使用SVC(Shader Variant Collection)来优化变体。</p>
<h2 id="Material"><a href="#Material" class="headerlink" title="Material"></a>Material</h2><blockquote>
<p>To describe the appearance of surfaces</p>
</blockquote>
<p>Shader和对应的材质属性属性</p>
<h3 id="Material-Variant"><a href="#Material-Variant" class="headerlink" title="Material Variant"></a>Material Variant</h3><p>似于复制材质。</p>
<ul>
<li>父材质改变时，自动改变</li>
<li>支持一些操作（如子材质改变同步到父材质、父材质设置部分属性锁定,使得子材质无法修改）</li>
<li>支持重新设置父材质</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://MikeMing126.github.io">Ming</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mikeming126.github.io/Mine/Unity/SRP/">https://mikeming126.github.io/Mine/Unity/SRP/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://MikeMing126.github.io" target="_blank">Ming Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Unity/">Unity</a></div><div class="post-share"><div class="social-share" data-image="/img/head.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/Mine/Unity/AsyncOp/" title="Unity异步操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Unity异步操作</div></div><div class="info-2"><div class="info-item-1">异步操作可以参考这篇文章Unity入门教程之异步篇第二节：协程 or UniTask？Unity 中异步流程到底怎么选Unity异步扩展实践（一）——以UniTask库为参考 关于临界资源问题Unity入门教程之异步篇第三节：多线程初探？理解并发与线程安全 协程 - 逻辑异步 - 单线程协程这块较为通用可以另外参考之前记录。 UniTask本质上是利用C#的Task。但是使用原生的async&#x2F;await和Task存在一些问题：  GC和性能开销(Task本身是引用类型，且async&#x2F;await产生状态机对象和闭包) 线程切换不一定对。且Unity大部分API只能在主线程使用。 任务的生命周期管理问题:任务不会因为对象被销毁而自动停止 平台多线程限制（如WebGL）  因此有UniTaskGitHub优势和注意事项：  零GC 主线程调度。默认完全在Unity的PlayerLoop上运行，因此不使用Thread。在 .NET 实现中，执行 await 语句之前和之后代码的线程是有可能不同的。虽然有线程切换，但我们不需要关心其中的细节，.NET...</div></div></div></a><a class="pagination-related" href="/Mine/Unity/Shadow/" title="Unity Shadow"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Unity Shadow</div></div><div class="info-2"><div class="info-item-1">阴影Shadow 光源可以产生两种阴影：  Real-time Shadows 实时阴影 Unity stores the shadows cast from each Light in shadow map textures. The textures update each frame; shadows move when the lights move.   Baked Shadows 烘培阴影 The Unity lightmapper stores the shadows received by each GameObject in static lightmap textures, shadow mask textures, or Light Probes. Shadows don’t move when the lights move.    物体的阴影投射：是否生成阴影除了和光源相关还和对应MeshRenderer的设置相关。可以在Mesh Renderer的Lighting内设置。 Shadow MappingUnity实时阴影实现——Shadow...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/Mine/Unity/AsyncOp/" title="Unity异步操作"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-14</div><div class="info-item-2">Unity异步操作</div></div><div class="info-2"><div class="info-item-1">异步操作可以参考这篇文章Unity入门教程之异步篇第二节：协程 or UniTask？Unity 中异步流程到底怎么选Unity异步扩展实践（一）——以UniTask库为参考 关于临界资源问题Unity入门教程之异步篇第三节：多线程初探？理解并发与线程安全 协程 - 逻辑异步 - 单线程协程这块较为通用可以另外参考之前记录。 UniTask本质上是利用C#的Task。但是使用原生的async&#x2F;await和Task存在一些问题：  GC和性能开销(Task本身是引用类型，且async&#x2F;await产生状态机对象和闭包) 线程切换不一定对。且Unity大部分API只能在主线程使用。 任务的生命周期管理问题:任务不会因为对象被销毁而自动停止 平台多线程限制（如WebGL）  因此有UniTaskGitHub优势和注意事项：  零GC 主线程调度。默认完全在Unity的PlayerLoop上运行，因此不使用Thread。在 .NET 实现中，执行 await 语句之前和之后代码的线程是有可能不同的。虽然有线程切换，但我们不需要关心其中的细节，.NET...</div></div></div></a><a class="pagination-related" href="/Mine/Unity/Animation/" title="Unity Animation"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-14</div><div class="info-item-2">Unity Animation</div></div><div class="info-2"><div class="info-item-1">Mecanim 动画系统Mecanim Animation SystemUnity6 动画系统 作用 Animate the properties of models and assets.  基础概念基于Animation Clips的概念。 Animation Clip包含对象随着事件如何改变位置、旋转或其他属性的相关信息。 外部导入或者Unity内部创建。Clip相关功能：  Transform信息 组件属性 Scripts中的属性 特定时间调用函数  Animation Event 仅支持单个参数的函数  用AnimationEvent Object来传递多个参数：支持一个int,一个float,一个string,一个GameObject引用。 Humanoid Avatar The rigged character model,has a specific configuration of bones mapped to Unity’s Avatar format.  为人形专门设定。Importing a model with humanoid...</div></div></div></a><a class="pagination-related" href="/Mine/Unity/PostProcessing/" title="Unity PostProcessing"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-05</div><div class="info-item-2">Unity PostProcessing</div></div><div class="info-2"><div class="info-item-1">Introduction to post-processingUnity 后处理 在渲染管线之后，FrameBuffer上处理。后处理和全屏效果。 效果参考和支持Post-processing effect availability reference </div></div></div></a><a class="pagination-related" href="/Mine/Unity/Physics/" title="Unity Physics"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-14</div><div class="info-item-2">Unity Physics</div></div><div class="info-2"><div class="info-item-1">物理 基础Unity物理系统由浅入深第一节：Unity 物理系统基础与应用 RigidBody 刚体 - 赋予物理属性 Collider 碰撞体 - 碰撞形状 Physic Material 物理材质 - 定义交互特性定义碰撞体之间的摩檫力和弹性。分配给Collider。 碰撞事件  Collision Callbacks 适用于两个非触发器（至少一个带RigidBody）之间的物理碰撞 Trigger Callbacks 至少一个Collider为Is Trigger的情况下，检测到物体进入&#x2F;离开&#x2F;停留在区域内 只有当碰撞中一个Collider附加了Rigidbody或者其为KinematicRigidbody上的Colider时，才能触发对应的回调。(对于KinematicRigidbody，不会触发CollisionCallback，需要用TriggerCallback)  射线检测 Raycast形状检测 Shape...</div></div></div></a><a class="pagination-related" href="/Mine/Unity/Shadow/" title="Unity Shadow"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-05</div><div class="info-item-2">Unity Shadow</div></div><div class="info-2"><div class="info-item-1">阴影Shadow 光源可以产生两种阴影：  Real-time Shadows 实时阴影 Unity stores the shadows cast from each Light in shadow map textures. The textures update each frame; shadows move when the lights move.   Baked Shadows 烘培阴影 The Unity lightmapper stores the shadows received by each GameObject in static lightmap textures, shadow mask textures, or Light Probes. Shadows don’t move when the lights move.    物体的阴影投射：是否生成阴影除了和光源相关还和对应MeshRenderer的设置相关。可以在Mesh Renderer的Lighting内设置。 Shadow MappingUnity实时阴影实现——Shadow...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Ming</div><div class="author-info-description">我们都在奔赴各自的人生，但你依旧是你</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Render-Pipeline%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">Render Pipeline基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Rendering-Paths"><span class="toc-number">1.1.</span> <span class="toc-text">Rendering Paths</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Forward-Rendering"><span class="toc-number">1.1.1.</span> <span class="toc-text">Forward Rendering</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deferred-Rendering"><span class="toc-number">1.1.2.</span> <span class="toc-text">Deferred Rendering</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SRP"><span class="toc-number">2.</span> <span class="toc-text">SRP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%89%E7%85%A7%E5%A4%84%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">光照处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SRP-Batcher"><span class="toc-number">2.2.</span> <span class="toc-text">SRP Batcher</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SRP-%E7%BC%96%E5%86%99%E5%9F%BA%E7%A1%80"><span class="toc-number">2.3.</span> <span class="toc-text">SRP 编写基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ScriptableRenderContext"><span class="toc-number">2.3.1.</span> <span class="toc-text">ScriptableRenderContext</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SRP%E5%BA%95%E5%B1%82%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="toc-number">2.4.</span> <span class="toc-text">SRP底层渲染流程及原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Scriptable-Culling"><span class="toc-number">2.4.1.</span> <span class="toc-text">Scriptable Culling</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Shadow-Culling"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">Shadow Culling</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dynamic-Objects-Culling"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">Dynamic Objects Culling</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Extrat-RenderNode-Queue"><span class="toc-number">2.4.1.3.</span> <span class="toc-text">Extrat RenderNode Queue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scriptable-Draw"><span class="toc-number">2.4.2.</span> <span class="toc-text">Scriptable Draw</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Commands"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">Commands</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Submit"><span class="toc-number">2.4.3.</span> <span class="toc-text">Submit</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PrepareDrawRenderersCommand"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">PrepareDrawRenderersCommand</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ScriptableRenderLoop"><span class="toc-number">2.4.3.2.</span> <span class="toc-text">ScriptableRenderLoop</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SRP-Batcher-1"><span class="toc-number">2.4.4.</span> <span class="toc-text">SRP Batcher</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#buffer%E5%A1%AB%E5%85%85%E6%95%B0%E6%8D%AE"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">buffer填充数据</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Shader-And-Material"><span class="toc-number">3.</span> <span class="toc-text">Shader And Material</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Shader"><span class="toc-number">3.1.</span> <span class="toc-text">Shader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SubShader-and-Pass"><span class="toc-number">3.1.1.</span> <span class="toc-text">SubShader and Pass</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SubShader"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">SubShader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pass"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">Pass</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shader-Variant"><span class="toc-number">3.1.2.</span> <span class="toc-text">Shader Variant</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E4%BD%93%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">变体加载流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Strip-Shader-Variants"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">Strip Shader Variants</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Material"><span class="toc-number">3.2.</span> <span class="toc-text">Material</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Material-Variant"><span class="toc-number">3.2.1.</span> <span class="toc-text">Material Variant</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/PostProcessing/" title="Unity PostProcessing">Unity PostProcessing</a><time datetime="2025-10-05T09:10:14.356Z" title="发表于 2025-10-05 17:10:14">2025-10-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/Shadow/" title="Unity Shadow">Unity Shadow</a><time datetime="2025-10-05T07:56:07.434Z" title="发表于 2025-10-05 15:56:07">2025-10-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/SRP/" title="Unity SRP">Unity SRP</a><time datetime="2025-10-02T06:15:27.265Z" title="发表于 2025-10-02 14:15:27">2025-10-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/AsyncOp/" title="Unity异步操作">Unity异步操作</a><time datetime="2025-09-14T08:01:59.349Z" title="发表于 2025-09-14 16:01:59">2025-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/Physics/" title="Unity Physics">Unity Physics</a><time datetime="2025-09-14T08:01:59.345Z" title="发表于 2025-09-14 16:01:59">2025-09-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/starBg2.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2025 By Ming</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23liMdTJDdBPikGC2F',
      clientSecret: 'eed0ab3cb8494f9e22f7a8bb469c58cc7e6fbaea',
      repo: 'BlogComment',
      owner: 'MikeMing126',
      admin: ['MikeMing126'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '79e3302e68db9e35ae086c44c948d613'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script src="/script/APlayerHolder.js"></script><div class="aplayer" data-id="13402811242" data-server="netease" data-type="playlist" data-fixed="true" data-loop="all" data-autoplay="true" data-order="random" data-theme="#3F51B5"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>