<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>UE5.5-GameplayPrediction | Ming Blog</title><meta name="author" content="Ming"><meta name="copyright" content="Ming"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="SourceCode源码Overview of Gameplay Ability PredictionHigh Level Goals At the GameplayAbility level (implementing an ability) prediction is transparent. An ability says “Do X-&gt;Y-&gt;Z”, and we will au">
<meta property="og:type" content="article">
<meta property="og:title" content="UE5.5-GameplayPrediction">
<meta property="og:url" content="https://mikeming126.github.io/UE/GAS/UE55GamplayPrediction/index.html">
<meta property="og:site_name" content="Ming Blog">
<meta property="og:description" content="SourceCode源码Overview of Gameplay Ability PredictionHigh Level Goals At the GameplayAbility level (implementing an ability) prediction is transparent. An ability says “Do X-&gt;Y-&gt;Z”, and we will au">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mikeming126.github.io/img/head.png">
<meta property="article:published_time" content="2025-03-05T14:56:19.218Z">
<meta property="article:modified_time" content="2025-03-05T15:14:51.999Z">
<meta property="article:author" content="Ming">
<meta property="article:tag" content="UE">
<meta property="article:tag" content="GAS">
<meta property="article:tag" content="UE Source">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mikeming126.github.io/img/head.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "UE5.5-GameplayPrediction",
  "url": "https://mikeming126.github.io/UE/GAS/UE55GamplayPrediction/",
  "image": "https://mikeming126.github.io/img/head.png",
  "datePublished": "2025-03-05T14:56:19.218Z",
  "dateModified": "2025-03-05T15:14:51.999Z",
  "author": [
    {
      "@type": "Person",
      "name": "Ming",
      "url": "https://mikeming126.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://mikeming126.github.io/UE/GAS/UE55GamplayPrediction/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":4,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'UE5.5-GameplayPrediction',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/starBg2.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/starBg2.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Ming Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">UE5.5-GameplayPrediction</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">UE5.5-GameplayPrediction</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-05T14:56:19.218Z" title="发表于 2025-03-05 22:56:19">2025-03-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-05T15:14:51.999Z" title="更新于 2025-03-05 23:14:51">2025-03-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/UE-Source/">UE Source</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>19分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="SourceCode源码"><a href="#SourceCode源码" class="headerlink" title="SourceCode源码"></a><a target="_blank" rel="noopener" href="https://github.com/MikeMing126/UESourceCode/blob/main/UE55_GAS_GameplayPrediction.h">SourceCode源码</a></h1><h1 id="Overview-of-Gameplay-Ability-Prediction"><a href="#Overview-of-Gameplay-Ability-Prediction" class="headerlink" title="Overview of Gameplay Ability Prediction"></a>Overview of Gameplay Ability Prediction</h1><h2 id="High-Level-Goals"><a href="#High-Level-Goals" class="headerlink" title="High Level Goals"></a>High Level Goals</h2><ul>
<li>At the GameplayAbility level (implementing an ability) prediction is transparent. An ability says “Do X-&gt;Y-&gt;Z”, and we will automatically predict the parts of that that we can.</li>
<li>We wish to avoid having logic such as “If Authority: Do X. Else: Do predictive version of X” in the ability itself.</li>
</ul>
<p>At this point, not all cases are solved, but we have a very solid framework for working with client side prediction.</p>
<p>When we say “client side prediction” we really mean client predicting game simulation state. Things can still be ‘completely client side’ without having to work within a prediction system.<br>For example, footsteps are completely client side and never interact with this system. But clients predicting their mana going from 100 to 90 when they cast a spell is ‘client side prediction’.</p>
<h2 id="What-do-we-currently-predict"><a href="#What-do-we-currently-predict" class="headerlink" title="What do we currently predict?"></a>What do we currently predict?</h2><ul>
<li>Initial GameplayAbility activation (and chained activation with caveats)</li>
<li>Triggered Events</li>
<li>GameplayEffect application:<ul>
<li>Attribute modification (EXCEPTIONS: Executions do not currently predict, only attribute modifiers)</li>
<li>GameplayTag modification</li>
</ul>
</li>
<li>Gameplay Cue events (both from within predictive gameplay effect and on their own)</li>
<li>Montages</li>
<li>Movement (built into UE UCharacterMovement)</li>
</ul>
<h2 id="Some-things-we-don’t-predict-most-of-these-we-potentially-could-but-currently-dont"><a href="#Some-things-we-don’t-predict-most-of-these-we-potentially-could-but-currently-dont" class="headerlink" title="Some things we don’t predict (most of these we potentially could, but currently dont):"></a>Some things we don’t predict (most of these we potentially could, but currently dont):</h2><ul>
<li>GameplayEffect removal</li>
<li>GameplayEffect periodic effects (dots ticking)</li>
</ul>
<h2 id="Problems-we-attempt-to-solve"><a href="#Problems-we-attempt-to-solve" class="headerlink" title="Problems we attempt to solve"></a>Problems we attempt to solve</h2><ol>
<li>“Can I do this?” Basic protocol for prediction.</li>
<li>“Undo” How to undo side effects when a prediction fails.</li>
<li>“Redo” How to avoid replaying side effects that we predicted locally but that also get replicated from the server.</li>
<li>“Completeness” How to be sure we &#x2F;really&#x2F; predicted all side effects.</li>
<li>“Dependencies” How to manage dependent prediction and chains of predicted events.</li>
<li>“Override” How to override state predictively that is otherwise replicated&#x2F;owned by the server.</li>
</ol>
<hr>
<h2 id="Implementation-Details"><a href="#Implementation-Details" class="headerlink" title="Implementation Details"></a>Implementation Details</h2><h3 id="​​-PredictionKey-​"><a href="#​​-PredictionKey-​" class="headerlink" title="​​ PredictionKey ​"></a>​<em><strong>​ PredictionKey ​</strong></em></h3><p>A fundamental concept in this system is the <code>FPredictionKey</code>. A prediction key on its own is simply a unique ID that is generated in a central place on the client. The client will send its prediction key to the server,<br>and associate predictive actions and side effects with this key. The server may respond with an accept&#x2F;reject for the prediction key, and will also associate the server-side created side effects with this prediction key.</p>
<p>(IMPORTANT) <code>FPredictionKey</code> always replicates client -&gt; server, but when replicating server -&gt; clients they <em>only</em> replicate to the client that sent the prediction key to the server in the first place.<br>This happens in <code>FPredictionKey::NetSerialize</code>. All other clients will receive an invalid (0) prediction key when a prediction key sent from a client is replicated back down through a replicated property.</p>
<hr>
<h3 id="​​-Ability-Activation-​"><a href="#​​-Ability-Activation-​" class="headerlink" title="​​ Ability Activation ​"></a>​<em><strong>​ Ability Activation ​</strong></em></h3><p>Ability Activation is a first class predictive action – it generates an initial prediction key. Whenever a client predictively activates an ability, it explicitly asks the server and the server explicitly responds. Once an ability has been<br>predictively activated (but the request has not yet been sent), the client has a valid ‘prediction window’ where predictive side effects can happen which are not explicitly ‘asked about’. (E.g., we do not explicitly ask ‘Can I decrement mana, Can I put this ability on cooldown. Those actions are considered logically atomic with activating an ability). You can think of this prediction window as being the initial callstack of <code>ActivateAbility</code>. Once <code>ActivateAbility</code> ends, your<br>prediction window (and therefore your prediction key) is no longer valid. This is important, because many things can invalidate your prediction window such as any timers or latent nodes in your Blueprint; we do not predict over multiple frames.</p>
<p><strong>AbilitySystemComponent</strong>​ provides a set of functions for communicating ability activation between clients and server: <code>TryActivateAbility</code> -&gt; <code>ServerTryActivateAbility</code> -&gt; <code>ClientActivateAbility(Failed/Succeed)</code>.</p>
<ol>
<li>Client calls <code>TryActivateAbility</code> which generates a new <code>FPredictionKey</code> and calls <code>ServerTryActivateAbility</code>.</li>
<li>Client continues (before hearing back from server) and calls <code>ActivateAbility</code> with the generated <code>PredictionKey</code> associated with the Ability’s <code>ActivationInfo</code>.</li>
<li>Any side effects that happen &#x2F;before the call to <code>ActivateAbility</code> finish&#x2F; have the generated <code>FPredictionKey</code> associated with them.</li>
<li>Server decides if the ability really happened in <code>ServerTryActivateAbility</code>, calls <code>ClientActivateAbility(Failed/Succeed)</code> and sets <code>UAbilitySystemComponent::ReplicatedPredictionKey</code> to the generated key that was sent with the request by the client.</li>
<li>If client receives <code>ClientAbilityFailed</code>, it immediately kills the ability and rolls back side effects that were associated with the prediction key.<ul>
<li>‘Rolling back’ logic is registered via <code>FPredictionKeyDelegates</code> and <code>FPredictionKey::NewRejectedDelegate/NewCaughtUpDelegate/NewRejectOrCaughtUpDelegate</code>.</li>
<li><code>ClientAbilityFailed</code> is really the only case where we ‘reject’ prediction keys and thus all of our current predictions rely on if an ability activates or not.</li>
</ul>
</li>
<li>If <code>ServerTryActivateAbility</code> succeeds, client must wait until property replication catches up (the Succeed RPC will be sent immediately, property replication will happen on its own). Once the <code>ReplicatedPredictionKey</code> catches up to the<br>key used previous steps, the client can undo its predictive side effects.<ul>
<li>See <code>FReplicatedPredictionKeyItem::OnRep</code> for the CatchUpTo logic. See <code>UAbilitySystemComponent::ReplicatedPredictionKeyMap</code> for how the keys actually get replicated. See ~&#96;FScopedPredictionWindow&#96; where the server acknowledges keys.</li>
</ul>
</li>
</ol>
<hr>
<h3 id="​​-GameplayEffect-Prediction-​"><a href="#​​-GameplayEffect-Prediction-​" class="headerlink" title="​​ GameplayEffect Prediction ​"></a>​<em><strong>​ GameplayEffect Prediction ​</strong></em></h3><p>GameplayEffects are considered side effects of ability activation and are not separately accepted&#x2F;rejected.</p>
<ol>
<li>GameplayEffects are only applied on clients if there is a valid prediction key. (If no prediction key, it simply skips the application on client).</li>
<li>Attributes, GameplayCues, and GameplayTags are all predicted if the GameplayEffect is predicted.</li>
<li>When the <code>FActiveGameplayEffect</code> is created, it stores the prediction key (<code>FActiveGameplayEffect::PredictionKey</code>)<ul>
<li>Instant effects are explained below in “Attribute Prediction”.</li>
</ul>
</li>
<li>On the server, the same prediction key is also set on the server’s <code>FActiveGameplayEffect</code> that will be replicated down.</li>
<li>As a client, if you get a replicated <code>FActiveGameplayEffect</code> with a valid prediction key on it, you check to see if you have an <code>ActiveGameplayEffect</code> with that same key, if there is match, we do not apply<br>the ‘on applied’ type of logic, e.g., GameplayCues. The solves the “Redo” problem. However we will have 2 of the ‘same’ GameplayEffects in our ActiveGameplayEffects container, temporarily:</li>
<li>At the same time, <code>FReplicatedPredictionKeyItem::OnRep</code> will catch up and the predictive effects will be removed. When they are removed in this case, we again check <code>PredictionKey</code> and decide<br>if we should not do the ‘On Remove’ logic &#x2F; GameplayCue.</li>
</ol>
<p>See <code>FActiveGameplayEffectsContainer::ApplyGameplayEffectSpec</code> where it registers what to do when caught-up (RemoveActiveGameplayEffect_NoReturn).<br>See <code>FActiveGameplayEffect::PostReplicatedAdd</code>, <code>FActiveGameplayEffect::PreReplicatedRemove</code>, and <code>FActiveGameplayCue::PostReplicatedAdd</code> for examples of how <code>FPredictionKey</code> is associated with the GE’s and GC’s.</p>
<hr>
<h3 id="​​-Attribute-Prediction-​"><a href="#​​-Attribute-Prediction-​" class="headerlink" title="​​ Attribute Prediction ​"></a>​<em><strong>​ Attribute Prediction ​</strong></em></h3><p>Since attributes are replicated as standard uproperties, predicting modification to them can be tricky (“Override” problem). Instantaneous modification can be even harder since these are non stateful by nature.<br>(E.g., rolling back an attribute mod is difficult if there is no book keeping past the modification). This makes the “Undo” and “Redo” problem also hard in this case.</p>
<p>The basic plan of attack is to treat attribute prediction as delta prediction rather than absolute value prediction. We do not predict that we have 90 mana, we predict that we have -10 mana from the server value, until<br>the server confirms our prediction key. Basically, treat instant modifications as &#x2F;infinite duration modifications&#x2F; to attributes while they are done predictively. The solves “Undo” and “Redo”.</p>
<p>For the “override” problem, we can handle this in the properties <code>OnRep</code> by treating the replicated (server) value as the ‘base value’ instead of ‘final value’ of the attribute, and to<br>reaggregate our ‘final value’ after a replication happens.</p>
<h4 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMyHealthSet::GetLifetimeReplicatedProps</span><span class="params">(TArray&lt; FLifetimeProperty &gt; &amp; OutLifetimeProps)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">DOREPLIFETIME_CONDITION_NOTIFY</span>(UMyHealthSet, Health, COND_None, REPNOTIFY_Always);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Gameplay-Cue-Events"><a href="#Gameplay-Cue-Events" class="headerlink" title="Gameplay Cue Events"></a>Gameplay Cue Events</h1><p>Outside of GameplayEffects which are already explained, Gameplay Cues can be activated on their own. These functions (<code>UAbilitySystemComponent::ExecuteGameplayCue</code> etc) take network role and prediction keys into account.</p>
<p>In <code>UAbilitySystemComponent::ExecuteGameplayCue</code>, if authority then do the multicast event (with replication key). If non authority but w&#x2F; a valid prediction key, predict the GameplayCue.<br>On the receiving end (<code>NetMulticast_InvokeGameplayCueExecuted</code> etc), if there is a replication key, then don’t do the event (assume you predicted it).<br>Remember that <code>FPredictionKeys</code> only replicate to the originating owner. This is an intrinsic property of <code>FReplicationKey</code>.</p>
<hr>
<h1 id="Triggered-Data-Prediction"><a href="#Triggered-Data-Prediction" class="headerlink" title="Triggered Data Prediction"></a>Triggered Data Prediction</h1><p>Triggered Data is currently used to activate abilities. Essentially this all goes through the same code path as ActivateAbility. Rather than the ability being activated from input press, it is activated from<br>another game code driven event. Clients are able to predictively execute these events which predictively activate abilities.</p>
<p>There are some nuances to how, since the server will also run the code that triggers events. The server won’t just wait to hear from the client. The server will keep a list of triggered abilities that have been<br>activated from a predictive ability. When receiving a <code>TryActivate</code> from a triggered ability, the server will look to see if &#x2F;it&#x2F; has already run this ability, and respond with that information.</p>
<p>The issue is we do not properly rollback these operations. There is work left to do on Triggered Events and replication. (explained at the end).</p>
<hr>
<h2 id="Advanced-topic-Dependencies"><a href="#Advanced-topic-Dependencies" class="headerlink" title="Advanced topic! Dependencies"></a>Advanced topic! Dependencies</h2><p>We can have situations such as “Ability X activates and immediately triggers an event which activates Ability Y which triggers another Ability Z”. The dependency chain is X-&gt;Y-&gt;Z.<br>Each of those abilities could be rejected by the server. If Y is rejected, then Z also never happened, but the server does not explicitly decide ‘no Z can’t run’.<br>To handle this, we have a concept of a Base PredictionKey, which is a member of <code>FPredictionKey</code>. When calling <code>TryActivateAbility</code>, we pass in the current PredictionKey (if applicable). That prediction key<br>is used as the base for any new prediction keys generated. We build a chain of keys this way, and can then invalidate Z if Y is rejected.</p>
<p>This is slightly more nuanced though. In the X-&gt;Y-&gt;Z case, the server will only receive the PredictionKey for X before trying to run the chain itself. E.g., it will TryActivate Y and Z with the original prediction key<br>sent to it from the client, whereas the client will generate a new PredictionKey each time it calls <code>TryActivateAbility</code>. The client has to generate a new PredictionKey for each ability activate, since each activate<br>is not logically atomic. Each side effect produced in the chain of events has to have a unique PredictionKey. We cannot have GameplayEffects produced in X have the same PredictionKey produced in Z.</p>
<p>To get around this, The prediction key of X is considered the Base key for Y and Z. The dependency from Y to Z is kept completely client side, which is done in by <code>FPredictionKeyDelegates::AddDependency</code>. We add delegates<br>to reject&#x2F;catchup Z if Y rejected&#x2F;confirmed.</p>
<p>This dependency system allows us to have multiple predictive actions that are not logically atomic within a single prediction window&#x2F;scope.</p>
<p>There is a problem though: because the dependencies are kept client side, the server does not actually know if it had previously rejected a dependent action. You can design around this issue by using activation tags<br>in your gameplay abilities. For instance, when predicting dependents GA_Combo1 -&gt; GA_Combo2, you could make GA_Combo2 only activate if it has a GameplayTag given by GA_Combo1. Thus a rejection of GA_Combo1 would also<br>cause the server to reject the activation of GA_Combo2.</p>
<hr>
<h1 id="Additional-Prediction-Windows-within-an-Ability"><a href="#Additional-Prediction-Windows-within-an-Ability" class="headerlink" title="Additional Prediction Windows (within an Ability)"></a>Additional Prediction Windows (within an Ability)</h1><p>As stated, A prediction key is only usable during a single logical scope. Once <code>ActivateAbility</code> returns, we are essentially done with that key. If the ability is waiting on an external event or timer, it’s possible<br>we will have already received a confirm&#x2F;reject from the server by the time we’re ready to continue execution. Thus any additional side effects produced after the initial activation can no longer be tied to the lifespan of the original key.</p>
<p>This isn’t that bad, except that abilities will sometimes want to react to player input. For example, ‘a hold down and charge’ ability wants to instantly predict some stuff when the button is released. It is possible<br>to create a new prediction window within an ability with <code>FScopedPredictionWindow</code>.</p>
<p><strong>FScopedPredictionWindows</strong>​ provides a way to send the server a new prediction key and have the server pick up and use that key within the same logical scope.</p>
<p><code>UAbilityTask_WaitInputRelease::OnReleaseCallback</code> is a good example. The flow of events is as followed:</p>
<ol>
<li>Client enters <code>UAbilityTask_WaitInputRelease::OnReleaseCallback</code> and starts a new <code>FScopedPredictionWindow</code>. This creates a new prediction key for this scope (<code>FScopedPredictionWindow::ScopedPredictionKey</code>).</li>
<li>Client calls <code>AbilitySystemComponent-&gt;ServerInputRelease</code> which passes <code>ScopedPrediction.ScopedPredictionKey</code> as a parameter.</li>
<li>Server runs <code>ServerInputRelease_Implementation</code> which takes the passed in PredictionKey and sets it as <code>UAbilitySystemComponent::ScopedPredictionKey</code> with an <code>FScopedPredictionWindow</code>.</li>
<li>Server runs <code>UAbilityTask_WaitInputRelease::OnReleaseCallback</code> &#x2F;within the same scope&#x2F;</li>
<li>When the server hits the <code>FScopedPredictionWindow</code> in ::OnReleaseCallback, it gets the prediction key from <code>UAbilitySystemComponent::ScopedPredictionKey</code>. That is now used for all side effects within this logical scope.</li>
<li>Once the server ends this scoped prediction window, the prediction key used is finished and set to <code>ReplicatedPredictionKey</code>.</li>
<li>All side effects created in this scope now share a key between client and server.</li>
</ol>
<p>The key to this working is that ::OnReleaseCallback calls ::ServerInputRelease which calls ::OnReleaseCallback on the server. There is no room for anything else to happen and use the given prediction key.</p>
<p>While there is no “Try&#x2F;Failed&#x2F;Succeed” calls in this example, all side effects are procedurally grouped&#x2F;atomic. This solves the “Undo” and “Redo” problems for any arbitrary function calls that run on the server and client.</p>
<hr>
<h1 id="Unsupported-Issues-Todo"><a href="#Unsupported-Issues-Todo" class="headerlink" title="Unsupported &#x2F; Issues&#x2F; Todo"></a>Unsupported &#x2F; Issues&#x2F; Todo</h1><h3 id="Triggered-events-do-not-explicitly-replicate"><a href="#Triggered-events-do-not-explicitly-replicate" class="headerlink" title="Triggered events do not explicitly replicate"></a>Triggered events do not explicitly replicate</h3><ul>
<li>E.g., if a triggered event only runs on the server, the client will never hear about it. This also prevents us from doing cross player&#x2F;AI etc events. Support<br>for this should eventually be added and it should follow the same pattern that GameplayEffect and GameplayCues follow (predict triggered event with a prediction key, ignore the RPC event if it has a prediction key).</li>
</ul>
<p>Big caveat with this whole system: Rollback of any chained activations (including triggered events) is currently not possible out of the box. The reason for this is because each ServerTryActivateAbility is going to be responded to in order.<br>Let’s chain dependent GA’s as an example: GA_Mispredict -&gt; GA_Predict1. In this example, when GA_Mispredict is activated and predicted locally it will immediately also activate GA_Predict1. The client sends ServerTryActivateAbility for GA_Mispredict,<br>and the server rejects it (sending back a ClientActivateAbilityFailed). As it stands, we don’t have any delegates that reject dependent abilities on the client (and the server isn’t even aware there are dependencies). On the server, it also<br>receives a ServerTryActivateAbility for GA_Predict1. Assuming that succeeds, the Client and Server are now both executing GA_Predict1 even though GA_Mispredict never happened. You can design around this by using the tag system to ensure GA_Mispredict succeeded.</p>
<hr>
<h3 id="Predicting-“Meta”-Attributes-such-as-Damage-Healing-vs-“real”-attributes-such-as-Health"><a href="#Predicting-“Meta”-Attributes-such-as-Damage-Healing-vs-“real”-attributes-such-as-Health" class="headerlink" title="Predicting “Meta” Attributes such as Damage&#x2F;Healing vs “real” attributes such as Health"></a>Predicting “Meta” Attributes such as Damage&#x2F;Healing vs “real” attributes such as Health</h3><p>We are unable to apply meta attributes predictively. Meta attributes only work on instant effects, in the back end of GameplayEffect (Pre&#x2F;Post Modify Attribute on the UAttributeSet). These events are not called when<br>applying duration-based gameplay effects. E.g., a GameplayEffect that modifies damage for 5 seconds doesn’t make sense.</p>
<p>In order to support this, we would probably add some limited support for duration based meta attributes, and move the transform of the instant gameplay effect from the front end (<code>UAbilitySystemComponent::ApplyGameplayEffectSpecToSelf</code>)<br>to the backend (<code>UAttributeSet::PostModifyAttribute</code>).</p>
<hr>
<h3 id="Predicting-ongoing-multiplicative-GameplayEffects"><a href="#Predicting-ongoing-multiplicative-GameplayEffects" class="headerlink" title="Predicting ongoing multiplicative GameplayEffects"></a>Predicting ongoing multiplicative GameplayEffects</h3><p>There are also limitations when predicting % based gameplay effects. Since the server replicates down the ‘final value’ of an attribute, but not the entire aggregator chain of what is modifying it, we may run into cases where<br>the client cannot accurately predict new gameplay effects.</p>
<p>For example:</p>
<ul>
<li>Client has a perm +10% movement speed buff with base movement speed of 500 -&gt; 550 is the final movement speed for this client.</li>
<li>Client has an ability which grants an additional 10% movement speed buff. It is expected to <em>sum</em> the % based multipliers for a final 20% bonus to 500 -&gt; 600 movement speed.</li>
<li>However on the client, we just apply a 10% buff to 550 -&gt; 605.</li>
</ul>
<p>This will need to be fixed by replicating down the aggregator chain for attributes. We already replicate some of this data, but not the full modifier list. We will need to look into supporting this eventually.</p>
<hr>
<h3 id="“Weak-Prediction”"><a href="#“Weak-Prediction”" class="headerlink" title="“Weak Prediction”"></a>“Weak Prediction”</h3><p>We will probably still have cases that do not fit well into this system. Some situations will exist where a prediction key exchange is not feasible. For example, an ability where any one that player collides with&#x2F;touches<br>receives a GameplayEffect that slows them and their material blue. Since we can’t send Server RPCs every time this happens (and the server couldn’t necessarily handle the message at its point in the simulation), there is no<br>way to correlate the gameplay effect side effects between client and server.</p>
<p>One approach here may be to think about a weaker form of prediction. One where there is not a fresh prediction key used and instead the server assumes the client will predict all side effects from an entire ability. This would<br>at least solve the “redo” problem but would not solve the “completeness” problem. If the client side prediction could be made as minimal as possible - for example only predicting an initial particle effect rather than<br>predicting the state and attribute change - then the problems get less severe.</p>
<hr>
<h1 id="FPredictionKey-Implementation-Notes"><a href="#FPredictionKey-Implementation-Notes" class="headerlink" title="FPredictionKey Implementation Notes"></a>FPredictionKey Implementation Notes</h1><p><code>FPredictionKey</code> is a generic way of supporting Clientside Prediction in the GameplayAbility system.<br>A <code>FPredictionKey</code> is essentially an ID for identifying predictive actions and side effects that are<br>done on a client. <code>UAbilitySystemComponent</code> supports synchronization of the prediction key and its side effects<br>between client and server.</p>
<p>Essentially, anything can be associated with a <code>PredictionKey</code>, for example activating an Ability.<br>The client can generate a fresh <code>PredictionKey</code> and sends it to the server in its <code>ServerTryActivateAbility</code> call.<br>The server can confirm or reject this call (<code>ClientActivateAbilitySucceed/Failed</code>).</p>
<p>While the client is predicting its ability, it is creating side effects (GameplayEffects, TriggeredEvents, Animations, etc).<br>As the client predicts these side effects, it associates each one with the prediction key generated at the start of the ability<br>activation.</p>
<p>If the ability activation is rejected, the client can immediately revert these side effects.<br>If the ability activation is accepted, the client must wait until the replicated side effects are sent to the server.<br>(The <code>ClientActivatbleAbilitySucceed</code> RPC will be immediately sent. Property replication may happen a few frames later).<br>Once replication of the server created side effects is finished, the client can undo its locally predictive side effects.</p>
<p>The main things <code>FPredictionKey</code> itself provides are:</p>
<ul>
<li>Unique ID and a system for having dependant chains of <code>Prediction Keys</code> (“Current” and “Base” integers)</li>
<li>A special implementation of <code>::NetSerialize</code> which only serializes the prediction key to the predicting client<ul>
<li>This is important as it allows us to serialize prediction keys in replicated state, knowing that only clients that gave the server the prediction key will actually see them!</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://MikeMing126.github.io">Ming</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mikeming126.github.io/UE/GAS/UE55GamplayPrediction/">https://mikeming126.github.io/UE/GAS/UE55GamplayPrediction/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://MikeMing126.github.io" target="_blank">Ming Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/UE/">UE</a><a class="post-meta__tags" href="/tags/GAS/">GAS</a><a class="post-meta__tags" href="/tags/UE-Source/">UE Source</a></div><div class="post-share"><div class="social-share" data-image="/img/head.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/UE/GAS/UE55GAS/" title="UE5.5-GAS-ReadMe"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">UE5.5-GAS-ReadMe</div></div><div class="info-2"><div class="info-item-1">  GASPurpose of this DocumentationThis documentation is meant to support and enhance the official Gameplay Ability System Unreal Developer Community documentation.  In particular, this document lives in the code repository under Gameplay Ability System plug-in folder and thus any user reading this documentation can submit a pull request to clarify functionality, update inaccurate information, or work with the community to flesh out areas that are missing. It is worth noting there are...</div></div></div></a><a class="pagination-related" href="/Other/GitLearning/" title="Git相关内容学习"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Git相关内容学习</div></div><div class="info-2"><div class="info-item-1">前言Git在版本维护上面还是能发挥很好的作用的。当然也可以考虑用TortoiseSVN。主要目的还是维护好代码吧。这样有什么临时改动想回滚到之前版本也比较好处理。避免某些操作无法撤销而花很多精力去重新编写内容。 基础Git指令有需要再补充。 配置GitIgnore相关内容基础说明在Git中，.gitignore文件用于指定项目中要忽略的文件和目录，这些文件和目录不会被跟踪和提交到远程仓库。编写.gitignore文件时，你可以使用一系列规则来匹配要忽略的文件和目录。 基本规则忽略特定文件：  filename.ext 忽略特定目录：  directory&#x2F; 忽略特定扩展名的所有文件：  *.log 忽略特定目录下的所有文件：  directory&#x2F;* 忽略特定目录及其所有子目录：  directory&#x2F;** 高级规则忽略特定模式的文件：  file[0-9].txt 忽略特定模式的目录：  dir*&#x2F;subdir&#x2F; 忽略特定目录下的特定文件： ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/UE/GAS/UE55GAS/" title="UE5.5-GAS-ReadMe"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-04</div><div class="info-item-2">UE5.5-GAS-ReadMe</div></div><div class="info-2"><div class="info-item-1">  GASPurpose of this DocumentationThis documentation is meant to support and enhance the official Gameplay Ability System Unreal Developer Community documentation.  In particular, this document lives in the code repository under Gameplay Ability System plug-in folder and thus any user reading this documentation can submit a pull request to clarify functionality, update inaccurate information, or work with the community to flesh out areas that are missing. It is worth noting there are...</div></div></div></a><a class="pagination-related" href="/UE/GAS/UE55GASGC/" title="UE5.5-GameplayCue"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-08</div><div class="info-item-2">UE5.5-GameplayCue</div></div><div class="info-2"><div class="info-item-1">GameplayCue重要的类：GameplayCueSet 但是游戏中的资源加载并不是这样进行的。 映射关系： Tag -&gt; GC GC的收集过程：将GameplayCue资产放在指定的目录下。具体的可以在.ini里面配置。以Lyra为例子   资源的加载：关键类为UAbilitySystemGlobals与UGameplayCueManager。可以看到GameplayCueManager里。 //UAbilitySystemGlobals部分//GameplayAbilitiesDeveloperSettings.h//注意宏里面Config的关键字/** Look in these paths for GameplayCueNotifies. These are your &quot;always loaded&quot; set. */UPROPERTY(Config, EditDefaultsOnly, Category=GameplayCue, meta =...</div></div></div></a><a class="pagination-related" href="/UE/GAS/UEGamplayPrediction%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/" title="GASPredictionKey自学简记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-06</div><div class="info-item-2">GASPredictionKey自学简记</div></div><div class="info-2"><div class="info-item-1">关键点：PredictionKey由GA激活生成的PKey，并由此去影响GAS系统中的各个其他部分。 客户端预测先行，在收到服务器校验结果后，执行对应的回滚操作。 概念：预测窗口 Prediction Window “We do not predict over multiple frames”  在多个行为激活形成链条时，每个行为有自己的PKey，但又和之前的PKey相关联。服务端并不确定Reject某个PKey对应的行为，是否会导致后续的行为也被拒绝。这里在实现的时候可能需要额外注意下。 关于预测窗口GA如果依赖于外部事件，或者定时器，在异步等待过程中，可能会收到服务器的confirm&#x2F;reject回调。而PKey在ActivateAbility返回时就结束了。因此后面激活的内容是无法绑定到这个PKey上的。 【这里可以验证一下...</div></div></div></a><a class="pagination-related" href="/UE/Project/Lyra/UE55Lyra2/" title="UE5.5-Lyra-2-GE"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-23</div><div class="info-item-2">UE5.5-Lyra-2-GE</div></div><div class="info-2"><div class="info-item-1">GE蓝图创建的GE。基于 GameplayEffectParent_Damage_Basic 来看GE:  Gameplay效果 组件 GEComponents 包含很多个效果 可以在编辑器中细看   修饰符 Modifiers 执行 Executions   Gameplay Cue  GE的执行流程以GA的ApplyCost为例子： GA:ApplyGameplayEffectToOwner↓GA:ApplyGameplayEffectSpecToOwner↓ASC:ApplyGameplayEffectSpecToSelf 到这里可以分为两条路线了，一条是即刻执行的GE，Instant类型。第二种是有持续时间的GE（包括永久）。对于后者，会生成FActiveGameplayEffect。 在ASC:ApplyGameplayEffectSpecToSelf中就有两个关键函数了：  持续类型的 由ASC的FActiveGameplayEffectContainer调用ApplyGameplayEffectSpec处理 Intant类型...</div></div></div></a><a class="pagination-related" href="/UE/Project/Lyra/UE55Lyra1/" title="UE5.5-Lyra-1-Attribute"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-16</div><div class="info-item-2">UE5.5-Lyra-1-Attribute</div></div><div class="info-2"><div class="info-item-1">基于官方Lyra的GAS学习。 综述首先就是ASC的位置。Lyra项目将ASC放置于了LyraPlayerState中。将ASC与PlayerState绑定。 此外 可以看到LyraCharacter。其也有获取ASC的接口。 从LyraCharacter获取ASC组件，依赖于其PawnExtComponent。这里可以看到ULyraPawnExtensionComponent这个类。该类会存放一个ASC指针。在函数InitializeAbilitySystem中进行设置。 LyraHeroComponent是唯一调用该方法的组件。见ULyraHeroComponent::HandleChangeInitState。这里的逻辑也是从PlayerState中拿到ASC，然后赋值给PawnExtComponent。 总而言之，该项目的ASC位于PlayerState。整体的链条大概如下：PlayerState -&gt; LyraHeroComp -&gt; PawnExtComponent -&gt; LyraCharacter。 再整理一下： LyraCharacter -...</div></div></div></a><a class="pagination-related" href="/UE/Project/Lyra/UE55Lyra3/" title="UE5.5-Lyra-3-GATask"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-27</div><div class="info-item-2">UE5.5-Lyra-3-GATask</div></div><div class="info-2"><div class="info-item-1">GamplayAbilityTask基础AbilityTask 异步任务 开始并等待结束&#x2F;打断 部分实现需要关注[K2Node_LatentAbilityCall]  基础逻辑 定义动态多播委托，并声明为BlueprintAssignable 声明静态工厂函数用于创建AbilityTask。由该函数定义输入参数。但是这个不意味着任务开始，不在其中调用广播 实现Activate函数。该函数代表着任务的激活    其他    - OnDestroy记得取消事件的侦听和注册，并调用父类的OnDestroy。   静态工厂函数的meta声明了meta &#x3D; (xxx前面忽略, BlueprintInternalUseOnly &#x3D; “TRUE”)  实际蓝图的调用走过UK2Node_LatentGameplayTaskCall的ExpandNode. WaitOverlap//定义委托DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FWaitOverlapDelegate, const...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Ming</div><div class="author-info-description">我们都在奔赴各自的人生，但你依旧是你</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#SourceCode%E6%BA%90%E7%A0%81"><span class="toc-number">1.</span> <span class="toc-text">SourceCode源码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Overview-of-Gameplay-Ability-Prediction"><span class="toc-number">2.</span> <span class="toc-text">Overview of Gameplay Ability Prediction</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#High-Level-Goals"><span class="toc-number">2.1.</span> <span class="toc-text">High Level Goals</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#What-do-we-currently-predict"><span class="toc-number">2.2.</span> <span class="toc-text">What do we currently predict?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Some-things-we-don%E2%80%99t-predict-most-of-these-we-potentially-could-but-currently-dont"><span class="toc-number">2.3.</span> <span class="toc-text">Some things we don’t predict (most of these we potentially could, but currently dont):</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Problems-we-attempt-to-solve"><span class="toc-number">2.4.</span> <span class="toc-text">Problems we attempt to solve</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Implementation-Details"><span class="toc-number">2.5.</span> <span class="toc-text">Implementation Details</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%8B%E2%80%8B-PredictionKey-%E2%80%8B"><span class="toc-number">2.5.1.</span> <span class="toc-text">​​ PredictionKey ​</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%8B%E2%80%8B-Ability-Activation-%E2%80%8B"><span class="toc-number">2.5.2.</span> <span class="toc-text">​​ Ability Activation ​</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%8B%E2%80%8B-GameplayEffect-Prediction-%E2%80%8B"><span class="toc-number">2.5.3.</span> <span class="toc-text">​​ GameplayEffect Prediction ​</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%8B%E2%80%8B-Attribute-Prediction-%E2%80%8B"><span class="toc-number">2.5.4.</span> <span class="toc-text">​​ Attribute Prediction ​</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Example"><span class="toc-number">2.5.4.1.</span> <span class="toc-text">Example:</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Gameplay-Cue-Events"><span class="toc-number">3.</span> <span class="toc-text">Gameplay Cue Events</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Triggered-Data-Prediction"><span class="toc-number">4.</span> <span class="toc-text">Triggered Data Prediction</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Advanced-topic-Dependencies"><span class="toc-number">4.1.</span> <span class="toc-text">Advanced topic! Dependencies</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Additional-Prediction-Windows-within-an-Ability"><span class="toc-number">5.</span> <span class="toc-text">Additional Prediction Windows (within an Ability)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Unsupported-Issues-Todo"><span class="toc-number">6.</span> <span class="toc-text">Unsupported &#x2F; Issues&#x2F; Todo</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Triggered-events-do-not-explicitly-replicate"><span class="toc-number">6.0.1.</span> <span class="toc-text">Triggered events do not explicitly replicate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Predicting-%E2%80%9CMeta%E2%80%9D-Attributes-such-as-Damage-Healing-vs-%E2%80%9Creal%E2%80%9D-attributes-such-as-Health"><span class="toc-number">6.0.2.</span> <span class="toc-text">Predicting “Meta” Attributes such as Damage&#x2F;Healing vs “real” attributes such as Health</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Predicting-ongoing-multiplicative-GameplayEffects"><span class="toc-number">6.0.3.</span> <span class="toc-text">Predicting ongoing multiplicative GameplayEffects</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%9CWeak-Prediction%E2%80%9D"><span class="toc-number">6.0.4.</span> <span class="toc-text">“Weak Prediction”</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#FPredictionKey-Implementation-Notes"><span class="toc-number">7.</span> <span class="toc-text">FPredictionKey Implementation Notes</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/PostProcessing/" title="Unity PostProcessing">Unity PostProcessing</a><time datetime="2025-10-05T09:10:14.356Z" title="发表于 2025-10-05 17:10:14">2025-10-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/Shadow/" title="Unity Shadow">Unity Shadow</a><time datetime="2025-10-05T07:56:07.434Z" title="发表于 2025-10-05 15:56:07">2025-10-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/SRP/" title="Unity SRP">Unity SRP</a><time datetime="2025-10-02T06:15:27.265Z" title="发表于 2025-10-02 14:15:27">2025-10-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/AsyncOp/" title="Unity异步操作">Unity异步操作</a><time datetime="2025-09-14T08:01:59.349Z" title="发表于 2025-09-14 16:01:59">2025-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/Physics/" title="Unity Physics">Unity Physics</a><time datetime="2025-09-14T08:01:59.345Z" title="发表于 2025-09-14 16:01:59">2025-09-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/starBg2.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2025 By Ming</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23liMdTJDdBPikGC2F',
      clientSecret: 'eed0ab3cb8494f9e22f7a8bb469c58cc7e6fbaea',
      repo: 'BlogComment',
      owner: 'MikeMing126',
      admin: ['MikeMing126'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '46ed6db8c519207426e9769b20d356d5'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script src="/script/APlayerHolder.js"></script><div class="aplayer" data-id="13402811242" data-server="netease" data-type="playlist" data-fixed="true" data-loop="all" data-autoplay="true" data-order="random" data-theme="#3F51B5"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>