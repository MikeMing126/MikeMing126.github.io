<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>UE5.5-Lyra-3-GATask | Ming Blog</title><meta name="author" content="Ming"><meta name="copyright" content="Ming"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="GamplayAbilityTask基础AbilityTask 异步任务 开始并等待结束&#x2F;打断 部分实现需要关注[K2Node_LatentAbilityCall]  基础逻辑 定义动态多播委托，并声明为BlueprintAssignable 声明静态工厂函数用于创建AbilityTask。由该函数定义输入参数。但是这个不意味着任务开始，不在其中调用广播 实现Activate函数。该函数">
<meta property="og:type" content="article">
<meta property="og:title" content="UE5.5-Lyra-3-GATask">
<meta property="og:url" content="https://mikeming126.github.io/UE/Project/Lyra/UE55Lyra3/index.html">
<meta property="og:site_name" content="Ming Blog">
<meta property="og:description" content="GamplayAbilityTask基础AbilityTask 异步任务 开始并等待结束&#x2F;打断 部分实现需要关注[K2Node_LatentAbilityCall]  基础逻辑 定义动态多播委托，并声明为BlueprintAssignable 声明静态工厂函数用于创建AbilityTask。由该函数定义输入参数。但是这个不意味着任务开始，不在其中调用广播 实现Activate函数。该函数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mikeming126.github.io/img/head.png">
<meta property="article:published_time" content="2025-03-27T13:04:29.543Z">
<meta property="article:modified_time" content="2025-04-06T07:21:13.336Z">
<meta property="article:author" content="Ming">
<meta property="article:tag" content="UE">
<meta property="article:tag" content="GAS">
<meta property="article:tag" content="Lyra">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mikeming126.github.io/img/head.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "UE5.5-Lyra-3-GATask",
  "url": "https://mikeming126.github.io/UE/Project/Lyra/UE55Lyra3/",
  "image": "https://mikeming126.github.io/img/head.png",
  "datePublished": "2025-03-27T13:04:29.543Z",
  "dateModified": "2025-04-06T07:21:13.336Z",
  "author": [
    {
      "@type": "Person",
      "name": "Ming",
      "url": "https://mikeming126.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://mikeming126.github.io/UE/Project/Lyra/UE55Lyra3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":4,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'UE5.5-Lyra-3-GATask',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/starBg2.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/starBg2.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Ming Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">UE5.5-Lyra-3-GATask</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">UE5.5-Lyra-3-GATask</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-27T13:04:29.543Z" title="发表于 2025-03-27 21:04:29">2025-03-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-06T07:21:13.336Z" title="更新于 2025-04-06 15:21:13">2025-04-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/UE/">UE</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="GamplayAbilityTask"><a href="#GamplayAbilityTask" class="headerlink" title="GamplayAbilityTask"></a>GamplayAbilityTask</h1><h2 id="基础AbilityTask"><a href="#基础AbilityTask" class="headerlink" title="基础AbilityTask"></a>基础AbilityTask</h2><ul>
<li>异步任务</li>
<li>开始并等待结束&#x2F;打断</li>
<li>部分实现需要关注[K2Node_LatentAbilityCall]</li>
</ul>
<h3 id="基础逻辑"><a href="#基础逻辑" class="headerlink" title="基础逻辑"></a>基础逻辑</h3><ul>
<li>定义动态多播委托，并声明为BlueprintAssignable</li>
<li>声明静态工厂函数用于创建AbilityTask。由该函数定义输入参数。但是这个不意味着任务开始，不在其中调用广播</li>
<li>实现Activate函数。该函数代表着任务的激活</li>
</ul>
<p>  其他<br>    - OnDestroy记得取消事件的侦听和注册，并调用父类的OnDestroy。</p>
<p>  静态工厂函数的meta声明了meta &#x3D; (xxx前面忽略, BlueprintInternalUseOnly &#x3D; “TRUE”)<br>  实际蓝图的调用走过UK2Node_LatentGameplayTaskCall的ExpandNode.</p>
<h3 id="WaitOverlap"><a href="#WaitOverlap" class="headerlink" title="WaitOverlap"></a>WaitOverlap</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//定义委托</span><br><span class="line">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FWaitOverlapDelegate, const FGameplayAbilityTargetDataHandle&amp;, TargetData);</span><br><span class="line"></span><br><span class="line">class AActor;</span><br><span class="line">class UPrimitiveComponent;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *	Fixme: this is still incomplete and probablyh not what most games want for melee systems.</span><br><span class="line"> *		-Only actually activates on Blocking hits</span><br><span class="line"> *		-Uses first PrimitiveComponent instead of being able to specify arbitrary component.</span><br><span class="line"> */</span><br><span class="line">UCLASS()</span><br><span class="line">class GAMEPLAYABILITIES_API UAbilityTask_WaitOverlap : public UAbilityTask</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_UCLASS_BODY()</span><br><span class="line"></span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FWaitOverlapDelegate	OnOverlap;</span><br><span class="line"></span><br><span class="line">    UFUNCTION()</span><br><span class="line">    void OnHitCallback(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult&amp; Hit);</span><br><span class="line"></span><br><span class="line">    //重写Activate</span><br><span class="line">    virtual void Activate() override;</span><br><span class="line"></span><br><span class="line">    //定义静态工厂函数</span><br><span class="line">    /** Wait until an overlap occurs. This will need to be better fleshed out so we can specify game specific collision requirements */</span><br><span class="line">    UFUNCTION(BlueprintCallable, Category=&quot;Ability|Tasks&quot;, meta = (HidePin = &quot;OwningAbility&quot;, DefaultToSelf = &quot;OwningAbility&quot;, BlueprintInternalUseOnly = &quot;TRUE&quot;))</span><br><span class="line">    static UAbilityTask_WaitOverlap* WaitForOverlap(UGameplayAbility* OwningAbility);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    //重写OnDestory</span><br><span class="line">    virtual void OnDestroy(bool AbilityEnded) override;</span><br><span class="line"></span><br><span class="line">    UPrimitiveComponent* GetComponent();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看到实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line">* 将生成的文件(xxx.Generated.cpp)内联到模块CPP文件中，这样能减少需要解析的头文件数量，从而缩短编译时间。</span><br><span class="line">* #include UE_INLINE_GENERATED_CPP_BY_NAME(CPP纯文件名无后缀)</span><br><span class="line">* 在CPP中使用，一般添加在#include最后部分</span><br><span class="line">*/</span><br><span class="line">//特殊include</span><br><span class="line">#include UE_INLINE_GENERATED_CPP_BY_NAME(AbilityTask_WaitOverlap)</span><br><span class="line"></span><br><span class="line">UAbilityTask_WaitOverlap::UAbilityTask_WaitOverlap(const FObjectInitializer&amp; ObjectInitializer): Super(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//主要的逻辑函数 - 异步逻辑</span><br><span class="line">void UAbilityTask_WaitOverlap::OnHitCallback(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult&amp; Hit)</span><br><span class="line">&#123;</span><br><span class="line">    if(OtherActor)</span><br><span class="line">    &#123;</span><br><span class="line">        // Construct TargetData</span><br><span class="line">        FGameplayAbilityTargetData_SingleTargetHit * TargetData = new FGameplayAbilityTargetData_SingleTargetHit(Hit);</span><br><span class="line"></span><br><span class="line">        // Give it a handle and return</span><br><span class="line">        FGameplayAbilityTargetDataHandle	Handle;</span><br><span class="line">        Handle.Data.Add(TSharedPtr&lt;FGameplayAbilityTargetData&gt;(TargetData));</span><br><span class="line"></span><br><span class="line">        //广播之前需要进行一下有效性检测</span><br><span class="line">        if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">        &#123;</span><br><span class="line">            OnOverlap.Broadcast(Handle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // We are done. Kill us so we don&#x27;t keep getting broadcast messages</span><br><span class="line">        EndTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">*	Need:</span><br><span class="line">*	-Easy way to specify which primitive components should be used for this overlap test</span><br><span class="line">*	-Easy way to specify which types of actors/collision overlaps that we care about/want to block on</span><br><span class="line">*/</span><br><span class="line">//静态工厂函数</span><br><span class="line">UAbilityTask_WaitOverlap* UAbilityTask_WaitOverlap::WaitForOverlap(UGameplayAbility* OwningAbility)</span><br><span class="line">&#123;</span><br><span class="line">    //这里需要注意调用方法为NewAbilityTask</span><br><span class="line">    UAbilityTask_WaitOverlap* MyObj = NewAbilityTask&lt;UAbilityTask_WaitOverlap&gt;(OwningAbility);</span><br><span class="line">    return MyObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_WaitOverlap::Activate()</span><br><span class="line">&#123;</span><br><span class="line">    //这里会做有效性检测</span><br><span class="line">    SetWaitingOnAvatar();</span><br><span class="line"></span><br><span class="line">    UPrimitiveComponent* PrimComponent = GetComponent();</span><br><span class="line">    if (PrimComponent)</span><br><span class="line">    &#123;</span><br><span class="line">        //对动态多播委托添加侦听</span><br><span class="line">        PrimComponent-&gt;OnComponentHit.AddDynamic(this, &amp;UAbilityTask_WaitOverlap::OnHitCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_WaitOverlap::OnDestroy(bool AbilityEnded)</span><br><span class="line">&#123;</span><br><span class="line">    UPrimitiveComponent* PrimComponent = GetComponent();</span><br><span class="line">    if (PrimComponent)</span><br><span class="line">    &#123;</span><br><span class="line">        //移除侦听</span><br><span class="line">        PrimComponent-&gt;OnComponentHit.RemoveDynamic(this, &amp;UAbilityTask_WaitOverlap::OnHitCallback);</span><br><span class="line">    &#125;</span><br><span class="line">    //父类OnDestroy</span><br><span class="line">    Super::OnDestroy(AbilityEnded);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UPrimitiveComponent* UAbilityTask_WaitOverlap::GetComponent()</span><br><span class="line">&#123;</span><br><span class="line">    // TEMP - we are just using root component&#x27;s collision. A real system will need more data to specify which component to use</span><br><span class="line">    UPrimitiveComponent * PrimComponent = nullptr;</span><br><span class="line">    AActor* ActorOwner = GetAvatarActor();</span><br><span class="line">    if (ActorOwner)</span><br><span class="line">    &#123;</span><br><span class="line">        PrimComponent = Cast&lt;UPrimitiveComponent&gt;(ActorOwner-&gt;GetRootComponent());</span><br><span class="line">        if (!PrimComponent)</span><br><span class="line">        &#123;</span><br><span class="line">            PrimComponent = ActorOwner-&gt;FindComponentByClass&lt;UPrimitiveComponent&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return PrimComponent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SpawnActor类型的AbilityTask"><a href="#SpawnActor类型的AbilityTask" class="headerlink" title="SpawnActor类型的AbilityTask"></a>SpawnActor类型的AbilityTask</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">*	--------------------------------------</span><br><span class="line">*	</span><br><span class="line">*	We have additional support for AbilityTasks that want to spawn actors. Though this could be accomplished in an Activate() function, it would not be</span><br><span class="line">*	possible to pass in dynamic &quot;ExposeOnSpawn&quot; actor properties. This is a powerful feature of blueprints, in order to support this, you need to implement </span><br><span class="line">*	a different step 3:</span><br><span class="line">*	</span><br><span class="line">*	Instead of an Activate() function, you should implement a BeginSpawningActor() and FinishSpawningActor() function.</span><br><span class="line">*	</span><br><span class="line">*	BeginSpawningActor() must take in a TSubclassOf&lt;YourActorClassToSpawn&gt; parameters named &#x27;Class&#x27;. It must also have a out reference parameters of type </span><br><span class="line">*	YourActorClassToSpawn*&amp; named SpawnedActor. This function is allowed to decide whether it wants to spawn the actor or not (useful if wishing to</span><br><span class="line">*	predicate actor spawning on network authority).</span><br><span class="line">*	</span><br><span class="line">*	BeginSpawningActor() can instantiate an actor with SpawnActorDeferred. This is important, otherwise the UCS will run before spawn parameters are set.</span><br><span class="line">*	BeginSpawningActor() should also set the SpawnedActor parameter to the actor it spawned.</span><br><span class="line">*	</span><br><span class="line">*	[Next, the generated byte code will set the expose on spawn parameters to whatever the user has set]</span><br><span class="line">*	</span><br><span class="line">*	If you spawned something, FinishSpawningActor() will be called and pass in the same actor that was just spawned. You MUST call ExecuteConstruction + PostActorConstruction</span><br><span class="line">*	on this actor!</span><br><span class="line">*	</span><br><span class="line">*	This is a lot of steps but in general, AbilityTask_SpawnActor() gives a clear, minimal example.</span><br><span class="line">*	</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>相较于Activate,需要实现BeginSpawningActor与FinishSpawningActor两个函数。<br>具体的逻辑要往上追溯UK2Node_LatentGameplayTaskCall与UK2Node_LatentAbilityCall。</p>
<h3 id="SpawnActor"><a href="#SpawnActor" class="headerlink" title="SpawnActor"></a>SpawnActor</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//动态多播委托</span><br><span class="line">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FGameplayTaskSpawnActorDelegate, AActor*, SpawnedActor);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *	Convenience task for spawning actors (optionally limiting the spawning to the network authority). If not the net authority, we will not spawn </span><br><span class="line"> *	and Success will not be called. The nice thing this adds is the ability to modify expose on spawn properties while also implicitly checking </span><br><span class="line"> *	network role before spawning.</span><br><span class="line"> *</span><br><span class="line"> *	Though this task doesn&#x27;t do much - games can implement similar tasks that carry out game specific rules. For example a &#x27;SpawnProjectile&#x27;</span><br><span class="line"> *	task that limits the available classes to the games projectile class, and that does game specific stuff on spawn (for example, determining</span><br><span class="line"> *	firing position from a weapon attachment).</span><br><span class="line"> *	</span><br><span class="line"> *	Long term we can also use this task as a sync point. If the executing client could wait execution until the server creates and replicates the </span><br><span class="line"> *	actor down to it. We could potentially also use this to do predictive actor spawning / reconciliation.</span><br><span class="line"> --“作为网络同步锚点，等待服务器生成并复制Actor到客户端后才继续执行。未来还可以用于预测性Actor生成与协调”</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">UCLASS(MinimalAPI)</span><br><span class="line">class UGameplayTask_SpawnActor : public UGameplayTask</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line">public:</span><br><span class="line">    //声明委托</span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FGameplayTaskSpawnActorDelegate	Success;</span><br><span class="line"></span><br><span class="line">    /** Called when we can&#x27;t spawn: on clients or potentially on server if they fail to spawn (rare) */</span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FGameplayTaskSpawnActorDelegate	DidNotSpawn;</span><br><span class="line"></span><br><span class="line">    //静态工厂函数</span><br><span class="line">    /** Spawn new Actor on the network authority (server) */</span><br><span class="line">    UFUNCTION(BlueprintCallable, Category = &quot;GameplayTasks&quot;, meta = (DisplayName=&quot;Spawn Actor for Gameplay Task&quot;, AdvancedDisplay = &quot;TaskOwner, bSpawnOnlyOnAuthority&quot;, DefaultToSelf = &quot;TaskOwner&quot;, BlueprintInternalUseOnly = &quot;TRUE&quot;))</span><br><span class="line">    static UGameplayTask_SpawnActor* SpawnActor(TScriptInterface&lt;IGameplayTaskOwnerInterface&gt; TaskOwner, FVector SpawnLocation, FRotator SpawnRotation, TSubclassOf&lt;AActor&gt; Class, bool bSpawnOnlyOnAuthority = false);</span><br><span class="line"></span><br><span class="line">    //重要函数1</span><br><span class="line">    UFUNCTION(BlueprintCallable, meta = (WorldContext=&quot;WorldContextObject&quot;, BlueprintInternalUseOnly = &quot;true&quot;), Category = &quot;GameplayTasks&quot;)</span><br><span class="line">    virtual bool BeginSpawningActor(UObject* WorldContextObject, AActor*&amp; SpawnedActor);</span><br><span class="line"></span><br><span class="line">    //重要函数2</span><br><span class="line">    UFUNCTION(BlueprintCallable, meta = (WorldContext=&quot;WorldContextObject&quot;, BlueprintInternalUseOnly = &quot;true&quot;), Category = &quot;GameplayTasks&quot;)</span><br><span class="line">    virtual void FinishSpawningActor(UObject* WorldContextObject, AActor* SpawnedActor);</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    FVector CachedSpawnLocation;</span><br><span class="line">    FRotator CachedSpawnRotation;</span><br><span class="line">    UPROPERTY()</span><br><span class="line">    TSubclassOf&lt;AActor&gt; ClassToSpawn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>来看到实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include UE_INLINE_GENERATED_CPP_BY_NAME(AbilityTask_SpawnActor)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UAbilityTask_SpawnActor::UAbilityTask_SpawnActor(const FObjectInitializer&amp; ObjectInitializer)</span><br><span class="line">	: Super(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//静态工厂函数</span><br><span class="line">UAbilityTask_SpawnActor* UAbilityTask_SpawnActor::SpawnActor(UGameplayAbility* OwningAbility, FGameplayAbilityTargetDataHandle TargetData, TSubclassOf&lt;AActor&gt; InClass)</span><br><span class="line">&#123;</span><br><span class="line">    //定义了目标类 - InClass</span><br><span class="line">    //定义了目标参数 - TargetData</span><br><span class="line"></span><br><span class="line">    //使用NewAbilityTask创建对象</span><br><span class="line">    UAbilityTask_SpawnActor* MyObj = NewAbilityTask&lt;UAbilityTask_SpawnActor&gt;(OwningAbility);</span><br><span class="line">    //变量赋值 - 使用MoveTemp的方式</span><br><span class="line">    MyObj-&gt;CachedTargetDataHandle = MoveTemp(TargetData);</span><br><span class="line">    return MyObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ---------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">bool UAbilityTask_SpawnActor::BeginSpawningActor(UGameplayAbility* OwningAbility, FGameplayAbilityTargetDataHandle TargetData, TSubclassOf&lt;AActor&gt; InClass, AActor*&amp; SpawnedActor)</span><br><span class="line">&#123;</span><br><span class="line">    //ShouldBroadcastAbilityTaskDelegates 有效性检测</span><br><span class="line">    if (Ability &amp;&amp; Ability-&gt;GetCurrentActorInfo()-&gt;IsNetAuthority() &amp;&amp; ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">    &#123;</span><br><span class="line">        UWorld* const World = GEngine-&gt;GetWorldFromContextObject(OwningAbility, EGetWorldErrorMode::LogAndReturnNull);</span><br><span class="line">        if (World)</span><br><span class="line">        &#123;</span><br><span class="line">            //生成对象</span><br><span class="line">            //这里SpawnActorDeferred内部调用UWorld::SpawnActor</span><br><span class="line">            SpawnedActor = World-&gt;SpawnActorDeferred&lt;AActor&gt;(InClass, FTransform::Identity, NULL, NULL, ESpawnActorCollisionHandlingMethod::AlwaysSpawn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (SpawnedActor == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        //有效性检测</span><br><span class="line">        if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">        &#123;</span><br><span class="line">            DidNotSpawn.Broadcast(nullptr);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_SpawnActor::FinishSpawningActor(UGameplayAbility* OwningAbility, FGameplayAbilityTargetDataHandle TargetData, AActor* SpawnedActor)</span><br><span class="line">&#123;</span><br><span class="line">    if (SpawnedActor)</span><br><span class="line">    &#123;</span><br><span class="line">        //设置参数</span><br><span class="line">        bool bTransformSet = false;</span><br><span class="line">        FTransform SpawnTransform;</span><br><span class="line">        if (FGameplayAbilityTargetData* LocationData = CachedTargetDataHandle.Get(0))		//Hardcode to use data 0. It&#x27;s OK if data isn&#x27;t useful/valid.</span><br><span class="line">        &#123;</span><br><span class="line">            //Set location. Rotation is unaffected.</span><br><span class="line">            if (LocationData-&gt;HasHitResult())</span><br><span class="line">            &#123;</span><br><span class="line">                SpawnTransform.SetLocation(LocationData-&gt;GetHitResult()-&gt;Location);</span><br><span class="line">                bTransformSet = true;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (LocationData-&gt;HasEndPoint())</span><br><span class="line">            &#123;</span><br><span class="line">                SpawnTransform = LocationData-&gt;GetEndPointTransform();</span><br><span class="line">                bTransformSet = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!bTransformSet)</span><br><span class="line">        &#123;</span><br><span class="line">            if (UAbilitySystemComponent* ASC = AbilitySystemComponent.Get())</span><br><span class="line">            &#123;</span><br><span class="line">                SpawnTransform = ASC-&gt;GetOwner()-&gt;GetTransform();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //注意调用FinishSpawning！</span><br><span class="line">        //AActor::FinishSpawning内部处理ExecuteConstruction 与 PostActorConstruction</span><br><span class="line">        /** Called to finish the spawning process, generally in the case of deferred spawning */</span><br><span class="line">        SpawnedActor-&gt;FinishSpawning(SpawnTransform);</span><br><span class="line"></span><br><span class="line">        //有效性检测</span><br><span class="line">        if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">        &#123;</span><br><span class="line">            Success.Broadcast(SpawnedActor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EndTask();</span><br><span class="line">&#125;</span><br><span class="line">// ---------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">//没有对委托做单独注册，也不需要重写OnDestroy了</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="WaitTargetData"><a href="#WaitTargetData" class="headerlink" title="WaitTargetData"></a>WaitTargetData</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//声明动态多播委托</span><br><span class="line">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FWaitTargetDataDelegate, const FGameplayAbilityTargetDataHandle&amp;, Data);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Wait for targeting actor (spawned from parameter) to provide data. Can be set not to end upon outputting data. Can be ended by task name.</span><br><span class="line"> *</span><br><span class="line"> * WARNING: These actors are spawned once per ability activation and in their default form are not very efficient</span><br><span class="line"> * For most games you will need to subclass and heavily modify this actor, or you will want to implement similar functions in a game-specific actor or blueprint to avoid actor spawn costs</span><br><span class="line"> * This task is not well tested by internal games, but it is a useful class to look at to learn how target replication occurs</span><br><span class="line"> */</span><br><span class="line">UCLASS()</span><br><span class="line">class GAMEPLAYABILITIES_API UAbilityTask_WaitTargetData: public UAbilityTask</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_UCLASS_BODY()</span><br><span class="line"></span><br><span class="line">    //声明委托变量</span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FWaitTargetDataDelegate	ValidData;</span><br><span class="line"></span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FWaitTargetDataDelegate	Cancelled;</span><br><span class="line"></span><br><span class="line">    //复制回调</span><br><span class="line">    UFUNCTION()</span><br><span class="line">    virtual void OnTargetDataReplicatedCallback(const FGameplayAbilityTargetDataHandle&amp; Data, FGameplayTag ActivationTag);</span><br><span class="line"></span><br><span class="line">    UFUNCTION()</span><br><span class="line">    virtual void OnTargetDataReplicatedCancelledCallback();</span><br><span class="line"></span><br><span class="line">    UFUNCTION()</span><br><span class="line">    virtual void OnTargetDataReadyCallback(const FGameplayAbilityTargetDataHandle&amp; Data);</span><br><span class="line"></span><br><span class="line">    UFUNCTION()</span><br><span class="line">    virtual void OnTargetDataCancelledCallback(const FGameplayAbilityTargetDataHandle&amp; Data);</span><br><span class="line"></span><br><span class="line">    //静态工厂函数</span><br><span class="line">    //这里有两个工厂函数。</span><br><span class="line">    //一个使用目标类，并由内部处理目标类的对象生成。并使用BeginSpawningActor与FinishSpawningActor。</span><br><span class="line">    //一个使用已有对象。并使用Activate。</span><br><span class="line">    /** Spawns target actor and waits for it to return valid data or to be canceled. */</span><br><span class="line">    UFUNCTION(BlueprintCallable, meta=(HidePin = &quot;OwningAbility&quot;, DefaultToSelf = &quot;OwningAbility&quot;, BlueprintInternalUseOnly = &quot;true&quot;, HideSpawnParms=&quot;Instigator&quot;), Category=&quot;Ability|Tasks&quot;)</span><br><span class="line">    static UAbilityTask_WaitTargetData* WaitTargetData(UGameplayAbility* OwningAbility, FName TaskInstanceName, TEnumAsByte&lt;EGameplayTargetingConfirmation::Type&gt; ConfirmationType, TSubclassOf&lt;AGameplayAbilityTargetActor&gt; Class);</span><br><span class="line"></span><br><span class="line">    /** Uses specified target actor and waits for it to return valid data or to be canceled. */</span><br><span class="line">    UFUNCTION(BlueprintCallable, meta = (HidePin = &quot;OwningAbility&quot;, DefaultToSelf = &quot;OwningAbility&quot;, BlueprintInternalUseOnly = &quot;true&quot;, HideSpawnParms = &quot;Instigator&quot;), Category = &quot;Ability|Tasks&quot;)</span><br><span class="line">    static UAbilityTask_WaitTargetData* WaitTargetDataUsingActor(UGameplayAbility* OwningAbility, FName TaskInstanceName, TEnumAsByte&lt;EGameplayTargetingConfirmation::Type&gt; ConfirmationType, AGameplayAbilityTargetActor* TargetActor);</span><br><span class="line"></span><br><span class="line">    //重写的Activate函数</span><br><span class="line">    virtual void Activate() override;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //由于要生成对象 声明BeginSpawningActor与FinishSpawningActor。</span><br><span class="line">    //这里和SpawnActor的参数还不太一样 可以再研究</span><br><span class="line">    UFUNCTION(BlueprintCallable, meta = (HidePin = &quot;OwningAbility&quot;, DefaultToSelf = &quot;OwningAbility&quot;, BlueprintInternalUseOnly = &quot;true&quot;), Category = &quot;Abilities&quot;)</span><br><span class="line">    virtual bool BeginSpawningActor(UGameplayAbility* OwningAbility, TSubclassOf&lt;AGameplayAbilityTargetActor&gt; Class, AGameplayAbilityTargetActor*&amp; SpawnedActor);</span><br><span class="line"></span><br><span class="line">    UFUNCTION(BlueprintCallable, meta = (HidePin = &quot;OwningAbility&quot;, DefaultToSelf = &quot;OwningAbility&quot;, BlueprintInternalUseOnly = &quot;true&quot;), Category = &quot;Abilities&quot;)</span><br><span class="line">    virtual void FinishSpawningActor(UGameplayAbility* OwningAbility, AGameplayAbilityTargetActor* SpawnedActor);</span><br><span class="line"></span><br><span class="line">    /** Called when the ability is asked to confirm from an outside node. What this means depends on the individual task. By default, this does nothing other than ending if bEndTask is true. */</span><br><span class="line">    virtual void ExternalConfirm(bool bEndTask) override;</span><br><span class="line"></span><br><span class="line">    /** Called when the ability is asked to cancel from an outside node. What this means depends on the individual task. By default, this does nothing other than ending the task. */</span><br><span class="line">    virtual void ExternalCancel() override;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line"></span><br><span class="line">    virtual bool ShouldSpawnTargetActor() const;</span><br><span class="line">    virtual void InitializeTargetActor(AGameplayAbilityTargetActor* SpawnedActor) const;</span><br><span class="line">    virtual void FinalizeTargetActor(AGameplayAbilityTargetActor* SpawnedActor) const;</span><br><span class="line"></span><br><span class="line">    virtual void RegisterTargetDataCallbacks();</span><br><span class="line"></span><br><span class="line">    virtual void OnDestroy(bool AbilityEnded) override;</span><br><span class="line"></span><br><span class="line">    virtual bool ShouldReplicateDataToServer() const;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line"></span><br><span class="line">    UPROPERTY()</span><br><span class="line">    TSubclassOf&lt;AGameplayAbilityTargetActor&gt; TargetClass;</span><br><span class="line"></span><br><span class="line">    /** The TargetActor that we spawned */</span><br><span class="line">    UPROPERTY()</span><br><span class="line">    TObjectPtr&lt;AGameplayAbilityTargetActor&gt; TargetActor;</span><br><span class="line"></span><br><span class="line">    TEnumAsByte&lt;EGameplayTargetingConfirmation::Type&gt; ConfirmationType;</span><br><span class="line"></span><br><span class="line">    FDelegateHandle OnTargetDataReplicatedCallbackDelegateHandle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">*	Requirements for using Begin/Finish SpawningActor functionality:</span><br><span class="line">*		-Have a parameters named &#x27;Class&#x27; in your Proxy factor function (E.g., WaitTargetdata)</span><br><span class="line">*		-Have a function named BeginSpawningActor w/ the same Class parameter</span><br><span class="line">*			-This function should spawn the actor with SpawnActorDeferred and return true/false if it spawned something.</span><br><span class="line">*		-Have a function named FinishSpawningActor w/ an AActor* of the class you spawned</span><br><span class="line">*			-This function *must* call ExecuteConstruction + PostActorConstruction</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>看到实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include UE_INLINE_GENERATED_CPP_BY_NAME(AbilityTask_WaitTargetData)</span><br><span class="line"></span><br><span class="line">UAbilityTask_WaitTargetData::UAbilityTask_WaitTargetData(const FObjectInitializer&amp; ObjectInitializer)</span><br><span class="line">	: Super(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//静态工厂函数</span><br><span class="line">UAbilityTask_WaitTargetData* UAbilityTask_WaitTargetData::WaitTargetData(UGameplayAbility* OwningAbility, FName TaskInstanceName, TEnumAsByte&lt;EGameplayTargetingConfirmation::Type&gt; ConfirmationType, TSubclassOf&lt;AGameplayAbilityTargetActor&gt; InTargetClass)</span><br><span class="line">&#123;</span><br><span class="line">    //NewAbilityTask创建对象</span><br><span class="line">    UAbilityTask_WaitTargetData* MyObj = NewAbilityTask&lt;UAbilityTask_WaitTargetData&gt;(OwningAbility, TaskInstanceName);		//Register for task list here, providing a given FName as a key</span><br><span class="line">    //设置对象的参数</span><br><span class="line">    MyObj-&gt;TargetClass = InTargetClass;</span><br><span class="line">    MyObj-&gt;TargetActor = nullptr;</span><br><span class="line">    MyObj-&gt;ConfirmationType = ConfirmationType;</span><br><span class="line">    return MyObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UAbilityTask_WaitTargetData* UAbilityTask_WaitTargetData::WaitTargetDataUsingActor(UGameplayAbility* OwningAbility, FName TaskInstanceName, TEnumAsByte&lt;EGameplayTargetingConfirmation::Type&gt; ConfirmationType, AGameplayAbilityTargetActor* InTargetActor)</span><br><span class="line">&#123;</span><br><span class="line">    //和上面的一样 不过是用Actor</span><br><span class="line">    UAbilityTask_WaitTargetData* MyObj = NewAbilityTask&lt;UAbilityTask_WaitTargetData&gt;(OwningAbility, TaskInstanceName);		//Register for task list here, providing a given FName as a key</span><br><span class="line">    MyObj-&gt;TargetClass = nullptr;</span><br><span class="line">    MyObj-&gt;TargetActor = InTargetActor;</span><br><span class="line">    MyObj-&gt;ConfirmationType = ConfirmationType;</span><br><span class="line">    return MyObj;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_WaitTargetData::Activate()</span><br><span class="line">&#123;</span><br><span class="line">    //这里是以传入TargetActor的方式来处理的</span><br><span class="line">    // Need to handle case where target actor was passed into task</span><br><span class="line">    if (Ability &amp;&amp; (TargetClass == nullptr))</span><br><span class="line">    &#123;</span><br><span class="line">        if (TargetActor)</span><br><span class="line">        &#123;</span><br><span class="line">            AGameplayAbilityTargetActor* SpawnedActor = TargetActor;</span><br><span class="line">            //获取类</span><br><span class="line">            TargetClass = SpawnedActor-&gt;GetClass();</span><br><span class="line">            //注册回调</span><br><span class="line">            RegisterTargetDataCallbacks();</span><br><span class="line"></span><br><span class="line">            if (!IsValid(this))</span><br><span class="line">            &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (ShouldSpawnTargetActor())</span><br><span class="line">            &#123;   </span><br><span class="line">                //设置PlayerController并注册回调</span><br><span class="line">                InitializeTargetActor(SpawnedActor);</span><br><span class="line">                //ASC设置信息</span><br><span class="line">                FinalizeTargetActor(SpawnedActor);</span><br><span class="line"></span><br><span class="line">                // Note that the call to FinalizeTargetActor, this task could finish and our owning ability may be ended.</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                TargetActor = nullptr;</span><br><span class="line"></span><br><span class="line">                // We may need a better solution here.  We don&#x27;t know the target actor isn&#x27;t needed till after it&#x27;s already been spawned.</span><br><span class="line">                SpawnedActor-&gt;Destroy();</span><br><span class="line">                SpawnedActor = nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            EndTask();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool UAbilityTask_WaitTargetData::BeginSpawningActor(UGameplayAbility* OwningAbility, TSubclassOf&lt;AGameplayAbilityTargetActor&gt; InTargetClass, AGameplayAbilityTargetActor*&amp; SpawnedActor)</span><br><span class="line">&#123;</span><br><span class="line">    SpawnedActor = nullptr;</span><br><span class="line"></span><br><span class="line">    if (Ability)</span><br><span class="line">    &#123;</span><br><span class="line">        if (ShouldSpawnTargetActor())</span><br><span class="line">        &#123;</span><br><span class="line">            UClass* Class = *InTargetClass;</span><br><span class="line">            if (Class != nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                if (UWorld* World = GEngine-&gt;GetWorldFromContextObject(OwningAbility, EGetWorldErrorMode::LogAndReturnNull))</span><br><span class="line">                &#123;</span><br><span class="line">                    //生成对应的对象</span><br><span class="line">                    SpawnedActor = World-&gt;SpawnActorDeferred&lt;AGameplayAbilityTargetActor&gt;(Class, FTransform::Identity, nullptr, nullptr, ESpawnActorCollisionHandlingMethod::AlwaysSpawn);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (SpawnedActor)</span><br><span class="line">            &#123;</span><br><span class="line">                TargetActor = SpawnedActor;</span><br><span class="line">                //注册回调</span><br><span class="line">                InitializeTargetActor(SpawnedActor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RegisterTargetDataCallbacks();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (SpawnedActor != nullptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_WaitTargetData::FinishSpawningActor(UGameplayAbility* OwningAbility, AGameplayAbilityTargetActor* SpawnedActor)</span><br><span class="line">&#123;</span><br><span class="line">    UAbilitySystemComponent* ASC = AbilitySystemComponent.Get();</span><br><span class="line">    if (ASC &amp;&amp; IsValid(SpawnedActor))</span><br><span class="line">    &#123;</span><br><span class="line">        check(TargetActor == SpawnedActor);</span><br><span class="line"></span><br><span class="line">        const FTransform SpawnTransform = ASC-&gt;GetOwner()-&gt;GetTransform();</span><br><span class="line"></span><br><span class="line">        SpawnedActor-&gt;FinishSpawning(SpawnTransform);</span><br><span class="line"></span><br><span class="line">        FinalizeTargetActor(SpawnedActor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool UAbilityTask_WaitTargetData::ShouldSpawnTargetActor() const</span><br><span class="line">&#123;</span><br><span class="line">    check(TargetClass);</span><br><span class="line">    check(Ability);</span><br><span class="line"></span><br><span class="line">    // Spawn the actor if this is a locally controlled ability (always) or if this is a replicating targeting mode.</span><br><span class="line">    // (E.g., server will spawn this target actor to replicate to all non owning clients)</span><br><span class="line"></span><br><span class="line">    const AGameplayAbilityTargetActor* CDO = CastChecked&lt;AGameplayAbilityTargetActor&gt;(TargetClass-&gt;GetDefaultObject());</span><br><span class="line"></span><br><span class="line">    const bool bReplicates = CDO-&gt;GetIsReplicated();</span><br><span class="line">    const bool bIsLocallyControlled = Ability-&gt;GetCurrentActorInfo()-&gt;IsLocallyControlled();</span><br><span class="line">    const bool bShouldProduceTargetDataOnServer = CDO-&gt;ShouldProduceTargetDataOnServer;</span><br><span class="line"></span><br><span class="line">    return (bReplicates || bIsLocallyControlled || bShouldProduceTargetDataOnServer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_WaitTargetData::InitializeTargetActor(AGameplayAbilityTargetActor* SpawnedActor) const</span><br><span class="line">&#123;</span><br><span class="line">    check(SpawnedActor);</span><br><span class="line">    check(Ability);</span><br><span class="line"></span><br><span class="line">    //设置生成Actor的PlayerController</span><br><span class="line">    SpawnedActor-&gt;PrimaryPC = Ability-&gt;GetCurrentActorInfo()-&gt;PlayerController.Get();</span><br><span class="line"></span><br><span class="line">    //这里见到GameplayAbilityTargetActor</span><br><span class="line">    // If we spawned the target actor, always register the callbacks for when the data is ready.</span><br><span class="line">    SpawnedActor-&gt;TargetDataReadyDelegate.AddUObject(const_cast&lt;UAbilityTask_WaitTargetData*&gt;(this), &amp;UAbilityTask_WaitTargetData::OnTargetDataReadyCallback);</span><br><span class="line">    SpawnedActor-&gt;CanceledDelegate.AddUObject(const_cast&lt;UAbilityTask_WaitTargetData*&gt;(this), &amp;UAbilityTask_WaitTargetData::OnTargetDataCancelledCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_WaitTargetData::FinalizeTargetActor(AGameplayAbilityTargetActor* SpawnedActor) const</span><br><span class="line">&#123;</span><br><span class="line">    check(SpawnedActor);</span><br><span class="line">    check(Ability);</span><br><span class="line"></span><br><span class="line">    if (UAbilitySystemComponent* ASC = AbilitySystemComponent.Get())</span><br><span class="line">    &#123;</span><br><span class="line">        // User ability activation is inhibited while this is active</span><br><span class="line">        ASC-&gt;SpawnedTargetActors.Push(SpawnedActor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SpawnedActor-&gt;StartTargeting(Ability);</span><br><span class="line"></span><br><span class="line">    if (SpawnedActor-&gt;ShouldProduceTargetData())</span><br><span class="line">    &#123;   </span><br><span class="line">        //不需要客户端提供信息的情况</span><br><span class="line">        </span><br><span class="line">        // If instant confirm, then stop targeting immediately.</span><br><span class="line">        // Note this is kind of bad: we should be able to just call a static func on the CDO to do this. </span><br><span class="line">        // But then we wouldn&#x27;t get to set ExposeOnSpawnParameters.</span><br><span class="line">        if (ConfirmationType == EGameplayTargetingConfirmation::Instant)</span><br><span class="line">        &#123;</span><br><span class="line">            SpawnedActor-&gt;ConfirmTargeting();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (ConfirmationType == EGameplayTargetingConfirmation::UserConfirmed)</span><br><span class="line">        &#123;</span><br><span class="line">            // Bind to the Cancel/Confirm Delegates (called from local confirm or from repped confirm)</span><br><span class="line">            SpawnedActor-&gt;BindToConfirmCancelInputs();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_WaitTargetData::RegisterTargetDataCallbacks()</span><br><span class="line">&#123;</span><br><span class="line">    if (!ensure(IsValid(this)))</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UAbilitySystemComponent* ASC = AbilitySystemComponent.Get();</span><br><span class="line">    if (!ASC)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    check(TargetClass);</span><br><span class="line">    check(Ability);</span><br><span class="line"></span><br><span class="line">    const AGameplayAbilityTargetActor* CDO = CastChecked&lt;AGameplayAbilityTargetActor&gt;(TargetClass-&gt;GetDefaultObject());</span><br><span class="line"></span><br><span class="line">    const bool bIsLocallyControlled = Ability-&gt;GetCurrentActorInfo()-&gt;IsLocallyControlled();</span><br><span class="line">    const bool bShouldProduceTargetDataOnServer = CDO-&gt;ShouldProduceTargetDataOnServer;</span><br><span class="line"></span><br><span class="line">    // If not locally controlled (server for remote client), see if TargetData was already sent</span><br><span class="line">    // else register callback for when it does get here.</span><br><span class="line">    if (!bIsLocallyControlled)</span><br><span class="line">    &#123;</span><br><span class="line">        // Register with the TargetData callbacks if we are expecting client to send them</span><br><span class="line">        if (!bShouldProduceTargetDataOnServer)</span><br><span class="line">        &#123;</span><br><span class="line">            //服务器，且依赖于客户端传输TargetData</span><br><span class="line"></span><br><span class="line">            FGameplayAbilitySpecHandle	SpecHandle = GetAbilitySpecHandle();</span><br><span class="line">            FPredictionKey ActivationPredictionKey = GetActivationPredictionKey();</span><br><span class="line">            </span><br><span class="line">            //进行回调注册</span><br><span class="line">            //Since multifire is supported, we still need to hook up the callbacks</span><br><span class="line">            ASC-&gt;AbilityTargetDataSetDelegate(SpecHandle, ActivationPredictionKey ).AddUObject(this, &amp;UAbilityTask_WaitTargetData::OnTargetDataReplicatedCallback);</span><br><span class="line">            ASC-&gt;AbilityTargetDataCancelledDelegate(SpecHandle, ActivationPredictionKey ).AddUObject(this, &amp;UAbilityTask_WaitTargetData::OnTargetDataReplicatedCancelledCallback);</span><br><span class="line"></span><br><span class="line">            //调用一次 如果数据已经准备好，会直接触发</span><br><span class="line">            ASC-&gt;CallReplicatedTargetDataDelegatesIfSet(SpecHandle, ActivationPredictionKey );</span><br><span class="line"></span><br><span class="line">            SetWaitingOnRemotePlayerData();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** Valid TargetData was replicated to use (we are server, was sent from client) */</span><br><span class="line">void UAbilityTask_WaitTargetData::OnTargetDataReplicatedCallback(const FGameplayAbilityTargetDataHandle&amp; Data, FGameplayTag ActivationTag)</span><br><span class="line">&#123;</span><br><span class="line">    FGameplayAbilityTargetDataHandle MutableData = Data;</span><br><span class="line"></span><br><span class="line">    if (UAbilitySystemComponent* ASC = AbilitySystemComponent.Get())</span><br><span class="line">    &#123;</span><br><span class="line">        ASC-&gt;ConsumeClientReplicatedTargetData(GetAbilitySpecHandle(), GetActivationPredictionKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** </span><br><span class="line">    *  Call into the TargetActor to sanitize/verify the data. If this returns false, we are rejecting</span><br><span class="line">    *	the replicated target data and will treat this as a cancel.</span><br><span class="line">    *	</span><br><span class="line">    *	This can also be used for bandwidth optimizations. OnReplicatedTargetDataReceived could do an actual</span><br><span class="line">    *	trace/check/whatever server side and use that data. So rather than having the client send that data</span><br><span class="line">    *	explicitly, the client is basically just sending a &#x27;confirm&#x27; and the server is now going to do the work</span><br><span class="line">    *	in OnReplicatedTargetDataReceived.</span><br><span class="line">    */</span><br><span class="line">    //调用OnReplicatedTargetDataReceived</span><br><span class="line">    if (TargetActor &amp;&amp; !TargetActor-&gt;OnReplicatedTargetDataReceived(MutableData))</span><br><span class="line">    &#123;</span><br><span class="line">        if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">        &#123;</span><br><span class="line">            Cancelled.Broadcast(MutableData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">        &#123;</span><br><span class="line">            ValidData.Broadcast(MutableData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ConfirmationType != EGameplayTargetingConfirmation::CustomMulti)</span><br><span class="line">    &#123;</span><br><span class="line">        EndTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** Client canceled this Targeting Task (we are the server) */</span><br><span class="line">void UAbilityTask_WaitTargetData::OnTargetDataReplicatedCancelledCallback()</span><br><span class="line">&#123;</span><br><span class="line">    if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">    &#123;</span><br><span class="line">        Cancelled.Broadcast(FGameplayAbilityTargetDataHandle());</span><br><span class="line">    &#125;</span><br><span class="line">    EndTask();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** The TargetActor we spawned locally has called back with valid target data */</span><br><span class="line">void UAbilityTask_WaitTargetData::OnTargetDataReadyCallback(const FGameplayAbilityTargetDataHandle&amp; Data)</span><br><span class="line">&#123;</span><br><span class="line">    UAbilitySystemComponent* ASC = AbilitySystemComponent.Get();</span><br><span class="line">    if (!Ability || !ASC)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //预测窗口</span><br><span class="line">    FScopedPredictionWindow	ScopedPrediction(ASC, ShouldReplicateDataToServer());</span><br><span class="line"></span><br><span class="line">    const FGameplayAbilityActorInfo* Info = Ability-&gt;GetCurrentActorInfo();</span><br><span class="line">    if (IsPredictingClient())</span><br><span class="line">    &#123;</span><br><span class="line">        if (!TargetActor-&gt;ShouldProduceTargetDataOnServer)</span><br><span class="line">        &#123;</span><br><span class="line">            FGameplayTag ApplicationTag; // Fixme: where would this be useful?</span><br><span class="line">            //发送数据给服务器</span><br><span class="line">            ASC-&gt;CallServerSetReplicatedTargetData(GetAbilitySpecHandle(), GetActivationPredictionKey(), Data, ApplicationTag, ASC-&gt;ScopedPredictionKey);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (ConfirmationType == EGameplayTargetingConfirmation::UserConfirmed)</span><br><span class="line">        &#123;</span><br><span class="line">            // We aren&#x27;t going to send the target data, but we will send a generic confirmed message.</span><br><span class="line">            ASC-&gt;ServerSetReplicatedEvent(EAbilityGenericReplicatedEvent::GenericConfirm, GetAbilitySpecHandle(), GetActivationPredictionKey(), ASC-&gt;ScopedPredictionKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">    &#123;</span><br><span class="line">        ValidData.Broadcast(Data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ConfirmationType != EGameplayTargetingConfirmation::CustomMulti)</span><br><span class="line">    &#123;</span><br><span class="line">        EndTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** The TargetActor we spawned locally has called back with a cancel event (they still include the &#x27;last/best&#x27; targetdata but the consumer of this may want to discard it) */</span><br><span class="line">void UAbilityTask_WaitTargetData::OnTargetDataCancelledCallback(const FGameplayAbilityTargetDataHandle&amp; Data)</span><br><span class="line">&#123;</span><br><span class="line">    UAbilitySystemComponent* ASC = AbilitySystemComponent.Get();</span><br><span class="line">    if (!ASC)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FScopedPredictionWindow ScopedPrediction(ASC, IsPredictingClient());</span><br><span class="line"></span><br><span class="line">    if (IsPredictingClient())</span><br><span class="line">    &#123;</span><br><span class="line">        if (!TargetActor-&gt;ShouldProduceTargetDataOnServer)</span><br><span class="line">        &#123;</span><br><span class="line">            ASC-&gt;ServerSetReplicatedTargetDataCancelled(GetAbilitySpecHandle(), GetActivationPredictionKey(), ASC-&gt;ScopedPredictionKey );</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            // We aren&#x27;t going to send the target data, but we will send a generic confirmed message.</span><br><span class="line">            ASC-&gt;ServerSetReplicatedEvent(EAbilityGenericReplicatedEvent::GenericCancel, GetAbilitySpecHandle(), GetActivationPredictionKey(), ASC-&gt;ScopedPredictionKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Cancelled.Broadcast(Data);</span><br><span class="line">    EndTask();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** Called when the ability is asked to confirm from an outside node. What this means depends on the individual task. By default, this does nothing other than ending if bEndTask is true. */</span><br><span class="line">void UAbilityTask_WaitTargetData::ExternalConfirm(bool bEndTask)</span><br><span class="line">&#123;</span><br><span class="line">    if (TargetActor)</span><br><span class="line">    &#123;</span><br><span class="line">        if (TargetActor-&gt;ShouldProduceTargetData())</span><br><span class="line">        &#123;</span><br><span class="line">            TargetActor-&gt;ConfirmTargetingAndContinue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Super::ExternalConfirm(bEndTask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** Called when the ability is asked to confirm from an outside node. What this means depends on the individual task. By default, this does nothing other than ending if bEndTask is true. */</span><br><span class="line">void UAbilityTask_WaitTargetData::ExternalCancel()</span><br><span class="line">&#123;</span><br><span class="line">    if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">    &#123;</span><br><span class="line">        Cancelled.Broadcast(FGameplayAbilityTargetDataHandle());</span><br><span class="line">    &#125;</span><br><span class="line">    Super::ExternalCancel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_WaitTargetData::OnDestroy(bool AbilityEnded)</span><br><span class="line">&#123;</span><br><span class="line">    if (TargetActor)</span><br><span class="line">    &#123;</span><br><span class="line">        TargetActor-&gt;Destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Super::OnDestroy(AbilityEnded);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool UAbilityTask_WaitTargetData::ShouldReplicateDataToServer() const</span><br><span class="line">&#123;</span><br><span class="line">    if (!Ability || !TargetActor)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Send TargetData to the server IFF we are the client and this isn&#x27;t a GameplayTargetActor that can produce data on the server	</span><br><span class="line">    const FGameplayAbilityActorInfo* Info = Ability-&gt;GetCurrentActorInfo();</span><br><span class="line">    if (!Info-&gt;IsNetAuthority() &amp;&amp; !TargetActor-&gt;ShouldProduceTargetDataOnServer)</span><br><span class="line">    &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// --------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://MikeMing126.github.io">Ming</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mikeming126.github.io/UE/Project/Lyra/UE55Lyra3/">https://mikeming126.github.io/UE/Project/Lyra/UE55Lyra3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://MikeMing126.github.io" target="_blank">Ming Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/UE/">UE</a><a class="post-meta__tags" href="/tags/GAS/">GAS</a><a class="post-meta__tags" href="/tags/Lyra/">Lyra</a></div><div class="post-share"><div class="social-share" data-image="/img/head.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/UE/Project/Lyra/UE55Lyra2/" title="UE5.5-Lyra-2-GE"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">UE5.5-Lyra-2-GE</div></div><div class="info-2"><div class="info-item-1">GE蓝图创建的GE。基于 GameplayEffectParent_Damage_Basic 来看GE:  Gameplay效果 组件 GEComponents 包含很多个效果 可以在编辑器中细看   修饰符 Modifiers 执行 Executions   Gameplay Cue  GE的执行流程以GA的ApplyCost为例子： GA:ApplyGameplayEffectToOwner↓GA:ApplyGameplayEffectSpecToOwner↓ASC:ApplyGameplayEffectSpecToSelf 到这里可以分为两条路线了，一条是即刻执行的GE，Instant类型。第二种是有持续时间的GE（包括永久）。对于后者，会生成FActiveGameplayEffect。 在ASC:ApplyGameplayEffectSpecToSelf中就有两个关键函数了：  持续类型的 由ASC的FActiveGameplayEffectContainer调用ApplyGameplayEffectSpec处理 Intant类型...</div></div></div></a><a class="pagination-related" href="/UE/Project/Lyra/UE55Lyra4/" title="UE5.5-Lyra-4-GATask-AGameplayAbilityTargetActor"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">UE5.5-Lyra-4-GATask-AGameplayAbilityTargetActor</div></div><div class="info-2"><div class="info-item-1">中间数据 GameplayAbilityTargetActor关于目标数据 以下是几个比较关键的类。AGameplayAbilityTargetActor委托：FAbilityTargetDataFGameplayAbilityTargetDataHandleFGameplayAbilityTargetDataFGameplayEffectContextHandleFGameplayEffectContext 总体上还是比较复杂的。从源码看起。 AGameplayAbilityTargetActor/** * TargetActors are spawned to assist with ability targeting. They are spawned by ability tasks and create/determine the outgoing targeting data passed from one task to another * * WARNING: These actors are spawned once per ability...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/UE/GAS/UE55GASGC/" title="UE5.5-GameplayCue"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-08</div><div class="info-item-2">UE5.5-GameplayCue</div></div><div class="info-2"><div class="info-item-1">GameplayCue重要的类：GameplayCueSet 但是游戏中的资源加载并不是这样进行的。 映射关系： Tag -&gt; GC GC的收集过程：将GameplayCue资产放在指定的目录下。具体的可以在.ini里面配置。以Lyra为例子   资源的加载：关键类为UAbilitySystemGlobals与UGameplayCueManager。可以看到GameplayCueManager里。 //UAbilitySystemGlobals部分//GameplayAbilitiesDeveloperSettings.h//注意宏里面Config的关键字/** Look in these paths for GameplayCueNotifies. These are your &quot;always loaded&quot; set. */UPROPERTY(Config, EditDefaultsOnly, Category=GameplayCue, meta =...</div></div></div></a><a class="pagination-related" href="/UE/Project/Lyra/UE55Lyra2/" title="UE5.5-Lyra-2-GE"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-23</div><div class="info-item-2">UE5.5-Lyra-2-GE</div></div><div class="info-2"><div class="info-item-1">GE蓝图创建的GE。基于 GameplayEffectParent_Damage_Basic 来看GE:  Gameplay效果 组件 GEComponents 包含很多个效果 可以在编辑器中细看   修饰符 Modifiers 执行 Executions   Gameplay Cue  GE的执行流程以GA的ApplyCost为例子： GA:ApplyGameplayEffectToOwner↓GA:ApplyGameplayEffectSpecToOwner↓ASC:ApplyGameplayEffectSpecToSelf 到这里可以分为两条路线了，一条是即刻执行的GE，Instant类型。第二种是有持续时间的GE（包括永久）。对于后者，会生成FActiveGameplayEffect。 在ASC:ApplyGameplayEffectSpecToSelf中就有两个关键函数了：  持续类型的 由ASC的FActiveGameplayEffectContainer调用ApplyGameplayEffectSpec处理 Intant类型...</div></div></div></a><a class="pagination-related" href="/UE/Project/Lyra/UE55Lyra1/" title="UE5.5-Lyra-1-Attribute"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-16</div><div class="info-item-2">UE5.5-Lyra-1-Attribute</div></div><div class="info-2"><div class="info-item-1">基于官方Lyra的GAS学习。 综述首先就是ASC的位置。Lyra项目将ASC放置于了LyraPlayerState中。将ASC与PlayerState绑定。 此外 可以看到LyraCharacter。其也有获取ASC的接口。 从LyraCharacter获取ASC组件，依赖于其PawnExtComponent。这里可以看到ULyraPawnExtensionComponent这个类。该类会存放一个ASC指针。在函数InitializeAbilitySystem中进行设置。 LyraHeroComponent是唯一调用该方法的组件。见ULyraHeroComponent::HandleChangeInitState。这里的逻辑也是从PlayerState中拿到ASC，然后赋值给PawnExtComponent。 总而言之，该项目的ASC位于PlayerState。整体的链条大概如下：PlayerState -&gt; LyraHeroComp -&gt; PawnExtComponent -&gt; LyraCharacter。 再整理一下： LyraCharacter -...</div></div></div></a><a class="pagination-related" href="/UE/Project/Lyra/UE55Lyra5/" title="UE5.5-Lyra-5-GATask-传输数据流程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">UE5.5-Lyra-5-GATask-传输数据流程</div></div><div class="info-2"><div class="info-item-1">GATask_WaitTargetData以WaitTargetData为例子理解TargetActor的使用流程和逻辑 客户端传输数据情况Client侧p1  p2  p3  Server侧p4  p5   服务端自己产生数据情况这里以对应AGameplayAbilityTargetActor_Radius作为例子p6 </div></div></div></a><a class="pagination-related" href="/UE/Project/Lyra/UE55Lyra6/" title="UE5.5-Lyra-6-MeleeAttack"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-06</div><div class="info-item-2">UE5.5-Lyra-6-MeleeAttack</div></div><div class="info-2"><div class="info-item-1">学习目标：近战攻击的实现和检测这里还是以Lyra的近战攻击行为GA_Melee作为样例来学习。同时参考项目ActionRPG。ActionRPG本来是虚幻4的项目，网上有UE5的适配版本。以此作为学习的样本。不过，GAS在虚幻4到虚幻5之间还是有较大的改动的。学习的时候还是多想想，多看看。 前言和方法GATask的静态工厂函数并不会直接在蓝图中调用。（Rider）里面可以看到显示为“没有蓝图用法”。而是会走蓝图的包一层去实现。正如宏里面meta声明的BlueprintInternalUseOnly = &quot;TRUE&quot;一样。 要搜索蓝图中的用法 可以在编辑器中使用Tools -&gt; Find in Blueprints来查找对应的应用方法。 要查找资产引用，可以右键对应的资产，看到ReferenceViewer。 GATask_PlayMontageAndWait首先还是看到蒙太奇的播放 PlayMontageAndWait源码DECLARE_DYNAMIC_MULTICAST_DELEGATE(FMontageWaitSimpleDelegate);/**...</div></div></div></a><a class="pagination-related" href="/UE/Project/Lyra/UE55Lyra8/" title="UE5.5-Lyra-8-Shooting"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-16</div><div class="info-item-2">UE5.5-Lyra-8-Shooting</div></div><div class="info-2"><div class="info-item-1">主要分析Lyra项目射击的完整流程。 前言深入分析的时候，GAS的调试工具就很重要了。可以参考官方GAS插件目录下的Readme文件。 命令行 &#96;基础调试命令启用GAS调试 - ShowDebug AbilitySystem 切换目录 - AbilitySystem.Debug.NextCategory Lyra射击分析主要GA分析类继承图以手枪射击为例子GA_Weapon_Fire_Pistol↑GA_Weapon_Fire↑ULyraGameplayAbility_RangedWeapon↑ULyraGameplayAbility_FromEquipment↑ULyraGameplayAbility 分析从ActivateAbility来看。逻辑处理函数:  (Locally Controlled判定) - StartRangedWeaponTargeting  表现处理函数：  播放蒙太奇异步任务...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Ming</div><div class="author-info-description">我们都在奔赴各自的人生，但你依旧是你</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#GamplayAbilityTask"><span class="toc-number">1.</span> <span class="toc-text">GamplayAbilityTask</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80AbilityTask"><span class="toc-number">1.1.</span> <span class="toc-text">基础AbilityTask</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E9%80%BB%E8%BE%91"><span class="toc-number">1.1.1.</span> <span class="toc-text">基础逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WaitOverlap"><span class="toc-number">1.1.2.</span> <span class="toc-text">WaitOverlap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpawnActor%E7%B1%BB%E5%9E%8B%E7%9A%84AbilityTask"><span class="toc-number">1.2.</span> <span class="toc-text">SpawnActor类型的AbilityTask</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SpawnActor"><span class="toc-number">1.2.1.</span> <span class="toc-text">SpawnActor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WaitTargetData"><span class="toc-number">1.2.2.</span> <span class="toc-text">WaitTargetData</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/PostProcessing/" title="Unity PostProcessing">Unity PostProcessing</a><time datetime="2025-10-05T09:10:14.356Z" title="发表于 2025-10-05 17:10:14">2025-10-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/Shadow/" title="Unity Shadow">Unity Shadow</a><time datetime="2025-10-05T07:56:07.434Z" title="发表于 2025-10-05 15:56:07">2025-10-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/SRP/" title="Unity SRP">Unity SRP</a><time datetime="2025-10-02T06:15:27.265Z" title="发表于 2025-10-02 14:15:27">2025-10-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/AsyncOp/" title="Unity异步操作">Unity异步操作</a><time datetime="2025-09-14T08:01:59.349Z" title="发表于 2025-09-14 16:01:59">2025-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/Physics/" title="Unity Physics">Unity Physics</a><time datetime="2025-09-14T08:01:59.345Z" title="发表于 2025-09-14 16:01:59">2025-09-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/starBg2.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2025 - 2026 By Ming</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23liMdTJDdBPikGC2F',
      clientSecret: 'eed0ab3cb8494f9e22f7a8bb469c58cc7e6fbaea',
      repo: 'BlogComment',
      owner: 'MikeMing126',
      admin: ['MikeMing126'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'd9add7111ef0c843a191901b44391974'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script src="/script/APlayerHolder.js"></script><div class="aplayer" data-id="13402811242" data-server="netease" data-type="playlist" data-fixed="true" data-loop="all" data-autoplay="true" data-order="random" data-theme="#3F51B5"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>