<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>UE5.5-Lyra-6-MeleeAttack | Ming Blog</title><meta name="author" content="Ming"><meta name="copyright" content="Ming"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="学习目标：近战攻击的实现和检测这里还是以Lyra的近战攻击行为GA_Melee作为样例来学习。同时参考项目ActionRPG。ActionRPG本来是虚幻4的项目，网上有UE5的适配版本。以此作为学习的样本。不过，GAS在虚幻4到虚幻5之间还是有较大的改动的。学习的时候还是多想想，多看看。 前言和方法GATask的静态工厂函数并不会直接在蓝图中调用。（Rider）里面可以看到显示为“没有蓝图用法”">
<meta property="og:type" content="article">
<meta property="og:title" content="UE5.5-Lyra-6-MeleeAttack">
<meta property="og:url" content="https://mikeming126.github.io/UE/Project/Lyra/UE55Lyra6/index.html">
<meta property="og:site_name" content="Ming Blog">
<meta property="og:description" content="学习目标：近战攻击的实现和检测这里还是以Lyra的近战攻击行为GA_Melee作为样例来学习。同时参考项目ActionRPG。ActionRPG本来是虚幻4的项目，网上有UE5的适配版本。以此作为学习的样本。不过，GAS在虚幻4到虚幻5之间还是有较大的改动的。学习的时候还是多想想，多看看。 前言和方法GATask的静态工厂函数并不会直接在蓝图中调用。（Rider）里面可以看到显示为“没有蓝图用法”">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mikeming126.github.io/img/head.png">
<meta property="article:published_time" content="2025-04-06T07:24:18.074Z">
<meta property="article:modified_time" content="2025-04-15T14:46:23.514Z">
<meta property="article:author" content="Ming">
<meta property="article:tag" content="UE">
<meta property="article:tag" content="GAS">
<meta property="article:tag" content="Lyra">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mikeming126.github.io/img/head.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "UE5.5-Lyra-6-MeleeAttack",
  "url": "https://mikeming126.github.io/UE/Project/Lyra/UE55Lyra6/",
  "image": "https://mikeming126.github.io/img/head.png",
  "datePublished": "2025-04-06T07:24:18.074Z",
  "dateModified": "2025-04-15T14:46:23.514Z",
  "author": [
    {
      "@type": "Person",
      "name": "Ming",
      "url": "https://mikeming126.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://mikeming126.github.io/UE/Project/Lyra/UE55Lyra6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":4,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'UE5.5-Lyra-6-MeleeAttack',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/starBg2.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/starBg2.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Ming Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">UE5.5-Lyra-6-MeleeAttack</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">UE5.5-Lyra-6-MeleeAttack</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-06T07:24:18.074Z" title="发表于 2025-04-06 15:24:18">2025-04-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-15T14:46:23.514Z" title="更新于 2025-04-15 22:46:23">2025-04-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/UE/">UE</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">5.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>学习目标：<br>近战攻击的实现和检测<br>这里还是以Lyra的近战攻击行为GA_Melee作为样例来学习。<br>同时参考项目ActionRPG。<br>ActionRPG本来是虚幻4的项目，网上有UE5的适配版本。以此作为学习的样本。不过，GAS在虚幻4到虚幻5之间还是有较大的改动的。学习的时候还是多想想，多看看。</p>
<h1 id="前言和方法"><a href="#前言和方法" class="headerlink" title="前言和方法"></a>前言和方法</h1><p>GATask的静态工厂函数并不会直接在蓝图中调用。（Rider）里面可以看到显示为“没有蓝图用法”。而是会走蓝图的包一层去实现。正如宏里面meta声明的<code>BlueprintInternalUseOnly = &quot;TRUE&quot;</code>一样。</p>
<p>要搜索蓝图中的用法 可以在编辑器中使用Tools -&gt; Find in Blueprints来查找对应的应用方法。</p>
<p>要查找资产引用，可以右键对应的资产，看到ReferenceViewer。</p>
<h1 id="GATask-PlayMontageAndWait"><a href="#GATask-PlayMontageAndWait" class="headerlink" title="GATask_PlayMontageAndWait"></a>GATask_PlayMontageAndWait</h1><p>首先还是看到蒙太奇的播放</p>
<h2 id="PlayMontageAndWait源码"><a href="#PlayMontageAndWait源码" class="headerlink" title="PlayMontageAndWait源码"></a>PlayMontageAndWait源码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">DECLARE_DYNAMIC_MULTICAST_DELEGATE(FMontageWaitSimpleDelegate);</span><br><span class="line"></span><br><span class="line">/** Ability task to simply play a montage. Many games will want to make a modified version of this task that looks for game-specific events */</span><br><span class="line">UCLASS()</span><br><span class="line">class GAMEPLAYABILITIES_API UAbilityTask_PlayMontageAndWait : public UAbilityTask</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FMontageWaitSimpleDelegate	OnCompleted;</span><br><span class="line"></span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FMontageWaitSimpleDelegate	OnBlendedIn;</span><br><span class="line"></span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FMontageWaitSimpleDelegate	OnBlendOut;</span><br><span class="line"></span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FMontageWaitSimpleDelegate	OnInterrupted;</span><br><span class="line"></span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FMontageWaitSimpleDelegate	OnCancelled;</span><br><span class="line"></span><br><span class="line">    UFUNCTION()</span><br><span class="line">    void OnMontageBlendedIn(UAnimMontage* Montage);</span><br><span class="line"></span><br><span class="line">    UFUNCTION()</span><br><span class="line">    void OnMontageBlendingOut(UAnimMontage* Montage, bool bInterrupted);</span><br><span class="line"></span><br><span class="line">    UE_DEPRECATED(5.3, &quot;Please use OnGameplayAbilityCancelled instead. This function naming implied the Montage was already interrupted (instead, we are about to interrupt it).&quot;)</span><br><span class="line">    UFUNCTION()</span><br><span class="line">    void OnMontageInterrupted();</span><br><span class="line"></span><br><span class="line">    /** Callback function for when the owning Gameplay Ability is cancelled */</span><br><span class="line">    UFUNCTION()</span><br><span class="line">    void OnGameplayAbilityCancelled();</span><br><span class="line"></span><br><span class="line">    UFUNCTION()</span><br><span class="line">    void OnMontageEnded(UAnimMontage* Montage, bool bInterrupted);</span><br><span class="line"></span><br><span class="line">    /** </span><br><span class="line">        * Start playing an animation montage on the avatar actor and wait for it to finish</span><br><span class="line">        * If StopWhenAbilityEnds is true, this montage will be aborted if the ability ends normally. It is always stopped when the ability is explicitly cancelled.</span><br><span class="line">        * On normal execution, OnBlendOut is called when the montage is blending out, and OnCompleted when it is completely done playing</span><br><span class="line">        * OnInterrupted is called if another montage overwrites this, and OnCancelled is called if the ability or task is cancelled</span><br><span class="line">        *</span><br><span class="line">        * @param TaskInstanceName Set to override the name of this task, for later querying</span><br><span class="line">        * @param MontageToPlay The montage to play on the character</span><br><span class="line">        * @param Rate Change to play the montage faster or slower</span><br><span class="line">        * @param StartSection If not empty, named montage section to start from</span><br><span class="line">        * @param bStopWhenAbilityEnds If true, this montage will be aborted if the ability ends normally. It is always stopped when the ability is explicitly cancelled</span><br><span class="line">        * @param AnimRootMotionTranslationScale Change to modify size of root motion or set to 0 to block it entirely</span><br><span class="line">        * @param StartTimeSeconds Starting time offset in montage, this will be overridden by StartSection if that is also set</span><br><span class="line">        * @param bAllowInterruptAfterBlendOut If true, you can receive OnInterrupted after an OnBlendOut started (otherwise OnInterrupted will not fire when interrupted, but you will not get OnComplete).</span><br><span class="line">        */</span><br><span class="line">    UFUNCTION(BlueprintCallable, Category=&quot;Ability|Tasks&quot;, meta = (DisplayName=&quot;PlayMontageAndWait&quot;,</span><br><span class="line">        HidePin = &quot;OwningAbility&quot;, DefaultToSelf = &quot;OwningAbility&quot;, BlueprintInternalUseOnly = &quot;TRUE&quot;))</span><br><span class="line">    static UAbilityTask_PlayMontageAndWait* CreatePlayMontageAndWaitProxy(UGameplayAbility* OwningAbility,</span><br><span class="line">        FName TaskInstanceName, UAnimMontage* MontageToPlay, float Rate = 1.f, FName StartSection = NAME_None, bool bStopWhenAbilityEnds = true, float AnimRootMotionTranslationScale = 1.f, float StartTimeSeconds = 0.f, bool bAllowInterruptAfterBlendOut = false);</span><br><span class="line"></span><br><span class="line">    virtual void Activate() override;</span><br><span class="line"></span><br><span class="line">    /** Called when the ability is asked to cancel from an outside node. What this means depends on the individual task. By default, this does nothing other than ending the task. */</span><br><span class="line">    virtual void ExternalCancel() override;</span><br><span class="line"></span><br><span class="line">    virtual FString GetDebugString() const override;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line"></span><br><span class="line">    virtual void OnDestroy(bool AbilityEnded) override;</span><br><span class="line"></span><br><span class="line">    /** Checks if the ability is playing a montage and stops that montage, returns true if a montage was stopped, false if not. */</span><br><span class="line">    bool StopPlayingMontage();</span><br><span class="line"></span><br><span class="line">    FOnMontageBlendedInEnded BlendedInDelegate;</span><br><span class="line">    FOnMontageBlendingOutStarted BlendingOutDelegate;</span><br><span class="line">    FOnMontageEnded MontageEndedDelegate;</span><br><span class="line">    FDelegateHandle InterruptedHandle;</span><br><span class="line"></span><br><span class="line">    UPROPERTY()</span><br><span class="line">    TObjectPtr&lt;UAnimMontage&gt; MontageToPlay;</span><br><span class="line"></span><br><span class="line">    UPROPERTY()</span><br><span class="line">    float Rate;</span><br><span class="line"></span><br><span class="line">    UPROPERTY()</span><br><span class="line">    FName StartSection;</span><br><span class="line"></span><br><span class="line">    UPROPERTY()</span><br><span class="line">    float AnimRootMotionTranslationScale;</span><br><span class="line"></span><br><span class="line">    UPROPERTY()</span><br><span class="line">    float StartTimeSeconds;</span><br><span class="line"></span><br><span class="line">    UPROPERTY()</span><br><span class="line">    bool bStopWhenAbilityEnds;</span><br><span class="line"></span><br><span class="line">    UPROPERTY()</span><br><span class="line">    bool bAllowInterruptAfterBlendOut;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include UE_INLINE_GENERATED_CPP_BY_NAME(AbilityTask_PlayMontageAndWait)</span><br><span class="line"></span><br><span class="line">static bool GUseAggressivePlayMontageAndWaitEndTask = true;</span><br><span class="line">static FAutoConsoleVariableRef CVarAggressivePlayMontageAndWaitEndTask(TEXT(&quot;AbilitySystem.PlayMontage.AggressiveEndTask&quot;), GUseAggressivePlayMontageAndWaitEndTask, TEXT(&quot;This should be set to true in order to avoid multiple callbacks off an AbilityTask_PlayMontageAndWait node&quot;));</span><br><span class="line"></span><br><span class="line">static bool GPlayMontageAndWaitFireInterruptOnAnimEndInterrupt = true;</span><br><span class="line">static FAutoConsoleVariableRef CVarPlayMontageAndWaitFireInterruptOnAnimEndInterrupt(TEXT(&quot;AbilitySystem.PlayMontage.FireInterruptOnAnimEndInterrupt&quot;), GPlayMontageAndWaitFireInterruptOnAnimEndInterrupt, TEXT(&quot;This is a fix that will cause AbilityTask_PlayMontageAndWait to fire its Interrupt event if the underlying AnimInstance ends in an interrupted&quot;));</span><br><span class="line"></span><br><span class="line">void UAbilityTask_PlayMontageAndWait::OnMontageBlendingOut(UAnimMontage* Montage, bool bInterrupted)</span><br><span class="line">&#123;</span><br><span class="line">    const bool bPlayingThisMontage = (Montage == MontageToPlay) &amp;&amp; Ability &amp;&amp; Ability-&gt;GetCurrentMontage() == MontageToPlay;</span><br><span class="line">    if (bPlayingThisMontage)</span><br><span class="line">    &#123;</span><br><span class="line">        // Reset AnimRootMotionTranslationScale</span><br><span class="line">        ACharacter* Character = Cast&lt;ACharacter&gt;(GetAvatarActor());</span><br><span class="line">        if (Character &amp;&amp; (Character-&gt;GetLocalRole() == ROLE_Authority ||</span><br><span class="line">                            (Character-&gt;GetLocalRole() == ROLE_AutonomousProxy &amp;&amp; Ability-&gt;GetNetExecutionPolicy() == EGameplayAbilityNetExecutionPolicy::LocalPredicted)))</span><br><span class="line">        &#123;</span><br><span class="line">            Character-&gt;SetAnimRootMotionTranslationScale(1.f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (bPlayingThisMontage &amp;&amp; (bInterrupted || !bAllowInterruptAfterBlendOut))</span><br><span class="line">    &#123;</span><br><span class="line">        if (UAbilitySystemComponent* ASC = AbilitySystemComponent.Get())</span><br><span class="line">        &#123;</span><br><span class="line">            ASC-&gt;ClearAnimatingAbility(Ability);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">    &#123;</span><br><span class="line">        if (bInterrupted)</span><br><span class="line">        &#123;</span><br><span class="line">            bAllowInterruptAfterBlendOut = false;</span><br><span class="line">            OnInterrupted.Broadcast();</span><br><span class="line"></span><br><span class="line">            if (GUseAggressivePlayMontageAndWaitEndTask)</span><br><span class="line">            &#123;</span><br><span class="line">                EndTask();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            OnBlendOut.Broadcast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_PlayMontageAndWait::OnMontageBlendedIn(UAnimMontage* Montage)</span><br><span class="line">&#123;</span><br><span class="line">    if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">    &#123;</span><br><span class="line">        OnBlendedIn.Broadcast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_PlayMontageAndWait::OnMontageInterrupted()</span><br><span class="line">&#123;</span><br><span class="line">    // Call the new function</span><br><span class="line">    OnGameplayAbilityCancelled();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_PlayMontageAndWait::OnGameplayAbilityCancelled()</span><br><span class="line">&#123;</span><br><span class="line">    if (StopPlayingMontage() || bAllowInterruptAfterBlendOut)</span><br><span class="line">    &#123;</span><br><span class="line">        // Let the BP handle the interrupt as well</span><br><span class="line">        if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">        &#123;</span><br><span class="line">            bAllowInterruptAfterBlendOut = false;</span><br><span class="line">            OnInterrupted.Broadcast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (GUseAggressivePlayMontageAndWaitEndTask)</span><br><span class="line">    &#123;</span><br><span class="line">        EndTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_PlayMontageAndWait::OnMontageEnded(UAnimMontage* Montage, bool bInterrupted)</span><br><span class="line">&#123;</span><br><span class="line">    if (!bInterrupted)</span><br><span class="line">    &#123;</span><br><span class="line">        if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">        &#123;</span><br><span class="line">            OnCompleted.Broadcast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(bAllowInterruptAfterBlendOut &amp;&amp; GPlayMontageAndWaitFireInterruptOnAnimEndInterrupt)</span><br><span class="line">    &#123;</span><br><span class="line">        if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">        &#123;</span><br><span class="line">            OnInterrupted.Broadcast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EndTask();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UAbilityTask_PlayMontageAndWait* UAbilityTask_PlayMontageAndWait::CreatePlayMontageAndWaitProxy(UGameplayAbility* OwningAbility,</span><br><span class="line">    FName TaskInstanceName, UAnimMontage *MontageToPlay, float Rate, FName StartSection, bool bStopWhenAbilityEnds, float AnimRootMotionTranslationScale, float StartTimeSeconds, bool bAllowInterruptAfterBlendOut)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    UAbilitySystemGlobals::NonShipping_ApplyGlobalAbilityScaler_Rate(Rate);</span><br><span class="line"></span><br><span class="line">    //创建对应的对象</span><br><span class="line">    UAbilityTask_PlayMontageAndWait* MyObj = NewAbilityTask&lt;UAbilityTask_PlayMontageAndWait&gt;(OwningAbility, TaskInstanceName);</span><br><span class="line">    //设置参数</span><br><span class="line">    MyObj-&gt;MontageToPlay = MontageToPlay;</span><br><span class="line">    MyObj-&gt;Rate = Rate;</span><br><span class="line">    MyObj-&gt;StartSection = StartSection;</span><br><span class="line">    MyObj-&gt;AnimRootMotionTranslationScale = AnimRootMotionTranslationScale;</span><br><span class="line">    MyObj-&gt;bStopWhenAbilityEnds = bStopWhenAbilityEnds;</span><br><span class="line">    MyObj-&gt;bAllowInterruptAfterBlendOut = bAllowInterruptAfterBlendOut;</span><br><span class="line">    MyObj-&gt;StartTimeSeconds = StartTimeSeconds;</span><br><span class="line"></span><br><span class="line">    return MyObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_PlayMontageAndWait::Activate()</span><br><span class="line">&#123;</span><br><span class="line">    if (Ability == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool bPlayedMontage = false;</span><br><span class="line"></span><br><span class="line">    if (UAbilitySystemComponent* ASC = AbilitySystemComponent.Get())</span><br><span class="line">    &#123;</span><br><span class="line">        const FGameplayAbilityActorInfo* ActorInfo = Ability-&gt;GetCurrentActorInfo();</span><br><span class="line">        //获取动画实例</span><br><span class="line">        //内部通过SkeletalMeshComponent来获取</span><br><span class="line">        UAnimInstance* AnimInstance = ActorInfo-&gt;GetAnimInstance();</span><br><span class="line">        if (AnimInstance != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            //使用ASC来播放蒙太奇 ASC内部处理网络复制与预测</span><br><span class="line">            //AnimInstance播放失败时返回值为0.f</span><br><span class="line">            if (ASC-&gt;PlayMontage(Ability, Ability-&gt;GetCurrentActivationInfo(), MontageToPlay, Rate, StartSection, StartTimeSeconds) &gt; 0.f)</span><br><span class="line">            &#123;</span><br><span class="line">                // Playing a montage could potentially fire off a callback into game code which could kill this ability! Early out if we are pending kill.</span><br><span class="line"></span><br><span class="line">                //确认当前有效性</span><br><span class="line">                if (ShouldBroadcastAbilityTaskDelegates() == false)</span><br><span class="line">                &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //相关事件的侦听注册</span><br><span class="line">                InterruptedHandle = Ability-&gt;OnGameplayAbilityCancelled.AddUObject(this, &amp;UAbilityTask_PlayMontageAndWait::OnGameplayAbilityCancelled);</span><br><span class="line"></span><br><span class="line">                BlendedInDelegate.BindUObject(this, &amp;UAbilityTask_PlayMontageAndWait::OnMontageBlendedIn);</span><br><span class="line">                AnimInstance-&gt;Montage_SetBlendedInDelegate(BlendedInDelegate, MontageToPlay);</span><br><span class="line"></span><br><span class="line">                BlendingOutDelegate.BindUObject(this, &amp;UAbilityTask_PlayMontageAndWait::OnMontageBlendingOut);</span><br><span class="line">                AnimInstance-&gt;Montage_SetBlendingOutDelegate(BlendingOutDelegate, MontageToPlay);</span><br><span class="line"></span><br><span class="line">                MontageEndedDelegate.BindUObject(this, &amp;UAbilityTask_PlayMontageAndWait::OnMontageEnded);</span><br><span class="line">                AnimInstance-&gt;Montage_SetEndDelegate(MontageEndedDelegate, MontageToPlay);</span><br><span class="line"></span><br><span class="line">                ACharacter* Character = Cast&lt;ACharacter&gt;(GetAvatarActor());</span><br><span class="line">                //服务端/本地客户端预测</span><br><span class="line">                if (Character &amp;&amp; (Character-&gt;GetLocalRole() == ROLE_Authority ||</span><br><span class="line">                                    (Character-&gt;GetLocalRole() == ROLE_AutonomousProxy &amp;&amp; Ability-&gt;GetNetExecutionPolicy() == EGameplayAbilityNetExecutionPolicy::LocalPredicted)))</span><br><span class="line">                &#123;</span><br><span class="line">                    //RootMotion参数设置</span><br><span class="line">                    Character-&gt;SetAnimRootMotionTranslationScale(AnimRootMotionTranslationScale);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                bPlayedMontage = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            ABILITY_LOG(Warning, TEXT(&quot;UAbilityTask_PlayMontageAndWait call to PlayMontage failed!&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        ABILITY_LOG(Warning, TEXT(&quot;UAbilityTask_PlayMontageAndWait called on invalid AbilitySystemComponent&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!bPlayedMontage)</span><br><span class="line">    &#123;</span><br><span class="line">        ABILITY_LOG(Warning, TEXT(&quot;UAbilityTask_PlayMontageAndWait called in Ability %s failed to play montage %s; Task Instance Name %s.&quot;), *Ability-&gt;GetName(), *GetNameSafe(MontageToPlay),*InstanceName.ToString());</span><br><span class="line">        if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">        &#123;</span><br><span class="line">            //播放不成功也是走Cancel</span><br><span class="line">            OnCancelled.Broadcast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //实体销毁时 由ASC终止GA</span><br><span class="line">    SetWaitingOnAvatar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_PlayMontageAndWait::ExternalCancel()</span><br><span class="line">&#123;</span><br><span class="line">    if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">    &#123;</span><br><span class="line">        OnCancelled.Broadcast();</span><br><span class="line">    &#125;</span><br><span class="line">    Super::ExternalCancel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_PlayMontageAndWait::OnDestroy(bool AbilityEnded)</span><br><span class="line">&#123;</span><br><span class="line">    // Note: Clearing montage end delegate isn&#x27;t necessary since its not a multicast and will be cleared when the next montage plays.</span><br><span class="line">    // (If we are destroyed, it will detect this and not do anything)</span><br><span class="line"></span><br><span class="line">    // This delegate, however, should be cleared as it is a multicast</span><br><span class="line">    if (Ability)</span><br><span class="line">    &#123;</span><br><span class="line">        //移除侦听</span><br><span class="line">        Ability-&gt;OnGameplayAbilityCancelled.Remove(InterruptedHandle);</span><br><span class="line">        if (AbilityEnded &amp;&amp; bStopWhenAbilityEnds)</span><br><span class="line">        &#123;</span><br><span class="line">            StopPlayingMontage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Super::OnDestroy(AbilityEnded);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool UAbilityTask_PlayMontageAndWait::StopPlayingMontage()</span><br><span class="line">&#123;</span><br><span class="line">    if (Ability == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const FGameplayAbilityActorInfo* ActorInfo = Ability-&gt;GetCurrentActorInfo();</span><br><span class="line">    if (ActorInfo == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UAnimInstance* AnimInstance = ActorInfo-&gt;GetAnimInstance();</span><br><span class="line">    if (AnimInstance == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Check if the montage is still playing</span><br><span class="line">    // The ability would have been interrupted, in which case we should automatically stop the montage</span><br><span class="line">    UAbilitySystemComponent* ASC = AbilitySystemComponent.Get();</span><br><span class="line">    if (ASC &amp;&amp; Ability)</span><br><span class="line">    &#123;</span><br><span class="line">        if (ASC-&gt;GetAnimatingAbility() == Ability</span><br><span class="line">            &amp;&amp; ASC-&gt;GetCurrentMontage() == MontageToPlay)</span><br><span class="line">        &#123;</span><br><span class="line">            // Unbind delegates so they don&#x27;t get called as well</span><br><span class="line">            FAnimMontageInstance* MontageInstance = AnimInstance-&gt;GetActiveInstanceForMontage(MontageToPlay);</span><br><span class="line">            if (MontageInstance)</span><br><span class="line">            &#123;</span><br><span class="line">                //解除委托绑定</span><br><span class="line">                //这里的这些委托，并不是多播委托 而为单播委托</span><br><span class="line">                MontageInstance-&gt;OnMontageBlendedInEnded.Unbind();</span><br><span class="line">                MontageInstance-&gt;OnMontageBlendingOutStarted.Unbind();</span><br><span class="line">                MontageInstance-&gt;OnMontageEnded.Unbind();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //ASC调用处理蒙太奇停止</span><br><span class="line">            ASC-&gt;CurrentMontageStop();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FString UAbilityTask_PlayMontageAndWait::GetDebugString() const</span><br><span class="line">&#123;</span><br><span class="line">    UAnimMontage* PlayingMontage = nullptr;</span><br><span class="line">    if (Ability)</span><br><span class="line">    &#123;</span><br><span class="line">        const FGameplayAbilityActorInfo* ActorInfo = Ability-&gt;GetCurrentActorInfo();</span><br><span class="line">        UAnimInstance* AnimInstance = ActorInfo-&gt;GetAnimInstance();</span><br><span class="line"></span><br><span class="line">        if (AnimInstance != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            PlayingMontage = AnimInstance-&gt;Montage_IsActive(MontageToPlay) ? ToRawPtr(MontageToPlay) : AnimInstance-&gt;GetCurrentActiveMontage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return FString::Printf(TEXT(&quot;PlayMontageAndWait. MontageToPlay: %s  (Currently Playing): %s&quot;), *GetNameSafe(MontageToPlay), *GetNameSafe(PlayingMontage));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="补充源码"><a href="#补充源码" class="headerlink" title="补充源码"></a>补充源码</h2><h3 id="ASC的PlayMontage"><a href="#ASC的PlayMontage" class="headerlink" title="ASC的PlayMontage"></a>ASC的PlayMontage</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">float UAbilitySystemComponent::PlayMontage(UGameplayAbility* InAnimatingAbility, FGameplayAbilityActivationInfo ActivationInfo, UAnimMontage* NewAnimMontage, float InPlayRate, FName StartSectionName, float StartTimeSeconds)</span><br><span class="line">&#123;</span><br><span class="line">    float Duration = -1.f;</span><br><span class="line"></span><br><span class="line">    UAnimInstance* AnimInstance = AbilityActorInfo.IsValid() ? AbilityActorInfo-&gt;GetAnimInstance() : nullptr;</span><br><span class="line">    if (AnimInstance &amp;&amp; NewAnimMontage)</span><br><span class="line">    &#123;   </span><br><span class="line">        //执行蒙太奇播放</span><br><span class="line">        //客户端预测 &amp;&amp; 服务端执行</span><br><span class="line">        //播放失败时返回0.f</span><br><span class="line">        Duration = AnimInstance-&gt;Montage_Play(NewAnimMontage, InPlayRate, EMontagePlayReturnType::MontageLength, StartTimeSeconds);</span><br><span class="line">        if (Duration &gt; 0.f)</span><br><span class="line">        &#123;</span><br><span class="line">            if (const UGameplayAbility* RawAnimatingAbility = LocalAnimMontageInfo.AnimatingAbility.Get())</span><br><span class="line">            &#123;</span><br><span class="line">                if (RawAnimatingAbility != InAnimatingAbility)</span><br><span class="line">                &#123;</span><br><span class="line">                    // The ability that was previously animating will have already gotten the &#x27;interrupted&#x27; callback.</span><br><span class="line">                    // It may be a good idea to make this a global policy and &#x27;cancel&#x27; the ability.</span><br><span class="line">                    // </span><br><span class="line">                    // For now, we expect it to end itself when this happens.</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            UAnimSequenceBase* Animation = NewAnimMontage-&gt;IsDynamicMontage() ? NewAnimMontage-&gt;GetFirstAnimReference() : NewAnimMontage;</span><br><span class="line"></span><br><span class="line">            if (NewAnimMontage-&gt;HasRootMotion() &amp;&amp; AnimInstance-&gt;GetOwningActor())</span><br><span class="line">            &#123;</span><br><span class="line">                UE_LOG(LogRootMotion, Log, TEXT(&quot;UAbilitySystemComponent::PlayMontage %s, Role: %s&quot;)</span><br><span class="line">                    , *GetNameSafe(Animation)</span><br><span class="line">                    , *UEnum::GetValueAsString(TEXT(&quot;Engine.ENetRole&quot;), AnimInstance-&gt;GetOwningActor()-&gt;GetLocalRole())</span><br><span class="line">                    );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            LocalAnimMontageInfo.AnimMontage = NewAnimMontage;</span><br><span class="line">            LocalAnimMontageInfo.AnimatingAbility = InAnimatingAbility;</span><br><span class="line">            LocalAnimMontageInfo.PlayInstanceId = (LocalAnimMontageInfo.PlayInstanceId &lt; UINT8_MAX ? LocalAnimMontageInfo.PlayInstanceId + 1 : 0);</span><br><span class="line">            </span><br><span class="line">            //设置GA当前播放的蒙太奇信息</span><br><span class="line">            if (InAnimatingAbility)</span><br><span class="line">            &#123;</span><br><span class="line">                InAnimatingAbility-&gt;SetCurrentMontage(NewAnimMontage);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // Start at a given Section.</span><br><span class="line">            if (StartSectionName != NAME_None)</span><br><span class="line">            &#123;</span><br><span class="line">                AnimInstance-&gt;Montage_JumpToSection(StartSectionName, NewAnimMontage);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //网络复制</span><br><span class="line">            // Replicate for non-owners and for replay recordings</span><br><span class="line">            // The data we set from GetRepAnimMontageInfo_Mutable() is used both by the server to replicate to clients and by clients to record replays.</span><br><span class="line">            // - 服务端广播以及客户端用于记录回放</span><br><span class="line">            // We need to set this data for recording clients because there exists network configurations where an abilities montage data will not replicate to some clients (for example: if the client is an autonomous proxy.)</span><br><span class="line">            //客户端自己是自主代理时。且需要回放</span><br><span class="line"></span><br><span class="line">            // Returns true IF the owner is authoritative OR the world is recording a replay.</span><br><span class="line">            //（服务端）||（客户端 - 回放时） 客户端非回放时不用考虑</span><br><span class="line">            if (ShouldRecordMontageReplication())</span><br><span class="line">            &#123;</span><br><span class="line">                FGameplayAbilityRepAnimMontage&amp; MutableRepAnimMontageInfo = GetRepAnimMontageInfo_Mutable();</span><br><span class="line"></span><br><span class="line">                // Those are static parameters, they are only set when the montage is played. They are not changed after that.</span><br><span class="line">                MutableRepAnimMontageInfo.Animation = Animation;</span><br><span class="line">                MutableRepAnimMontageInfo.PlayInstanceId = (MutableRepAnimMontageInfo.PlayInstanceId &lt; UINT8_MAX ? MutableRepAnimMontageInfo.PlayInstanceId + 1 : 0);</span><br><span class="line"></span><br><span class="line">                MutableRepAnimMontageInfo.SectionIdToPlay = 0;</span><br><span class="line">                if (MutableRepAnimMontageInfo.Animation &amp;&amp; StartSectionName != NAME_None)</span><br><span class="line">                &#123;</span><br><span class="line">                    // we add one so INDEX_NONE can be used in the on rep</span><br><span class="line">                    MutableRepAnimMontageInfo.SectionIdToPlay = NewAnimMontage-&gt;GetSectionIndex(StartSectionName) + 1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (NewAnimMontage-&gt;IsDynamicMontage())</span><br><span class="line">                &#123;</span><br><span class="line">                    check(!NewAnimMontage-&gt;SlotAnimTracks.IsEmpty());</span><br><span class="line">                    MutableRepAnimMontageInfo.SlotName = NewAnimMontage-&gt;SlotAnimTracks[0].SlotName;</span><br><span class="line">                    MutableRepAnimMontageInfo.BlendOutTime = NewAnimMontage-&gt;GetDefaultBlendInTime();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Update parameters that change during Montage life time.</span><br><span class="line">                AnimMontage_UpdateReplicatedData();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //服务端广播</span><br><span class="line">            // Replicate to non-owners</span><br><span class="line">            if (IsOwnerActorAuthoritative())</span><br><span class="line">            &#123;</span><br><span class="line">                // Force net update on our avatar actor.</span><br><span class="line">                if (AbilityActorInfo-&gt;AvatarActor != nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    AbilityActorInfo-&gt;AvatarActor-&gt;ForceNetUpdate();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                // If this prediction key is rejected, we need to end the preview</span><br><span class="line">                FPredictionKey PredictionKey = GetPredictionKeyForNewAction();</span><br><span class="line">                if (PredictionKey.IsValidKey())</span><br><span class="line">                &#123;</span><br><span class="line">                    //注册回调</span><br><span class="line">                    PredictionKey.NewRejectedDelegate().BindUObject(this, &amp;UAbilitySystemComponent::OnPredictiveMontageRejected, NewAnimMontage);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return Duration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Lyra的近战攻击检测"><a href="#Lyra的近战攻击检测" class="headerlink" title="Lyra的近战攻击检测"></a>Lyra的近战攻击检测</h1><p>Lyra的近战检测做的其实比较简单。<br>可以看到GA_Melee蓝图。</p>
<img src="/UE/Project/Lyra/UE55Lyra6/image-1.png" class="" title="alt text">  
<p>依据Authority - 控制仅在服务端进行伤害逻辑处理<br>碰撞检测方式 - Capsule碰撞检测[基于挂点socket和直线确定起点和终点]<br>在获取到应用对象后，服务端使用ApplyGameplayEffectToTarget来应用近战伤害效果。<br>从实现上看，Lyra的客户端并没有做伤害预测。表现上，客户端仅会预测播放蒙太奇。如果有目标，目标也不会有预测的受击效果（受击效果位于GE上而不是GA了）。<br>要等到服务端确认了，执行了对应的检测和GE应用逻辑，客户端才能看到对应的受击效果。</p>
<h1 id="ActionRPG的近战攻击检测"><a href="#ActionRPG的近战攻击检测" class="headerlink" title="ActionRPG的近战攻击检测"></a>ActionRPG的近战攻击检测</h1><p>ActionRPG中的近战攻击检测主要还是依赖于蒙太奇。</p>
<img src="/UE/Project/Lyra/UE55Lyra6/image-2.png" class="" title="alt text">
<h2 id="GA与GE应用"><a href="#GA与GE应用" class="headerlink" title="GA与GE应用"></a>GA与GE应用</h2><p>这部分还是可以研究一下：</p>
<h3 id="GA重写和重要函数"><a href="#GA重写和重要函数" class="headerlink" title="GA重写和重要函数"></a>GA重写和重要函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Subclass of ability blueprint type with game-specific data</span><br><span class="line"> * This class uses GameplayEffectContainers to allow easier execution of gameplay effects based on a triggering tag</span><br><span class="line"> * Most games will need to implement a subclass to support their game-specific code</span><br><span class="line"> */</span><br><span class="line">UCLASS()</span><br><span class="line">class ACTIONRPG_API URPGGameplayAbility : public UGameplayAbility</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line">public:</span><br><span class="line">    // Constructor and overrides</span><br><span class="line">    URPGGameplayAbility();</span><br><span class="line"></span><br><span class="line">    //GATags-&gt;GEContainer</span><br><span class="line">    //这里的GEContainer是单独声明的一个容器，非GAS系统自带的。</span><br><span class="line">    /** Map of gameplay tags to gameplay effect containers */</span><br><span class="line">    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = GameplayEffects)</span><br><span class="line">    TMap&lt;FGameplayTag, FRPGGameplayEffectContainer&gt; EffectContainerMap;</span><br><span class="line"></span><br><span class="line">    /** Make gameplay effect container spec to be applied later, using the passed in container */</span><br><span class="line">    UFUNCTION(BlueprintCallable, Category = Ability, meta=(AutoCreateRefTerm = &quot;EventData&quot;))</span><br><span class="line">    virtual FRPGGameplayEffectContainerSpec MakeEffectContainerSpecFromContainer(const FRPGGameplayEffectContainer&amp; Container, const FGameplayEventData&amp; EventData, int32 OverrideGameplayLevel = -1);</span><br><span class="line"></span><br><span class="line">    /** Search for and make a gameplay effect container spec to be applied later, from the EffectContainerMap */</span><br><span class="line">    UFUNCTION(BlueprintCallable, Category = Ability, meta = (AutoCreateRefTerm = &quot;EventData&quot;))</span><br><span class="line">    virtual FRPGGameplayEffectContainerSpec MakeEffectContainerSpec(FGameplayTag ContainerTag, const FGameplayEventData&amp; EventData, int32 OverrideGameplayLevel = -1);</span><br><span class="line"></span><br><span class="line">    /** Applies a gameplay effect container spec that was previously created */</span><br><span class="line">    UFUNCTION(BlueprintCallable, Category = Ability)</span><br><span class="line">    virtual TArray&lt;FActiveGameplayEffectHandle&gt; ApplyEffectContainerSpec(const FRPGGameplayEffectContainerSpec&amp; ContainerSpec);</span><br><span class="line"></span><br><span class="line">    /** Applies a gameplay effect container, by creating and then applying the spec */</span><br><span class="line">    UFUNCTION(BlueprintCallable, Category = Ability, meta = (AutoCreateRefTerm = &quot;EventData&quot;))</span><br><span class="line">    virtual TArray&lt;FActiveGameplayEffectHandle&gt; ApplyEffectContainer(FGameplayTag ContainerTag, const FGameplayEventData&amp; EventData, int32 OverrideGameplayLevel = -1);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">URPGGameplayAbility::URPGGameplayAbility() &#123;&#125;</span><br><span class="line"></span><br><span class="line">FRPGGameplayEffectContainerSpec URPGGameplayAbility::MakeEffectContainerSpecFromContainer(const FRPGGameplayEffectContainer&amp; Container, const FGameplayEventData&amp; EventData, int32 OverrideGameplayLevel)</span><br><span class="line">&#123;</span><br><span class="line">    // First figure out our actor info</span><br><span class="line">    FRPGGameplayEffectContainerSpec ReturnSpec;</span><br><span class="line">    AActor* OwningActor = GetOwningActorFromActorInfo();</span><br><span class="line">    ARPGCharacterBase* OwningCharacter = Cast&lt;ARPGCharacterBase&gt;(OwningActor);</span><br><span class="line">    URPGAbilitySystemComponent* OwningASC = URPGAbilitySystemComponent::GetAbilitySystemComponentFromActor(OwningActor);</span><br><span class="line"></span><br><span class="line">    if (OwningASC)</span><br><span class="line">    &#123;</span><br><span class="line">        // If we have a target type, run the targeting logic. This is optional, targets can be added later</span><br><span class="line">        if (Container.TargetType.Get())</span><br><span class="line">        &#123;</span><br><span class="line">            TArray&lt;FHitResult&gt; HitResults;</span><br><span class="line">            TArray&lt;AActor*&gt; TargetActors;</span><br><span class="line">            const URPGTargetType* TargetTypeCDO = Container.TargetType.GetDefaultObject();</span><br><span class="line">            AActor* AvatarActor = GetAvatarActorFromActorInfo();</span><br><span class="line">            TargetTypeCDO-&gt;GetTargets(OwningCharacter, AvatarActor, EventData, HitResults, TargetActors);</span><br><span class="line">            ReturnSpec.AddTargets(HitResults, TargetActors);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If we don&#x27;t have an override level, use the default on the ability itself</span><br><span class="line">        if (OverrideGameplayLevel == INDEX_NONE)</span><br><span class="line">        &#123;</span><br><span class="line">            OverrideGameplayLevel = OverrideGameplayLevel = this-&gt;GetAbilityLevel(); //OwningASC-&gt;GetDefaultAbilityLevel();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //创建GESpec</span><br><span class="line">        // Build GameplayEffectSpecs for each applied effect</span><br><span class="line">        for (const TSubclassOf&lt;UGameplayEffect&gt;&amp; EffectClass : Container.TargetGameplayEffectClasses)</span><br><span class="line">        &#123;</span><br><span class="line">            ReturnSpec.TargetGameplayEffectSpecs.Add(MakeOutgoingGameplayEffectSpec(EffectClass, OverrideGameplayLevel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ReturnSpec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FRPGGameplayEffectContainerSpec URPGGameplayAbility::MakeEffectContainerSpec(FGameplayTag ContainerTag, const FGameplayEventData&amp; EventData, int32 OverrideGameplayLevel)</span><br><span class="line">&#123;</span><br><span class="line">    FRPGGameplayEffectContainer* FoundContainer = EffectContainerMap.Find(ContainerTag);</span><br><span class="line"></span><br><span class="line">    if (FoundContainer)</span><br><span class="line">    &#123;</span><br><span class="line">        return MakeEffectContainerSpecFromContainer(*FoundContainer, EventData, OverrideGameplayLevel);</span><br><span class="line">    &#125;</span><br><span class="line">    return FRPGGameplayEffectContainerSpec();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TArray&lt;FActiveGameplayEffectHandle&gt; URPGGameplayAbility::ApplyEffectContainerSpec(const FRPGGameplayEffectContainerSpec&amp; ContainerSpec)</span><br><span class="line">&#123;</span><br><span class="line">    TArray&lt;FActiveGameplayEffectHandle&gt; AllEffects;</span><br><span class="line"></span><br><span class="line">    // Iterate list of effect specs and apply them to their target data</span><br><span class="line">    for (const FGameplayEffectSpecHandle&amp; SpecHandle : ContainerSpec.TargetGameplayEffectSpecs)</span><br><span class="line">    &#123;</span><br><span class="line">        AllEffects.Append(K2_ApplyGameplayEffectSpecToTarget(SpecHandle, ContainerSpec.TargetData));</span><br><span class="line">    &#125;</span><br><span class="line">    return AllEffects;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TArray&lt;FActiveGameplayEffectHandle&gt; URPGGameplayAbility::ApplyEffectContainer(FGameplayTag ContainerTag, const FGameplayEventData&amp; EventData, int32 OverrideGameplayLevel)</span><br><span class="line">&#123;</span><br><span class="line">    FRPGGameplayEffectContainerSpec Spec = MakeEffectContainerSpec(ContainerTag, EventData, OverrideGameplayLevel);</span><br><span class="line">    return ApplyEffectContainerSpec(Spec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="辅助类声明"><a href="#辅助类声明" class="headerlink" title="辅助类声明"></a>辅助类声明</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Struct defining a list of gameplay effects, a tag, and targeting info</span><br><span class="line"> * These containers are defined statically in blueprints or assets and then turn into Specs at runtime</span><br><span class="line"> */</span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line">struct FRPGGameplayEffectContainer</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line">public:</span><br><span class="line">    FRPGGameplayEffectContainer() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    /** Sets the way that targeting happens */</span><br><span class="line">    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = GameplayEffectContainer)</span><br><span class="line">    TSubclassOf&lt;URPGTargetType&gt; TargetType;</span><br><span class="line"></span><br><span class="line">    /** List of gameplay effects to apply to the targets */</span><br><span class="line">    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = GameplayEffectContainer)</span><br><span class="line">    TArray&lt;TSubclassOf&lt;UGameplayEffect&gt;&gt; TargetGameplayEffectClasses;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Class that is used to determine targeting for abilities</span><br><span class="line"> * It is meant to be blueprinted to run target logic</span><br><span class="line"> * This does not subclass GameplayAbilityTargetActor because this class is never instanced into the world</span><br><span class="line"> * This can be used as a basis for a game-specific targeting blueprint</span><br><span class="line"> * If your targeting is more complicated you may need to instance into the world once or as a pooled actor</span><br><span class="line"> */</span><br><span class="line">UCLASS(Blueprintable, meta = (ShowWorldContextPin))</span><br><span class="line">class ACTIONRPG_API URPGTargetType : public UObject</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line">public:</span><br><span class="line">    // Constructor and overrides</span><br><span class="line">    URPGTargetType() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    /** Called to determine targets to apply gameplay effects to */</span><br><span class="line">    UFUNCTION(BlueprintNativeEvent)</span><br><span class="line">    void GetTargets(ARPGCharacterBase* TargetingCharacter, AActor* TargetingActor, FGameplayEventData EventData, TArray&lt;FHitResult&gt;&amp; OutHitResults, TArray&lt;AActor*&gt;&amp; OutActors) const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/** Trivial target type that uses the owner */</span><br><span class="line">UCLASS(NotBlueprintable)</span><br><span class="line">class ACTIONRPG_API URPGTargetType_UseOwner : public URPGTargetType</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line">public:</span><br><span class="line">    // Constructor and overrides</span><br><span class="line">    URPGTargetType_UseOwner() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    /** Uses the passed in event data */</span><br><span class="line">    virtual void GetTargets_Implementation(ARPGCharacterBase* TargetingCharacter, AActor* TargetingActor, FGameplayEventData EventData, TArray&lt;FHitResult&gt;&amp; OutHitResults, TArray&lt;AActor*&gt;&amp; OutActors) const override;</span><br><span class="line"></span><br><span class="line">    //cpp实现逻辑</span><br><span class="line">    void URPGTargetType_UseOwner::GetTargets_Implementation(ARPGCharacterBase* TargetingCharacter, AActor* TargetingActor, FGameplayEventData EventData, TArray&lt;FHitResult&gt;&amp; OutHitResults, TArray&lt;AActor*&gt;&amp; OutActors) const</span><br><span class="line">    &#123;</span><br><span class="line">        OutActors.Add(TargetingCharacter);</span><br><span class="line">    &#125;</span><br><span class="line">    //</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/** Trivial target type that pulls the target out of the event data */</span><br><span class="line">UCLASS(NotBlueprintable)</span><br><span class="line">class ACTIONRPG_API URPGTargetType_UseEventData : public URPGTargetType</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line">public:</span><br><span class="line">    // Constructor and overrides</span><br><span class="line">    URPGTargetType_UseEventData() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    /** Uses the passed in event data */</span><br><span class="line">    virtual void GetTargets_Implementation(ARPGCharacterBase* TargetingCharacter, AActor* TargetingActor, FGameplayEventData EventData, TArray&lt;FHitResult&gt;&amp; OutHitResults, TArray&lt;AActor*&gt;&amp; OutActors) const override;</span><br><span class="line"></span><br><span class="line">    //cpp实现逻辑：</span><br><span class="line">    void URPGTargetType_UseEventData::GetTargets_Implementation(ARPGCharacterBase* TargetingCharacter, AActor* TargetingActor, FGameplayEventData EventData, TArray&lt;FHitResult&gt;&amp; OutHitResults, TArray&lt;AActor*&gt;&amp; OutActors) const</span><br><span class="line">    &#123;</span><br><span class="line">        const FHitResult* FoundHitResult = EventData.ContextHandle.GetHitResult();</span><br><span class="line">        if (FoundHitResult)</span><br><span class="line">        &#123;</span><br><span class="line">            OutHitResults.Add(*FoundHitResult);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (EventData.Target)</span><br><span class="line">        &#123;</span><br><span class="line">            //OutActors.Add(const_cast&lt;AActor*&gt;(EventData.Target));</span><br><span class="line">            OutActors.Add(const_cast&lt;AActor*&gt;(ToRawPtr(EventData.Target)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>主要是用Tag来映射对应的GEList。一个GA可以通过不同的Tag来应用不同的GEList。中间的函数会帮助确定GE的应用对象（Target），并创建对应的GESpec来处理GE应用逻辑。</p>
<h2 id="目标筛选与Tag"><a href="#目标筛选与Tag" class="headerlink" title="目标筛选与Tag"></a>目标筛选与Tag</h2><h3 id="PlayMontageAndWaitForEvent"><a href="#PlayMontageAndWaitForEvent" class="headerlink" title="PlayMontageAndWaitForEvent"></a>PlayMontageAndWaitForEvent</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class URPGAbilitySystemComponent;</span><br><span class="line"></span><br><span class="line">/** Delegate type used, EventTag and Payload may be empty if it came from the montage callbacks */</span><br><span class="line">DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FRPGPlayMontageAndWaitForEventDelegate, FGameplayTag, EventTag, FGameplayEventData, EventData);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * This task combines PlayMontageAndWait and WaitForEvent into one task, so you can wait for multiple types of activations such as from a melee combo</span><br><span class="line"> * Much of this code is copied from one of those two ability tasks</span><br><span class="line"> * This is a good task to look at as an example when creating game-specific tasks</span><br><span class="line"> * It is expected that each game will have a set of game-specific tasks to do what they want</span><br><span class="line"> */</span><br><span class="line">UCLASS()</span><br><span class="line">class ACTIONRPG_API URPGAbilityTask_PlayMontageAndWaitForEvent : public UAbilityTask</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line">public:</span><br><span class="line">    // Constructor and overrides</span><br><span class="line">    URPGAbilityTask_PlayMontageAndWaitForEvent(const FObjectInitializer&amp; ObjectInitializer);</span><br><span class="line">    virtual void Activate() override;</span><br><span class="line">    virtual void ExternalCancel() override;</span><br><span class="line">    virtual FString GetDebugString() const override;</span><br><span class="line">    virtual void OnDestroy(bool AbilityEnded) override;</span><br><span class="line"></span><br><span class="line">    /** The montage completely finished playing */</span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FRPGPlayMontageAndWaitForEventDelegate OnCompleted;</span><br><span class="line"></span><br><span class="line">    /** The montage started blending out */</span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FRPGPlayMontageAndWaitForEventDelegate OnBlendOut;</span><br><span class="line"></span><br><span class="line">    /** The montage was interrupted */</span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FRPGPlayMontageAndWaitForEventDelegate OnInterrupted;</span><br><span class="line"></span><br><span class="line">    /** The ability task was explicitly cancelled by another ability */</span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FRPGPlayMontageAndWaitForEventDelegate OnCancelled;</span><br><span class="line"></span><br><span class="line">    /** One of the triggering gameplay events happened */</span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FRPGPlayMontageAndWaitForEventDelegate EventReceived;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        * Play a montage and wait for it end. If a gameplay event happens that matches EventTags (or EventTags is empty), the EventReceived delegate will fire with a tag and event data.</span><br><span class="line">        * If StopWhenAbilityEnds is true, this montage will be aborted if the ability ends normally. It is always stopped when the ability is explicitly cancelled.</span><br><span class="line">        * On normal execution, OnBlendOut is called when the montage is blending out, and OnCompleted when it is completely done playing</span><br><span class="line">        * OnInterrupted is called if another montage overwrites this, and OnCancelled is called if the ability or task is cancelled</span><br><span class="line">        *</span><br><span class="line">        * @param TaskInstanceName Set to override the name of this task, for later querying</span><br><span class="line">        * @param MontageToPlay The montage to play on the character</span><br><span class="line">        * @param EventTags Any gameplay events matching this tag will activate the EventReceived callback. If empty, all events will trigger callback</span><br><span class="line">        * @param Rate Change to play the montage faster or slower</span><br><span class="line">        * @param bStopWhenAbilityEnds If true, this montage will be aborted if the ability ends normally. It is always stopped when the ability is explicitly cancelled</span><br><span class="line">        * @param AnimRootMotionTranslationScale Change to modify size of root motion or set to 0 to block it entirely</span><br><span class="line">        */</span><br><span class="line">    UFUNCTION(BlueprintCallable, Category=&quot;Ability|Tasks&quot;, meta = (HidePin = &quot;OwningAbility&quot;, DefaultToSelf = &quot;OwningAbility&quot;, BlueprintInternalUseOnly = &quot;TRUE&quot;))</span><br><span class="line">    static URPGAbilityTask_PlayMontageAndWaitForEvent* PlayMontageAndWaitForEvent(</span><br><span class="line">        UGameplayAbility* OwningAbility,</span><br><span class="line">        FName TaskInstanceName,</span><br><span class="line">        UAnimMontage* MontageToPlay,</span><br><span class="line">        FGameplayTagContainer EventTags,</span><br><span class="line">        float Rate = 1.f,</span><br><span class="line">        FName StartSection = NAME_None,</span><br><span class="line">        bool bStopWhenAbilityEnds = true,</span><br><span class="line">        float AnimRootMotionTranslationScale = 1.f);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    /** Montage that is playing */</span><br><span class="line">    UPROPERTY()</span><br><span class="line">    UAnimMontage* MontageToPlay;</span><br><span class="line"></span><br><span class="line">    //关键参数</span><br><span class="line">    /** List of tags to match against gameplay events */</span><br><span class="line">    UPROPERTY()</span><br><span class="line">    FGameplayTagContainer EventTags;</span><br><span class="line"></span><br><span class="line">    /** Playback rate */</span><br><span class="line">    UPROPERTY()</span><br><span class="line">    float Rate;</span><br><span class="line"></span><br><span class="line">    /** Section to start montage from */</span><br><span class="line">    UPROPERTY()</span><br><span class="line">    FName StartSection;</span><br><span class="line"></span><br><span class="line">    /** Modifies how root motion movement to apply */</span><br><span class="line">    UPROPERTY()</span><br><span class="line">    float AnimRootMotionTranslationScale;</span><br><span class="line"></span><br><span class="line">    /** Rather montage should be aborted if ability ends */</span><br><span class="line">    UPROPERTY()</span><br><span class="line">    bool bStopWhenAbilityEnds;</span><br><span class="line"></span><br><span class="line">    /** Checks if the ability is playing a montage and stops that montage, returns true if a montage was stopped, false if not. */</span><br><span class="line">    bool StopPlayingMontage();</span><br><span class="line"></span><br><span class="line">    /** Returns our ability system component */</span><br><span class="line">    URPGAbilitySystemComponent* GetTargetASC();</span><br><span class="line"></span><br><span class="line">    void OnMontageBlendingOut(UAnimMontage* Montage, bool bInterrupted);</span><br><span class="line">    void OnAbilityCancelled();</span><br><span class="line">    void OnMontageEnded(UAnimMontage* Montage, bool bInterrupted);</span><br><span class="line">    void OnGameplayEvent(FGameplayTag EventTag, const FGameplayEventData* Payload);</span><br><span class="line"></span><br><span class="line">    FOnMontageBlendingOutStarted BlendingOutDelegate;</span><br><span class="line">    FOnMontageEnded MontageEndedDelegate;</span><br><span class="line">    FDelegateHandle CancelledHandle;</span><br><span class="line">    FDelegateHandle EventHandle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">URPGAbilityTask_PlayMontageAndWaitForEvent::URPGAbilityTask_PlayMontageAndWaitForEvent(const FObjectInitializer&amp; ObjectInitializer)</span><br><span class="line">    : Super(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">    Rate = 1.f;</span><br><span class="line">    bStopWhenAbilityEnds = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">URPGAbilitySystemComponent* URPGAbilityTask_PlayMontageAndWaitForEvent::GetTargetASC()</span><br><span class="line">&#123;</span><br><span class="line">    return Cast&lt;URPGAbilitySystemComponent&gt;(AbilitySystemComponent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void URPGAbilityTask_PlayMontageAndWaitForEvent::OnMontageBlendingOut(UAnimMontage* Montage, bool bInterrupted)</span><br><span class="line">&#123;</span><br><span class="line">    if (Ability &amp;&amp; Ability-&gt;GetCurrentMontage() == MontageToPlay)</span><br><span class="line">    &#123;</span><br><span class="line">        if (Montage == MontageToPlay)</span><br><span class="line">        &#123;</span><br><span class="line">            AbilitySystemComponent-&gt;ClearAnimatingAbility(Ability);</span><br><span class="line"></span><br><span class="line">            // Reset AnimRootMotionTranslationScale</span><br><span class="line">            ACharacter* Character = Cast&lt;ACharacter&gt;(GetAvatarActor());</span><br><span class="line">            if (Character &amp;&amp; (Character-&gt;GetLocalRole() == ROLE_Authority ||</span><br><span class="line">                                (Character-&gt;GetLocalRole() == ROLE_AutonomousProxy &amp;&amp; Ability-&gt;GetNetExecutionPolicy() == EGameplayAbilityNetExecutionPolicy::LocalPredicted)))</span><br><span class="line">            &#123;</span><br><span class="line">                Character-&gt;SetAnimRootMotionTranslationScale(1.f);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (bInterrupted)</span><br><span class="line">    &#123;</span><br><span class="line">        if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">        &#123;</span><br><span class="line">            OnInterrupted.Broadcast(FGameplayTag(), FGameplayEventData());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">        &#123;</span><br><span class="line">            OnBlendOut.Broadcast(FGameplayTag(), FGameplayEventData());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void URPGAbilityTask_PlayMontageAndWaitForEvent::OnAbilityCancelled()</span><br><span class="line">&#123;</span><br><span class="line">    // TODO: Merge this fix back to engine, it was calling the wrong callback</span><br><span class="line"></span><br><span class="line">    if (StopPlayingMontage())</span><br><span class="line">    &#123;</span><br><span class="line">        // Let the BP handle the interrupt as well</span><br><span class="line">        if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">        &#123;</span><br><span class="line">            OnCancelled.Broadcast(FGameplayTag(), FGameplayEventData());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void URPGAbilityTask_PlayMontageAndWaitForEvent::OnMontageEnded(UAnimMontage* Montage, bool bInterrupted)</span><br><span class="line">&#123;</span><br><span class="line">    if (!bInterrupted)</span><br><span class="line">    &#123;</span><br><span class="line">        if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">        &#123;</span><br><span class="line">            OnCompleted.Broadcast(FGameplayTag(), FGameplayEventData());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EndTask();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//重点广播函数</span><br><span class="line">void URPGAbilityTask_PlayMontageAndWaitForEvent::OnGameplayEvent(FGameplayTag EventTag, const FGameplayEventData* Payload)</span><br><span class="line">&#123;</span><br><span class="line">    if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">    &#123;</span><br><span class="line">        FGameplayEventData TempData = *Payload;</span><br><span class="line">        TempData.EventTag = EventTag;</span><br><span class="line"></span><br><span class="line">        EventReceived.Broadcast(EventTag, TempData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">URPGAbilityTask_PlayMontageAndWaitForEvent* URPGAbilityTask_PlayMontageAndWaitForEvent::PlayMontageAndWaitForEvent(UGameplayAbility* OwningAbility,</span><br><span class="line">    FName TaskInstanceName, UAnimMontage* MontageToPlay, FGameplayTagContainer EventTags, float Rate, FName StartSection, bool bStopWhenAbilityEnds, float AnimRootMotionTranslationScale)</span><br><span class="line">&#123;</span><br><span class="line">    //静态工厂函数。这部分和PlayMontageAndWait大差不差</span><br><span class="line">    UAbilitySystemGlobals::NonShipping_ApplyGlobalAbilityScaler_Rate(Rate);</span><br><span class="line"></span><br><span class="line">    URPGAbilityTask_PlayMontageAndWaitForEvent* MyObj = NewAbilityTask&lt;URPGAbilityTask_PlayMontageAndWaitForEvent&gt;(OwningAbility, TaskInstanceName);</span><br><span class="line">    MyObj-&gt;MontageToPlay = MontageToPlay;</span><br><span class="line">    MyObj-&gt;EventTags = EventTags;</span><br><span class="line">    MyObj-&gt;Rate = Rate;</span><br><span class="line">    MyObj-&gt;StartSection = StartSection;</span><br><span class="line">    MyObj-&gt;AnimRootMotionTranslationScale = AnimRootMotionTranslationScale;</span><br><span class="line">    MyObj-&gt;bStopWhenAbilityEnds = bStopWhenAbilityEnds;</span><br><span class="line"></span><br><span class="line">    return MyObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void URPGAbilityTask_PlayMontageAndWaitForEvent::Activate()</span><br><span class="line">&#123;</span><br><span class="line">    //这部分也是和PlayMontageAndWait大体相似</span><br><span class="line"></span><br><span class="line">    if (Ability == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool bPlayedMontage = false;</span><br><span class="line">    URPGAbilitySystemComponent* RPGAbilitySystemComponent = GetTargetASC();</span><br><span class="line"></span><br><span class="line">    if (RPGAbilitySystemComponent)</span><br><span class="line">    &#123;</span><br><span class="line">        const FGameplayAbilityActorInfo* ActorInfo = Ability-&gt;GetCurrentActorInfo();</span><br><span class="line">        UAnimInstance* AnimInstance = ActorInfo-&gt;GetAnimInstance();</span><br><span class="line">        if (AnimInstance != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            //关键事件侦听函数</span><br><span class="line">            // Bind to event callback</span><br><span class="line">            EventHandle = RPGAbilitySystemComponent-&gt;AddGameplayEventTagContainerDelegate(EventTags, FGameplayEventTagMulticastDelegate::FDelegate::CreateUObject(this, &amp;URPGAbilityTask_PlayMontageAndWaitForEvent::OnGameplayEvent));</span><br><span class="line"></span><br><span class="line">            if (RPGAbilitySystemComponent-&gt;PlayMontage(Ability, Ability-&gt;GetCurrentActivationInfo(), MontageToPlay, Rate, StartSection) &gt; 0.f)</span><br><span class="line">            &#123;</span><br><span class="line">                // Playing a montage could potentially fire off a callback into game code which could kill this ability! Early out if we are  pending kill.</span><br><span class="line">                if (ShouldBroadcastAbilityTaskDelegates() == false)</span><br><span class="line">                &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                CancelledHandle = Ability-&gt;OnGameplayAbilityCancelled.AddUObject(this, &amp;URPGAbilityTask_PlayMontageAndWaitForEvent::OnAbilityCancelled);</span><br><span class="line"></span><br><span class="line">                BlendingOutDelegate.BindUObject(this, &amp;URPGAbilityTask_PlayMontageAndWaitForEvent::OnMontageBlendingOut);</span><br><span class="line">                AnimInstance-&gt;Montage_SetBlendingOutDelegate(BlendingOutDelegate, MontageToPlay);</span><br><span class="line"></span><br><span class="line">                MontageEndedDelegate.BindUObject(this, &amp;URPGAbilityTask_PlayMontageAndWaitForEvent::OnMontageEnded);</span><br><span class="line">                AnimInstance-&gt;Montage_SetEndDelegate(MontageEndedDelegate, MontageToPlay);</span><br><span class="line"></span><br><span class="line">                ACharacter* Character = Cast&lt;ACharacter&gt;(GetAvatarActor());</span><br><span class="line">                if (Character &amp;&amp; (Character-&gt;GetLocalRole() == ROLE_Authority ||</span><br><span class="line">                                    (Character-&gt;GetLocalRole() == ROLE_AutonomousProxy &amp;&amp; Ability-&gt;GetNetExecutionPolicy() == EGameplayAbilityNetExecutionPolicy::LocalPredicted)))</span><br><span class="line">                &#123;</span><br><span class="line">                    Character-&gt;SetAnimRootMotionTranslationScale(AnimRootMotionTranslationScale);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                bPlayedMontage = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            ABILITY_LOG(Warning, TEXT(&quot;URPGAbilityTask_PlayMontageAndWaitForEvent call to PlayMontage failed!&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        ABILITY_LOG(Warning, TEXT(&quot;URPGAbilityTask_PlayMontageAndWaitForEvent called on invalid AbilitySystemComponent&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!bPlayedMontage)</span><br><span class="line">    &#123;</span><br><span class="line">        ABILITY_LOG(Warning, TEXT(&quot;URPGAbilityTask_PlayMontageAndWaitForEvent called in Ability %s failed to play montage %s; Task Instance Name %s.&quot;), *Ability-&gt;GetName(), *GetNameSafe(MontageToPlay),*InstanceName.ToString());</span><br><span class="line">        if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">        &#123;</span><br><span class="line">            OnCancelled.Broadcast(FGameplayTag(), FGameplayEventData());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SetWaitingOnAvatar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void URPGAbilityTask_PlayMontageAndWaitForEvent::ExternalCancel()</span><br><span class="line">&#123;</span><br><span class="line">    UAbilitySystemComponent* ASC = GetTargetASC();</span><br><span class="line"></span><br><span class="line">    if (ASC)</span><br><span class="line">    //check(AbilitySystemComponent);</span><br><span class="line"></span><br><span class="line">    OnAbilityCancelled();</span><br><span class="line"></span><br><span class="line">    Super::ExternalCancel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void URPGAbilityTask_PlayMontageAndWaitForEvent::OnDestroy(bool AbilityEnded)</span><br><span class="line">&#123;</span><br><span class="line">    // Note: Clearing montage end delegate isn&#x27;t necessary since its not a multicast and will be cleared when the next montage plays.</span><br><span class="line">    // (If we are destroyed, it will detect this and not do anything)</span><br><span class="line"></span><br><span class="line">    // This delegate, however, should be cleared as it is a multicast</span><br><span class="line">    if (Ability)</span><br><span class="line">    &#123;</span><br><span class="line">        Ability-&gt;OnGameplayAbilityCancelled.Remove(CancelledHandle);</span><br><span class="line">        if (AbilityEnded &amp;&amp; bStopWhenAbilityEnds)</span><br><span class="line">        &#123;</span><br><span class="line">            StopPlayingMontage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    URPGAbilitySystemComponent* RPGAbilitySystemComponent = GetTargetASC();</span><br><span class="line">    if (RPGAbilitySystemComponent)</span><br><span class="line">    &#123;</span><br><span class="line">        RPGAbilitySystemComponent-&gt;RemoveGameplayEventTagContainerDelegate(EventTags, EventHandle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Super::OnDestroy(AbilityEnded);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool URPGAbilityTask_PlayMontageAndWaitForEvent::StopPlayingMontage()</span><br><span class="line">&#123;</span><br><span class="line">    const FGameplayAbilityActorInfo* ActorInfo = Ability-&gt;GetCurrentActorInfo();</span><br><span class="line">    if (!ActorInfo)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UAnimInstance* AnimInstance = ActorInfo-&gt;GetAnimInstance();</span><br><span class="line">    if (AnimInstance == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Check if the montage is still playing</span><br><span class="line">    // The ability would have been interrupted, in which case we should automatically stop the montage</span><br><span class="line">    UAbilitySystemComponent* ASC = GetTargetASC();</span><br><span class="line"></span><br><span class="line">    if (ASC &amp;&amp; Ability)</span><br><span class="line">    //if (AbilitySystemComponent &amp;&amp; Ability)</span><br><span class="line">    &#123;</span><br><span class="line">        if (AbilitySystemComponent-&gt;GetAnimatingAbility() == Ability</span><br><span class="line">            &amp;&amp; AbilitySystemComponent-&gt;GetCurrentMontage() == MontageToPlay)</span><br><span class="line">        &#123;</span><br><span class="line">            // Unbind delegates so they don&#x27;t get called as well</span><br><span class="line">            FAnimMontageInstance* MontageInstance = AnimInstance-&gt;GetActiveInstanceForMontage(MontageToPlay);</span><br><span class="line">            if (MontageInstance)</span><br><span class="line">            &#123;</span><br><span class="line">                MontageInstance-&gt;OnMontageBlendingOutStarted.Unbind();</span><br><span class="line">                MontageInstance-&gt;OnMontageEnded.Unbind();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            AbilitySystemComponent-&gt;CurrentMontageStop();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FString URPGAbilityTask_PlayMontageAndWaitForEvent::GetDebugString() const</span><br><span class="line">&#123;</span><br><span class="line">    UAnimMontage* PlayingMontage = nullptr;</span><br><span class="line">    if (Ability)</span><br><span class="line">    &#123;</span><br><span class="line">        const FGameplayAbilityActorInfo* ActorInfo = Ability-&gt;GetCurrentActorInfo();</span><br><span class="line">        UAnimInstance* AnimInstance = ActorInfo-&gt;GetAnimInstance();</span><br><span class="line"></span><br><span class="line">        if (AnimInstance != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            PlayingMontage = AnimInstance-&gt;Montage_IsActive(MontageToPlay) ? MontageToPlay : AnimInstance-&gt;GetCurrentActiveMontage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return FString::Printf(TEXT(&quot;PlayMontageAndWaitForEvent. MontageToPlay: %s  (Currently Playing): %s&quot;), *GetNameSafe(MontageToPlay), *GetNameSafe(PlayingMontage));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="蒙太奇播放与Notify"><a href="#蒙太奇播放与Notify" class="headerlink" title="蒙太奇播放与Notify"></a>蒙太奇播放与Notify</h2><img src="/UE/Project/Lyra/UE55Lyra6/image-3.png" class="" title="alt text">
<p>这里有两个相对关键重要的Notify<br>1.Weapon Attack NS<br>2.Jump Section NS</p>
<h3 id="WeaponAttackNS"><a href="#WeaponAttackNS" class="headerlink" title="WeaponAttackNS"></a>WeaponAttackNS</h3><p>这个动画通知主要用于启用武器攻击检测。<br>关键参数 - EventTag<br>具体的检测逻辑 放在WeaponActor上。<br>逻辑链条：<br>RecNotifyBegin -&gt; 获取Actor -&gt; 获取Weapon -&gt; Weapon设置开始攻击检测<br>RecNotifyEnd -&gt; 获取Actor -&gt; 获取Weapon -&gt; Weapon设置结束攻击检测</p>
<h4 id="攻击检测"><a href="#攻击检测" class="headerlink" title="攻击检测"></a>攻击检测</h4><p>看到WeaponActor。实际上还是在某段时间内，启用Capsule碰撞体积来实现的。</p>
<p>碰撞逻辑内部使用了DoOnce,并用结束碰撞的延迟来做DoOnce的Reset，从而设置攻击间隔。在进行了目标非发出者(Instigator)的检测后，使用目标和发出者来构造GameplayEventData,并使用SendGameplayEventToActor将Tag和构造的GameplayEventData发送给发出者。</p>
<p>ASC::HandleGameplayEvent -&gt; ASC的GameplayEventTagContainerDelegates进行广播。</p>
<h3 id="JumpSectionNS"><a href="#JumpSectionNS" class="headerlink" title="JumpSectionNS"></a>JumpSectionNS</h3><p>主要是理解ActionRPG中，Combo的实现方式。<br>在这个项目中，一个攻击的多个连段是放在同一个蒙太奇里做的，分为了不同的Section。Combo其实是在不同的Section中进行切换。</p>
<p>Character上存在一个EnableComboPeriod标志位，NotifyBegin与End的时候设置该标志位。<br>在Notify上会存一个JumpSection的信息。</p>
<img src="/UE/Project/Lyra/UE55Lyra6/image4.png" class="" title="alt text">
<img src="/UE/Project/Lyra/UE55Lyra6/image5.png" class="" title="alt text">
<p>可以看到，仅有第一个Combo会使用GA。后面的只是切换蒙太奇片段。<br>这种设计并不严谨。</p>
<h1 id="网络延迟模拟和测试"><a href="#网络延迟模拟和测试" class="headerlink" title="网络延迟模拟和测试"></a>网络延迟模拟和测试</h1><p>还是以Lyra项目为例子<br>NetMode使用Play As Client，并设置为2个玩家来作为测试样例。<br>网络延迟可以在下面的AdvancedSettings来进行设置</p>
<img src="/UE/Project/Lyra/UE55Lyra6/image.png" class="" title="alt text">
<p>通过网络延迟，可以更好的看到客户端的预测效果和情况。</p>
<p>如果这里的网络延迟没有生效，可以尝试以下配置。</p>
<img src="/UE/Project/Lyra/UE55Lyra6/image6.png" class="" title="alt text">

<h1 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h1><p>ActionRPG的生命值相关改动 还是通过GE来实现的。定义为“PassivegGameplayEffects”。<br>ActionRPG的设计和实现，可以看出来还是针对单机模式的。包括连击的实现，也没有使用多个GA，仅在第一次触发的时候使用了GA。可以参考其武器近战攻击的碰撞检测实现，以及连击的Notify设置，但这块最好还是用Tag来做比较好。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://MikeMing126.github.io">Ming</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mikeming126.github.io/UE/Project/Lyra/UE55Lyra6/">https://mikeming126.github.io/UE/Project/Lyra/UE55Lyra6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://MikeMing126.github.io" target="_blank">Ming Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/UE/">UE</a><a class="post-meta__tags" href="/tags/GAS/">GAS</a><a class="post-meta__tags" href="/tags/Lyra/">Lyra</a></div><div class="post-share"><div class="social-share" data-image="/img/head.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/UE/Project/Lyra/UE55Lyra5/" title="UE5.5-Lyra-5-GATask-传输数据流程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">UE5.5-Lyra-5-GATask-传输数据流程</div></div><div class="info-2"><div class="info-item-1">GATask_WaitTargetData以WaitTargetData为例子理解TargetActor的使用流程和逻辑 客户端传输数据情况Client侧p1  p2  p3  Server侧p4  p5   服务端自己产生数据情况这里以对应AGameplayAbilityTargetActor_Radius作为例子p6 </div></div></div></a><a class="pagination-related" href="/UE/Engine/UEBlueprintNote/" title="UE蓝图笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">UE蓝图笔记</div></div><div class="info-2"><div class="info-item-1">蓝图断点与流程显示断点的话，右键对应的节点添加断点即可。 运行时打开对应的蓝图，并在编辑器中选中对应的对象，可以观看其运行流程。  </div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/UE/GAS/UE55GASGC/" title="UE5.5-GameplayCue"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-08</div><div class="info-item-2">UE5.5-GameplayCue</div></div><div class="info-2"><div class="info-item-1">GameplayCue重要的类：GameplayCueSet 但是游戏中的资源加载并不是这样进行的。 映射关系： Tag -&gt; GC GC的收集过程：将GameplayCue资产放在指定的目录下。具体的可以在.ini里面配置。以Lyra为例子   资源的加载：关键类为UAbilitySystemGlobals与UGameplayCueManager。可以看到GameplayCueManager里。 //UAbilitySystemGlobals部分//GameplayAbilitiesDeveloperSettings.h//注意宏里面Config的关键字/** Look in these paths for GameplayCueNotifies. These are your &quot;always loaded&quot; set. */UPROPERTY(Config, EditDefaultsOnly, Category=GameplayCue, meta =...</div></div></div></a><a class="pagination-related" href="/UE/Project/Lyra/UE55Lyra1/" title="UE5.5-Lyra-1-Attribute"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-16</div><div class="info-item-2">UE5.5-Lyra-1-Attribute</div></div><div class="info-2"><div class="info-item-1">基于官方Lyra的GAS学习。 综述首先就是ASC的位置。Lyra项目将ASC放置于了LyraPlayerState中。将ASC与PlayerState绑定。 此外 可以看到LyraCharacter。其也有获取ASC的接口。 从LyraCharacter获取ASC组件，依赖于其PawnExtComponent。这里可以看到ULyraPawnExtensionComponent这个类。该类会存放一个ASC指针。在函数InitializeAbilitySystem中进行设置。 LyraHeroComponent是唯一调用该方法的组件。见ULyraHeroComponent::HandleChangeInitState。这里的逻辑也是从PlayerState中拿到ASC，然后赋值给PawnExtComponent。 总而言之，该项目的ASC位于PlayerState。整体的链条大概如下：PlayerState -&gt; LyraHeroComp -&gt; PawnExtComponent -&gt; LyraCharacter。 再整理一下： LyraCharacter -...</div></div></div></a><a class="pagination-related" href="/UE/Project/Lyra/UE55Lyra2/" title="UE5.5-Lyra-2-GE"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-23</div><div class="info-item-2">UE5.5-Lyra-2-GE</div></div><div class="info-2"><div class="info-item-1">GE蓝图创建的GE。基于 GameplayEffectParent_Damage_Basic 来看GE:  Gameplay效果 组件 GEComponents 包含很多个效果 可以在编辑器中细看   修饰符 Modifiers 执行 Executions   Gameplay Cue  GE的执行流程以GA的ApplyCost为例子： GA:ApplyGameplayEffectToOwner↓GA:ApplyGameplayEffectSpecToOwner↓ASC:ApplyGameplayEffectSpecToSelf 到这里可以分为两条路线了，一条是即刻执行的GE，Instant类型。第二种是有持续时间的GE（包括永久）。对于后者，会生成FActiveGameplayEffect。 在ASC:ApplyGameplayEffectSpecToSelf中就有两个关键函数了：  持续类型的 由ASC的FActiveGameplayEffectContainer调用ApplyGameplayEffectSpec处理 Intant类型...</div></div></div></a><a class="pagination-related" href="/UE/Project/Lyra/UE55Lyra3/" title="UE5.5-Lyra-3-GATask"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-27</div><div class="info-item-2">UE5.5-Lyra-3-GATask</div></div><div class="info-2"><div class="info-item-1">GamplayAbilityTask基础AbilityTask 异步任务 开始并等待结束&#x2F;打断 部分实现需要关注[K2Node_LatentAbilityCall]  基础逻辑 定义动态多播委托，并声明为BlueprintAssignable 声明静态工厂函数用于创建AbilityTask。由该函数定义输入参数。但是这个不意味着任务开始，不在其中调用广播 实现Activate函数。该函数代表着任务的激活    其他    - OnDestroy记得取消事件的侦听和注册，并调用父类的OnDestroy。   静态工厂函数的meta声明了meta &#x3D; (xxx前面忽略, BlueprintInternalUseOnly &#x3D; “TRUE”)  实际蓝图的调用走过UK2Node_LatentGameplayTaskCall的ExpandNode. WaitOverlap//定义委托DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FWaitOverlapDelegate, const...</div></div></div></a><a class="pagination-related" href="/UE/Project/Lyra/UE55Lyra4/" title="UE5.5-Lyra-4-GATask-AGameplayAbilityTargetActor"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-01</div><div class="info-item-2">UE5.5-Lyra-4-GATask-AGameplayAbilityTargetActor</div></div><div class="info-2"><div class="info-item-1">中间数据 GameplayAbilityTargetActor关于目标数据 以下是几个比较关键的类。AGameplayAbilityTargetActor委托：FAbilityTargetDataFGameplayAbilityTargetDataHandleFGameplayAbilityTargetDataFGameplayEffectContextHandleFGameplayEffectContext 总体上还是比较复杂的。从源码看起。 AGameplayAbilityTargetActor/** * TargetActors are spawned to assist with ability targeting. They are spawned by ability tasks and create/determine the outgoing targeting data passed from one task to another * * WARNING: These actors are spawned once per ability...</div></div></div></a><a class="pagination-related" href="/UE/Project/Lyra/UE55Lyra5/" title="UE5.5-Lyra-5-GATask-传输数据流程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">UE5.5-Lyra-5-GATask-传输数据流程</div></div><div class="info-2"><div class="info-item-1">GATask_WaitTargetData以WaitTargetData为例子理解TargetActor的使用流程和逻辑 客户端传输数据情况Client侧p1  p2  p3  Server侧p4  p5   服务端自己产生数据情况这里以对应AGameplayAbilityTargetActor_Radius作为例子p6 </div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Ming</div><div class="author-info-description">我们都在奔赴各自的人生，但你依旧是你</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">前言和方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GATask-PlayMontageAndWait"><span class="toc-number">2.</span> <span class="toc-text">GATask_PlayMontageAndWait</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PlayMontageAndWait%E6%BA%90%E7%A0%81"><span class="toc-number">2.1.</span> <span class="toc-text">PlayMontageAndWait源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E6%BA%90%E7%A0%81"><span class="toc-number">2.2.</span> <span class="toc-text">补充源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ASC%E7%9A%84PlayMontage"><span class="toc-number">2.2.1.</span> <span class="toc-text">ASC的PlayMontage</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lyra%E7%9A%84%E8%BF%91%E6%88%98%E6%94%BB%E5%87%BB%E6%A3%80%E6%B5%8B"><span class="toc-number">3.</span> <span class="toc-text">Lyra的近战攻击检测</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ActionRPG%E7%9A%84%E8%BF%91%E6%88%98%E6%94%BB%E5%87%BB%E6%A3%80%E6%B5%8B"><span class="toc-number">4.</span> <span class="toc-text">ActionRPG的近战攻击检测</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GA%E4%B8%8EGE%E5%BA%94%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">GA与GE应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GA%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%A6%81%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.1.</span> <span class="toc-text">GA重写和重要函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E7%B1%BB%E5%A3%B0%E6%98%8E"><span class="toc-number">4.1.2.</span> <span class="toc-text">辅助类声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">4.1.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E7%AD%9B%E9%80%89%E4%B8%8ETag"><span class="toc-number">4.2.</span> <span class="toc-text">目标筛选与Tag</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PlayMontageAndWaitForEvent"><span class="toc-number">4.2.1.</span> <span class="toc-text">PlayMontageAndWaitForEvent</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%92%99%E5%A4%AA%E5%A5%87%E6%92%AD%E6%94%BE%E4%B8%8ENotify"><span class="toc-number">4.3.</span> <span class="toc-text">蒙太奇播放与Notify</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WeaponAttackNS"><span class="toc-number">4.3.1.</span> <span class="toc-text">WeaponAttackNS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%A3%80%E6%B5%8B"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">攻击检测</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JumpSectionNS"><span class="toc-number">4.3.2.</span> <span class="toc-text">JumpSectionNS</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%A8%A1%E6%8B%9F%E5%92%8C%E6%B5%8B%E8%AF%95"><span class="toc-number">5.</span> <span class="toc-text">网络延迟模拟和测试</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A2%98%E5%A4%96"><span class="toc-number">6.</span> <span class="toc-text">题外</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/AsyncOp/" title="Unity异步操作">Unity异步操作</a><time datetime="2025-09-14T08:01:59.349Z" title="发表于 2025-09-14 16:01:59">2025-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/Physics/" title="Unity Physics">Unity Physics</a><time datetime="2025-09-14T08:01:59.345Z" title="发表于 2025-09-14 16:01:59">2025-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Mine/Unity/Animation/" title="Unity Animation">Unity Animation</a><time datetime="2025-09-14T08:01:59.343Z" title="发表于 2025-09-14 16:01:59">2025-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/UE/Share/25ShangHaiFest/" title="2025 - UE - ShangHaiFest">2025 - UE - ShangHaiFest</a><time datetime="2025-08-22T11:09:27.474Z" title="发表于 2025-08-22 19:09:27">2025-08-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Books/Tech/%E9%87%8D%E6%9E%84/" title="重构:改善既有代码的设计">重构:改善既有代码的设计</a><time datetime="2025-07-14T13:43:14.158Z" title="发表于 2025-07-14 21:43:14">2025-07-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/starBg2.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2025 By Ming</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23liMdTJDdBPikGC2F',
      clientSecret: 'eed0ab3cb8494f9e22f7a8bb469c58cc7e6fbaea',
      repo: 'BlogComment',
      owner: 'MikeMing126',
      admin: ['MikeMing126'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '4fac02b0009e89f825e711f94b4d605f'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script src="/script/APlayerHolder.js"></script><div class="aplayer" data-id="13402811242" data-server="netease" data-type="playlist" data-fixed="true" data-loop="all" data-autoplay="true" data-order="random" data-theme="#3F51B5"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>