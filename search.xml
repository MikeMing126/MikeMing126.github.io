<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo APlayer 音频播放及切换网页时保存音频进度</title>
    <url>/Hexo/HexoAPlayer/</url>
    <content><![CDATA[<h1 id="音乐播放"><a href="#音乐播放" class="headerlink" title="音乐播放"></a>音乐播放</h1><p>主要用于实现网页在线音乐播放</p>
<h2 id="基于Butterfly主题的音乐播放器"><a href="#基于Butterfly主题的音乐播放器" class="headerlink" title="基于Butterfly主题的音乐播放器"></a>基于Butterfly主题的音乐播放器</h2><p>参考文章 <a href="https://polar-bear.eu.org/2023/07/21/hexo-tag-aplayer-cha-jian/">博客</a></p>
<p>插件：hexo-tag-aplayer</p>
<p>启用MeingJS来使用在线网站歌单。</p>
<h3 id="底部播放器切换网站问题"><a href="#底部播放器切换网站问题" class="headerlink" title="底部播放器切换网站问题"></a>底部播放器切换网站问题</h3><h4 id="基于Hexo-Tag-APlayer的PJAX-兼容："><a href="#基于Hexo-Tag-APlayer的PJAX-兼容：" class="headerlink" title="基于Hexo-Tag-APlayer的PJAX 兼容："></a>基于Hexo-Tag-APlayer的PJAX 兼容：</h4><p>在主题配置文件中设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pjax:</span><br><span class="line">  enable: ture</span><br><span class="line">  exclude:</span><br></pre></td></tr></table></figure>

<p><strong>!!!PJAX问题!!!</strong><br>基于这种配置，虽然网页在切换时，音频播放器的进度不会重置，但是很多网页的动画也因此而丢失了。</p>
<h4 id="不使用PJAX的实现方案"><a href="#不使用PJAX的实现方案" class="headerlink" title="不使用PJAX的实现方案:"></a>不使用PJAX的实现方案:</h4><p>参考文章 <a href="https://zsyyblog.com/90153be9.html">博客</a></p>
<ol>
<li>在博客对应的source文件夹中 创建script文件夹。</li>
<li>编写对应的代码文件，并放于script文件夹中。如APlayerHolder.js</li>
<li>在主题yml配置对应的代码</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inject:</span><br><span class="line">  head:</span><br><span class="line">  bottom:</span><br><span class="line">    - &lt;script src=&quot;/script/APlayerHolder.js&quot;&gt;&lt;/script&gt; //新增代码使用。</span><br><span class="line">    - &lt;class=&quot;aplayer&quot;&gt; //这里是你的音乐播放器配置，不用改。</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>对应代码文件APlayerHolder.js示例</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">InitAPlayerHolder</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//获取全局对象aplayer。</span></span><br><span class="line">    <span class="comment">//注意判空</span></span><br><span class="line">    <span class="keyword">var</span> ap = <span class="variable language_">window</span>.<span class="property">aplayers</span> &amp;&amp; <span class="variable language_">window</span>.<span class="property">aplayers</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ap == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//等待aplayer对象被创建</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="title class_">InitAPlayerHolder</span>, <span class="number">50</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//#region 状态保存函数</span></span><br><span class="line">    <span class="comment">//原基础上加了个检测暂停免得切换页面后爆零(bushi)（指社死）</span></span><br><span class="line">    ap.<span class="title function_">on</span>(<span class="string">&quot;pause&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;aPlayerMusicPaused&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//ap.lrc.hide()</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//自带播放暂停时显隐歌词，后面那句可以删，上同</span></span><br><span class="line">    ap.<span class="title function_">on</span>(<span class="string">&quot;play&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;aPlayerMusicPaused&quot;</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//ap.lrc.show()</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存音量</span></span><br><span class="line">    ap.<span class="property">audio</span>.<span class="property">onvolumechange</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;aPlayerMusicVolume&quot;</span>,ap.<span class="property">audio</span>.<span class="property">volume</span>);&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Index/Time/Mode 定时保存</span></span><br><span class="line">    <span class="keyword">var</span> saveTimeInterval = <span class="number">150</span>;</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;aPlayerMusicIndex&quot;</span>,ap.<span class="property">list</span>.<span class="property">index</span>);</span><br><span class="line">        <span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;aPlayerMusicTime&quot;</span>,ap.<span class="property">audio</span>.<span class="property">currentTime</span>);</span><br><span class="line">        <span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;aPlayerMusicMode&quot;</span>,ap.<span class="property">mode</span>);</span><br><span class="line">    &#125;,saveTimeInterval);</span><br><span class="line">    <span class="comment">//#endregion 状态保存函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//#region 加载保存进度</span></span><br><span class="line">    <span class="comment">//自带播放暂停时显隐歌词，可以删</span></span><br><span class="line">    ap.<span class="property">lrc</span>.<span class="title function_">hide</span>();</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;aplayer-icon-menu&quot;</span>)[<span class="number">0</span>].<span class="title function_">click</span>()</span><br><span class="line">    <span class="comment">//Index</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;aPlayerMusicIndex&quot;</span>)!=<span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        aPlayerMusicIndex = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;aPlayerMusicIndex&quot;</span>);</span><br><span class="line">        ap.<span class="property">list</span>.<span class="title function_">switch</span>(aPlayerMusicIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Time</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;aPlayerMusicTime&quot;</span>) != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">musict</span> = <span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;aPlayerMusicTime&quot;</span>);</span><br><span class="line">        ap.<span class="title function_">setMode</span>(<span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;aPlayerMusicMode&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;aPlayerMusicPaused&quot;</span>)==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ap.<span class="title function_">pause</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ap.<span class="title function_">play</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// setTimeout(function()&#123;</span></span><br><span class="line">        <span class="comment">//     ap.seek(window.musict); //seek炸了我很久，最后决定加个延时（本来要用canplay但是莫名鬼畜了）</span></span><br><span class="line">        <span class="comment">// &#125;,500);</span></span><br><span class="line">        <span class="keyword">var</span> g=<span class="literal">true</span>; <span class="comment">//加个变量以防鬼畜但是不知道怎么节流qwq</span></span><br><span class="line">        ap.<span class="title function_">on</span>(<span class="string">&quot;canplay&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g)&#123;</span><br><span class="line">                ap.<span class="title function_">seek</span>(<span class="variable language_">window</span>.<span class="property">musict</span>);</span><br><span class="line">                g=<span class="literal">false</span>;<span class="comment">//如果不加oncanplay的话会seek失败就这原因炸很久</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;aPlayerMusicPaused&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        ap.<span class="title function_">setMode</span>(<span class="string">&quot;mini&quot;</span>); <span class="comment">//新版添加了保存展开状态功能</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Volume</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;aPlayerMusicVolume&quot;</span>) != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ap.<span class="property">audio</span>.<span class="property">volume</span>=<span class="title class_">Number</span>(<span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;aPlayerMusicVolume&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//#endregion 加载保存进度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行逻辑</span></span><br><span class="line"><span class="title class_">InitAPlayerHolder</span>();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>书本阅读 —— Summary</title>
    <url>/Books/ReadingSummary/</url>
    <content><![CDATA[<h1 id="书本阅读-——-Summary"><a href="#书本阅读-——-Summary" class="headerlink" title="书本阅读 —— Summary"></a>书本阅读 —— Summary</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在大学工作之后，我自己倒是很少再单独去看完整的书籍了。大多数情况，是按需求找些博客，找些项目，或者知乎文章来看。或者是单独去抽某本书的部分来看。</p>
<p>从技术实用角度来说，这样可以依据需求快速的寻找解决方案，到也挺好的。</p>
<p>不过，我仍然认为，有些书本值得整本去读一读，能开阔不少视野。</p>
<p>本篇用来汇总记录我的一些读书感想。</p>
<h2 id="技术项"><a href="#技术项" class="headerlink" title="技术项"></a>技术项</h2><h3 id="《人月神话》"><a href="#《人月神话》" class="headerlink" title="《人月神话》"></a>《人月神话》</h3><a href="/Books/Tech/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D/" title="人月神话">人月神话</a>


<h3 id="《重构-改善既有代码的设计》"><a href="#《重构-改善既有代码的设计》" class="headerlink" title="《重构:改善既有代码的设计》"></a>《重构:改善既有代码的设计》</h3><a href="/Books/Tech/%E9%87%8D%E6%9E%84/" title="重构:改善既有代码的设计">重构</a>

<h2 id="心理"><a href="#心理" class="headerlink" title="心理"></a>心理</h2>]]></content>
      <categories>
        <category>书本阅读</category>
      </categories>
      <tags>
        <tag>书本阅读</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo开发</title>
    <url>/Hexo/HexoDev/</url>
    <content><![CDATA[<h1 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h1><h2 id="Hexo开发去除缓存-重新刷新生成"><a href="#Hexo开发去除缓存-重新刷新生成" class="headerlink" title="Hexo开发去除缓存-重新刷新生成"></a>Hexo开发去除缓存-重新刷新生成</h2><h3 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h3><p>在开发一个 Hexo 插件，在开发的过程中，遇到了一些小的问题：插件的代码发生了修改，但运行hexo 的时候却没有实时刷新出来。</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>在对代码进行分析后发现，hexo 的 tag filter 的结果会缓存在数据库中，由于缓存了，所以我使用的 generator ，所以也会被缓存。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>在预览前，删除 db.json 即可让 hexo 重新开始生成</p>
<h2 id="网页缓存问题"><a href="#网页缓存问题" class="headerlink" title="网页缓存问题"></a>网页缓存问题</h2><p>F12打开开发者工具，网络部分，选择禁用缓存即可。</p>
<h1 id="创建带文件夹的文章用于图片处理"><a href="#创建带文件夹的文章用于图片处理" class="headerlink" title="创建带文件夹的文章用于图片处理"></a>创建带文件夹的文章用于图片处理</h1><p>直接命令行 hexo new newArticleName 就可以创建了</p>
<p>指定目录：</p>
<blockquote>
<p>hexo n -p post dir&#x2F;post1<br>在_posts&#x2F;dir目录下生成post1.md文件。</p>
</blockquote>
<h1 id="添加站内文章连接"><a href="#添加站内文章连接" class="headerlink" title="添加站内文章连接"></a>添加站内文章连接</h1><h2 id="使用绝对地址"><a href="#使用绝对地址" class="headerlink" title="使用绝对地址"></a>使用绝对地址</h2><blockquote>
<p>[超链接名称](&#x2F;站内地址)</p>
</blockquote>
<p>这里要注意，默认情况下的配置，内部文章地址会带上日期。<br>再_config.yml内修改permalink,改为 :title&#x2F; 即可。<br>示例地址</p>
<blockquote>
<p>[Hexo开发](&#x2F;Hexo&#x2F;HexoDev&#x2F;)</p>
</blockquote>
<p><a href="/Hexo/HexoDev/">Hexo开发</a></p>
<h2 id="使用post-link标签"><a href="#使用post-link标签" class="headerlink" title="使用post_link标签"></a>使用post_link标签</h2><blockquote>
<p><code>&#123;% post_link /文档地址/md文件名 '链接名称' %&#125;</code></p>
</blockquote>
<p>示例地址<br><code>&#123;% post_link Hexo/HexoDev 'Hexo开发' %&#125;</code></p>
<a href="/Hexo/HexoDev/" title="Hexo开发">Hexo开发</a>

<h1 id="移动Hexo博客"><a href="#移动Hexo博客" class="headerlink" title="移动Hexo博客"></a>移动Hexo博客</h1><p>可以考虑直接拷贝。建议使用压缩包进行。</p>
<h2 id="Hexo迁移"><a href="#Hexo迁移" class="headerlink" title="Hexo迁移"></a>Hexo迁移</h2><p>直接拷贝算是一种方法吧。<br>但是重点在于创建时间需要处理 这个可以用WinRAR来处理</p>
<p>然后是日期方面：<br>修改post.md去处理<br><a href="https://blog.binarydev.top/posts/2024/07/24/38823/index.html">hexo每次远程部署会变动文章更新日期解决方案</a><br><a href="https://blog.ikun.uk/debug/98.html">『hexo』博客迁移后helloworld文章时间错误</a></p>
<h2 id="WinRAR创建时间设置"><a href="#WinRAR创建时间设置" class="headerlink" title="WinRAR创建时间设置"></a>WinRAR创建时间设置</h2><p><a href="https://blog.csdn.net/abc070608/article/details/115464305">WinRAR在压缩文件和解压时，默认保留文件、文件夹的创建日期、修改日期、访问日期</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Theme</title>
    <url>/Hexo/HexoTheme/</url>
    <content><![CDATA[<h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><h2 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h2><p><a href="https://github.com/MaLuns/hexo-theme-async">GitHub</a>  </p>
<p><a href="https://hexo-theme-async.imalun.com/guide/">Introduction</a>  </p>
<h2 id="Butterfly"><a href="#Butterfly" class="headerlink" title="Butterfly"></a>Butterfly</h2><p><a href="https://butterfly.js.org/">Introduction</a>  </p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Git相关内容学习</title>
    <url>/Other/GitLearning/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Git在版本维护上面还是能发挥很好的作用的。当然也可以考虑用TortoiseSVN。<br>主要目的还是维护好代码吧。这样有什么临时改动想回滚到之前版本也比较好处理。避免某些操作无法撤销而花很多精力去重新编写内容。</p>
<h1 id="基础Git指令"><a href="#基础Git指令" class="headerlink" title="基础Git指令"></a>基础Git指令</h1><p>有需要再补充。</p>
<h1 id="配置GitIgnore相关内容"><a href="#配置GitIgnore相关内容" class="headerlink" title="配置GitIgnore相关内容"></a>配置GitIgnore相关内容</h1><h2 id="基础说明"><a href="#基础说明" class="headerlink" title="基础说明"></a>基础说明</h2><p>在Git中，.gitignore文件用于指定项目中要忽略的文件和目录，这些文件和目录不会被跟踪和提交到远程仓库。编写.gitignore文件时，你可以使用一系列规则来匹配要忽略的文件和目录。</p>
<h2 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h2><h3 id="忽略特定文件："><a href="#忽略特定文件：" class="headerlink" title="忽略特定文件："></a>忽略特定文件：</h3><p>  filename.ext</p>
<h3 id="忽略特定目录："><a href="#忽略特定目录：" class="headerlink" title="忽略特定目录："></a>忽略特定目录：</h3><p>  directory&#x2F;</p>
<h3 id="忽略特定扩展名的所有文件："><a href="#忽略特定扩展名的所有文件：" class="headerlink" title="忽略特定扩展名的所有文件："></a>忽略特定扩展名的所有文件：</h3><p>  *.log</p>
<h3 id="忽略特定目录下的所有文件："><a href="#忽略特定目录下的所有文件：" class="headerlink" title="忽略特定目录下的所有文件："></a>忽略特定目录下的所有文件：</h3><p>  directory&#x2F;*</p>
<h3 id="忽略特定目录及其所有子目录："><a href="#忽略特定目录及其所有子目录：" class="headerlink" title="忽略特定目录及其所有子目录："></a>忽略特定目录及其所有子目录：</h3><p>  directory&#x2F;**</p>
<h2 id="高级规则"><a href="#高级规则" class="headerlink" title="高级规则"></a>高级规则</h2><h3 id="忽略特定模式的文件："><a href="#忽略特定模式的文件：" class="headerlink" title="忽略特定模式的文件："></a>忽略特定模式的文件：</h3><p>  file[0-9].txt</p>
<h3 id="忽略特定模式的目录："><a href="#忽略特定模式的目录：" class="headerlink" title="忽略特定模式的目录："></a>忽略特定模式的目录：</h3><p>  dir*&#x2F;subdir&#x2F;</p>
<h3 id="忽略特定目录下的特定文件："><a href="#忽略特定目录下的特定文件：" class="headerlink" title="忽略特定目录下的特定文件："></a>忽略特定目录下的特定文件：</h3><p>  directory&#x2F;filename.ext</p>
<h3 id="忽略特定目录下的所有文件，但不包括子目录："><a href="#忽略特定目录下的所有文件，但不包括子目录：" class="headerlink" title="忽略特定目录下的所有文件，但不包括子目录："></a>忽略特定目录下的所有文件，但不包括子目录：</h3><p>  directory&#x2F;<em>.</em></p>
<h3 id="忽略特定目录下的所有文件，但包括子目录中的某些文件："><a href="#忽略特定目录下的所有文件，但包括子目录中的某些文件：" class="headerlink" title="忽略特定目录下的所有文件，但包括子目录中的某些文件："></a>忽略特定目录下的所有文件，但包括子目录中的某些文件：</h3><p>  directory&#x2F;*<br>  !directory&#x2F;subdir&#x2F;important.file</p>
<h2 id="特殊规则"><a href="#特殊规则" class="headerlink" title="特殊规则"></a>特殊规则</h2><h3 id="忽略隐藏文件"><a href="#忽略隐藏文件" class="headerlink" title="忽略隐藏文件"></a>忽略隐藏文件</h3><p>  以.开头的文件：.*</p>
<h3 id="忽略空目录"><a href="#忽略空目录" class="headerlink" title="忽略空目录"></a>忽略空目录</h3><p>  Git默认不跟踪空目录，但可以通过创建一个空的.gitkeep文件来跟踪：<br>  忽略所有空目录<br>  *&#x2F;<br>  但跟踪特定空目录<br>  !important_dir&#x2F;</p>
<h3 id="全局忽略文件"><a href="#全局忽略文件" class="headerlink" title="全局忽略文件"></a>全局忽略文件</h3><p>  在全局配置中设置，适用于所有项目：<br>  git config –global core.excludesfile ~&#x2F;.gitignore_global</p>
<h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><h3 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h3><p>  Git会按照.gitignore文件中的顺序匹配规则，后面的规则可能会覆盖前面的规则。</p>
<h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><p>  规则是相对于.gitignore文件所在目录的。</p>
<h3 id="全局忽略文件-1"><a href="#全局忽略文件-1" class="headerlink" title="全局忽略文件"></a>全局忽略文件</h3><p>  如果你有一些文件或目录在所有项目中都需要忽略，可以考虑使用全局忽略文件。</p>
<p>通过合理编写.gitignore文件，可以有效地管理项目中的不必要文件，保持仓库的整洁。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>寻路系统 PathFinding</title>
    <url>/Other/PathFinding/</url>
    <content><![CDATA[<p>寻路和障碍相关的方案</p>
<h1 id="障碍"><a href="#障碍" class="headerlink" title="障碍"></a>障碍</h1><h2 id="SDF"><a href="#SDF" class="headerlink" title="SDF"></a>SDF</h2><p>在项目中应用过对应的SDF。<br>参考实现是腾讯游戏开发精粹中提到的SDF方案。</p>
<h1 id="寻路-PathFinding"><a href="#寻路-PathFinding" class="headerlink" title="寻路 PathFinding"></a>寻路 PathFinding</h1><h2 id="AStar"><a href="#AStar" class="headerlink" title="AStar"></a>AStar</h2><p>AStar算法算是很基础的了。在2D类型的游戏中，AStar一般足够胜任大多数场景。<br>但在大地图，存在着对应的问题。<br>这里有着几个优化：</p>
<ol>
<li>启发函数优化</li>
<li>DoubleAStar - 正反向耗时平均和路径优化。</li>
<li>JPS</li>
<li>HPAStar</li>
</ol>
<h2 id="RecastNavigation"><a href="#RecastNavigation" class="headerlink" title="RecastNavigation"></a>RecastNavigation</h2><p>或者说是NavMesh。<br>学会了对应的算法后，对于2D地图，也能用，注意好边界的情况和容错就好。</p>
<p>官方项目:<br><a href="https://github.com/recastnavigation/recastnavigation">GitHub</a></p>
<p>这里有一篇非常详细的文章,个人看了感慨良多:<br><a href="https://zhuanlan.zhihu.com/p/592339133">Recast Navigation源码分析：导航网格Navmesh的生成原理</a><br>下面这篇也可以参考阅读:<br><a href="https://zhuanlan.zhihu.com/p/583887024">【Recast Navigation】SoloMesh源码分析（一）——概述</a></p>
<h3 id="三角剖分"><a href="#三角剖分" class="headerlink" title="三角剖分"></a>三角剖分</h3><p><a href="https://oi-wiki.org/geometry/triangulation/">三角剖分</a></p>
]]></content>
      <categories>
        <category>PathFinding</category>
      </categories>
      <tags>
        <tag>PathFinding</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转与四元数</title>
    <url>/Other/RotationAndQuaternion/</url>
    <content><![CDATA[<h1 id="旋转与四元数"><a href="#旋转与四元数" class="headerlink" title="旋转与四元数"></a>旋转与四元数</h1><h2 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h2><p>三维空间中的向量可以基于一组基向量来进行表示。<br>我们可以基于一组基向量来表示另外一组基向量。<br>由此我们可以进行空间转换。</p>
<img src="/Other/RotationAndQuaternion/image.png" class="" title="alt text">
<p>换言之 有以下操作：</p>
<img src="/Other/RotationAndQuaternion/image-1.png" class="" title="alt text">
<p>因此，在计算某个向量(全局)在某个对象局部坐标系下的值，<br>可以用该对象的Transform去计算逆矩阵，再对该向量进行左乘操作，从而得到局部空间向量。</p>
<h2 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h2><p><a href="https://zhuanlan.zhihu.com/p/1940774727674238008">为什么Roll、Pitch、Yaw的定义如此混乱？本文来讲透欧拉角的本质</a><br>一般需要规定旋转的顺序，确定内旋还是外旋(前者每次围绕自己当前的坐标系，后者围绕世界坐标系)，并约定对应的坐标轴。</p>
<p>用三个角度表示物体在三位空间中的旋转状态。<br>以Unity坐标轴为例： 采用 Z - X - Y ， 可以区分静态欧拉角（Space.World）和动态欧拉角（Space.Self）</p>
<ul>
<li>绕x轴旋转的俯仰角 Pitch</li>
<li>绕y轴旋转的偏航角 Yaw</li>
<li>绕z轴旋转的翻滚角 Roll</li>
</ul>
<h2 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h2><h3 id="万向锁问题"><a href="#万向锁问题" class="headerlink" title="万向锁问题"></a>万向锁问题</h3><p>基于欧拉角的旋转存在万向锁问题。<br>比如将Rotation的X设置为90度，此时对Y和Z的操作是相同的。<br>具体的可以网上去看看对应的文章，或者游戏引擎中试试。</p>
<h3 id="四元数乘法"><a href="#四元数乘法" class="headerlink" title="四元数乘法"></a>四元数乘法</h3><p>使用四元数可以避免万向锁的问题。</p>
<p>一些前置的思维：<br>欧拉公式: </p>
<img src="/Other/RotationAndQuaternion/image-2.png" class="" title="alt text">

<p>对于四元数乘法也是一样的，如果绕某个向量v旋转w，则可以左乘该四元数。</p>
<p>详细了解需要知道四维超球的概念。<br>而在旋转这块，我们只需要单位四维超球即可。</p>
<p>对于四元数p,左乘四元数q (w,v)即qp，其代表着绕v方向，右手法则，旋转一定角度(记为θ)，同时，沿着v方向”旋转”θ。</p>
<p>而对于给定向量v1，旋转θ度，我们可以构建四元数q,使得qw &#x3D; cos(θ&#x2F;2) qV &#x3D; sin(θ&#x2F;2)v1<br>这个时候，对点p，旋转后的 p’ &#x3D; qp(q-1)。</p>
<img src="/Other/RotationAndQuaternion/image-3.png" class="" title="alt text">]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>四元数</tag>
        <tag>Quaternion</tag>
        <tag>旋转</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下的Git账号更换</title>
    <url>/Other/windows-change-git/</url>
    <content><![CDATA[<h3 id="Hexo更换指定Git账号问题"><a href="#Hexo更换指定Git账号问题" class="headerlink" title="Hexo更换指定Git账号问题"></a>Hexo更换指定Git账号问题</h3><ul>
<li><p>Git内设置对应的账号和密码</p>
</li>
<li><p>控制面板 - 用户 - 凭据管理器 - Windows凭据删除对应git的凭据 在使用时重新通过网页处理凭据 </p>
</li>
<li><p>使用新账号登陆即可</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity异步操作</title>
    <url>/Mine/Unity/AsyncOp/</url>
    <content><![CDATA[<p>异步操作<br>可以参考这篇文章<br><a href="https://juejin.cn/post/7528690628806098995">Unity入门教程之异步篇第二节：协程 or UniTask？Unity 中异步流程到底怎么选</a><br><a href="https://www.bilibili.com/opus/847408446350295046">Unity异步扩展实践（一）——以UniTask库为参考</a></p>
<p>关于临界资源问题<br><a href="https://juejin.cn/post/7528436312074027054">Unity入门教程之异步篇第三节：多线程初探？理解并发与线程安全</a></p>
<h1 id="协程-逻辑异步-单线程"><a href="#协程-逻辑异步-单线程" class="headerlink" title="协程 - 逻辑异步 - 单线程"></a>协程 - 逻辑异步 - 单线程</h1><p>协程这块较为通用可以另外参考之前记录。</p>
<h1 id="UniTask"><a href="#UniTask" class="headerlink" title="UniTask"></a>UniTask</h1><p>本质上是利用C#的Task。<br>但是使用原生的async&#x2F;await和Task存在一些问题：</p>
<ul>
<li>GC和性能开销(Task本身是引用类型，且async&#x2F;await产生状态机对象和闭包)</li>
<li>线程切换不一定对。且Unity大部分API只能在主线程使用。</li>
<li>任务的生命周期管理问题:任务不会因为对象被销毁而自动停止</li>
<li>平台多线程限制（如WebGL）</li>
</ul>
<p>因此有UniTask<br><a href="https://github.com/Cysharp/UniTask">GitHub</a><br>优势和注意事项：</p>
<ul>
<li>零GC</li>
<li><strong>主线程调度</strong>。默认完全在Unity的PlayerLoop上运行，因此不使用Thread。<br>在 .NET 实现中，执行 await 语句之前和之后代码的线程是有可能不同的。虽然有线程切换，但我们不需要关心其中的细节，.NET 已经帮我们完成了其中的脏活累活，让结果看起来和单线程一致。<br>如果要使用多线程，可以看github示例:<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多线程示例，在此行代码后的内容都运行在一个线程池上</span></span><br><span class="line"><span class="keyword">await</span> UniTask.SwitchToThreadPool();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 工作在线程池上的代码 */</span></span><br><span class="line"><span class="comment">//Unity会限制非主线程上可以使用的API</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转回主线程（等同于 UniRx 的`ObserveOnMainThread`）</span></span><br><span class="line"><span class="keyword">await</span> UniTask.SwitchToMainThread();</span><br></pre></td></tr></table></figure>
以及方法RunOnThreadPool。</li>
<li>对于取消和异常情况需要特殊处理。了解CancellationToken相关内容</li>
</ul>
<p>对于空类型可以用UniTaskVoid。处理编译器警告-加上Forget()</p>
<blockquote>
<p>xxxx.Forget();</p>
</blockquote>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>在Unity 2022.2之后，Unity在MonoBehaviour.destroyCancellationToken和Application.exitCancellationToken中添加了 CancellationToken。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Cysharp.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UniTaskExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> GameObject _prefabToLoad;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _playerScore = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">object</span> _scoreLock = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line">    <span class="keyword">private</span> CancellationTokenSource _cancellationTokenSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _cancellationTokenSource = <span class="keyword">new</span> CancellationTokenSource();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 启动多个异步任务</span></span><br><span class="line">        RunMultipleTasksAsync().Forget(); <span class="comment">// Forget() 用于不需要等待的 UniTaskVoid</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 取消所有正在运行的任务</span></span><br><span class="line">        _cancellationTokenSource?.Cancel();</span><br><span class="line">        _cancellationTokenSource?.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> UniTaskVoid <span class="title">RunMultipleTasksAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 1. 等待一段时间</span></span><br><span class="line">            <span class="keyword">await</span> UniTask.Delay(TimeSpan.FromSeconds(<span class="number">1</span>), cancellationToken: _cancellationTokenSource.Token);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2. 异步加载资源（不会阻塞主线程）</span></span><br><span class="line">            GameObject loadedObject = <span class="keyword">await</span> Resources.LoadAsync&lt;GameObject&gt;(<span class="string">&quot;SomeAsset&quot;</span>)</span><br><span class="line">                .ToUniTask(cancellationToken: _cancellationTokenSource.Token) <span class="keyword">as</span> GameObject;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3. 实例化对象（必须在主线程执行）</span></span><br><span class="line">            Instantiate(loadedObject, transform.position, Quaternion.identity);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4. 并行执行多个任务</span></span><br><span class="line">            <span class="keyword">await</span> UniTask.WhenAll(</span><br><span class="line">                MoveObjectAsync(loadedObject, Vector3.up, <span class="number">2f</span>),</span><br><span class="line">                ChangeColorAsync(loadedObject, Color.red, <span class="number">1f</span>)</span><br><span class="line">            );</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 5. 使用线程安全的方式更新共享资源</span></span><br><span class="line">            <span class="keyword">await</span> UpdateScoreSafelyAsync(<span class="number">100</span>);</span><br><span class="line">            </span><br><span class="line">            Debug.Log(<span class="string">$&quot;最终分数: <span class="subst">&#123;_playerScore&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (OperationCanceledException)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 任务被取消时的处理</span></span><br><span class="line">            Debug.Log(<span class="string">&quot;任务被取消&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(<span class="string">$&quot;任务出错: <span class="subst">&#123;e.Message&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安全的分数更新方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> UniTask <span class="title">UpdateScoreSafelyAsync</span>(<span class="params"><span class="built_in">int</span> pointsToAdd</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 模拟一些异步工作（可能在后台线程运行）</span></span><br><span class="line">        <span class="keyword">await</span> UniTask.RunOnThreadPool(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 模拟复杂计算</span></span><br><span class="line">            System.Threading.Thread.Sleep(<span class="number">50</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对共享资源的访问需要加锁</span></span><br><span class="line">        <span class="keyword">lock</span> (_scoreLock)</span><br><span class="line">        &#123;</span><br><span class="line">            _playerScore += pointsToAdd;</span><br><span class="line">            Debug.Log(<span class="string">$&quot;分数更新: <span class="subst">&#123;_playerScore&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// UI 更新必须在主线程执行</span></span><br><span class="line">        <span class="keyword">await</span> UniTask.SwitchToMainThread();</span><br><span class="line">        UpdateScoreUI(_playerScore);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UpdateScoreUI</span>(<span class="params"><span class="built_in">int</span> score</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这里更新UI元素</span></span><br><span class="line">        Debug.Log(<span class="string">$&quot;更新UI显示分数: <span class="subst">&#123;score&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> UniTask <span class="title">MoveObjectAsync</span>(<span class="params">GameObject obj, Vector3 direction, <span class="built_in">float</span> duration</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">float</span> elapsedTime = <span class="number">0f</span>;</span><br><span class="line">        Vector3 startPosition = obj.transform.position;</span><br><span class="line">        Vector3 targetPosition = startPosition + direction;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (elapsedTime &lt; duration)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 检查是否取消请求</span></span><br><span class="line">            _cancellationTokenSource.Token.ThrowIfCancellationRequested();</span><br><span class="line">            </span><br><span class="line">            elapsedTime += Time.deltaTime;</span><br><span class="line">            <span class="built_in">float</span> t = Mathf.Clamp01(elapsedTime / duration);</span><br><span class="line">            obj.transform.position = Vector3.Lerp(startPosition, targetPosition, t);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">await</span> UniTask.Yield(); <span class="comment">// 等待下一帧</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> UniTask <span class="title">ChangeColorAsync</span>(<span class="params">GameObject obj, Color targetColor, <span class="built_in">float</span> duration</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Renderer renderer = obj.GetComponent&lt;Renderer&gt;();</span><br><span class="line">        Color startColor = renderer.material.color;</span><br><span class="line">        <span class="built_in">float</span> elapsedTime = <span class="number">0f</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (elapsedTime &lt; duration)</span><br><span class="line">        &#123;</span><br><span class="line">            _cancellationTokenSource.Token.ThrowIfCancellationRequested();</span><br><span class="line">            </span><br><span class="line">            elapsedTime += Time.deltaTime;</span><br><span class="line">            <span class="built_in">float</span> t = Mathf.Clamp01(elapsedTime / duration);</span><br><span class="line">            renderer.material.color = Color.Lerp(startColor, targetColor, t);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">await</span> UniTask.Yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按钮点击事件示例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnButtonClick</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 启动一个新任务来响应UI事件</span></span><br><span class="line">        HandleButtonClickAsync().Forget();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> UniTaskVoid <span class="title">HandleButtonClickAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 防止重复点击</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">await</span> CheckIfAlreadyProcessingAsync())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">await</span> UpdateScoreSafelyAsync(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">await</span> PlayButtonAnimationAsync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> UniTask&lt;<span class="built_in">bool</span>&gt; <span class="title">CheckIfAlreadyProcessingAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 模拟异步检查</span></span><br><span class="line">        <span class="keyword">await</span> UniTask.DelayFrame(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> UniTask <span class="title">PlayButtonAnimationAsync</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 模拟动画播放</span></span><br><span class="line">        <span class="keyword">await</span> UniTask.Delay(TimeSpan.FromSeconds(<span class="number">0.5f</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>重构:改善既有代码的设计</title>
    <url>/Books/Tech/%E9%87%8D%E6%9E%84/</url>
    <content><![CDATA[<h1 id="章节阅读总结"><a href="#章节阅读总结" class="headerlink" title="章节阅读总结"></a>章节阅读总结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>重构这本书主要还是要注重其重构的思想和应用方法。多读多看，真是一本好书。</p>
<h2 id="第二章-重构的原则"><a href="#第二章-重构的原则" class="headerlink" title="第二章 重构的原则"></a>第二章 重构的原则</h2><p>重构的概念：<br>在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本</p>
<ul>
<li>消除重复代码，改善设计</li>
<li>使得软件更容易理解</li>
<li>便于发现bug</li>
<li>提高编程速度[基于理解性和整体设计，新功能也更易于添加]</li>
</ul>
<p>小步进行。一致性和单步正确性。<br>”即便重构没有完成，也可以在任何时候停下来“</p>
<p>正如开头提到的那几句关键：<br>旧的不变，新的创建，一步切换，旧的再见。</p>
<p>重构、架构和YAGNI<br>“you arenot going to need it”<br>用重构来改善代码的设计，应对新需求的变化。<br>对于增加软件复杂度的灵活性机制，评估其重构难度，如果未来不难进行重构，可以维持简单设计的原则。”YAGNI”<br>“采⽤YAGNI并不表⽰完全不⽤预先考虑架构。总有⼀些时候，如果缺少预先的思考，重构会难以开展。但两者之间的平衡点已经发⽣了很⼤的改变：如今我更倾向于等⼀等，待到对问题理解更充分，再来着⼿解决。”</p>
<p>重点还是要区分好“重构”和“性能优化”。<br>在重构时，可能会让性能更好，也可能更差。但是代码的总体组织结构，和可读性都应该提升。<br>“先写出可以调优的软件，然后调优”</p>
<ul>
<li>性能改善一旦被分散到程序各个角落，每次改善的视角不可避免的会变得比较狭隘</li>
<li>大部分性能问题，其实都仅集中在一小段代码[一视同仁的优化很多时候都在做无用功]</li>
<li>“哪怕完全了解系统，需实际度量其性能，而不是臆测” 【还是要基于性能分析工具和度量】</li>
</ul>
<p>“两顶帽子”<br>重构时不添加新功能，明确自己是在重构还是在添加新功能。<br>可以切换，但明确自己目前在处理的内容</p>
<p>重构的时间：</p>
<ul>
<li>“事不过三，三则重构”</li>
<li>添加新功能</li>
<li>结合到开发中</li>
</ul>
<p>分支问题 - 基于主干的开发 持续集成【Continuous Integration CI】<br>可靠的测试 - 自测试代码 - 确保重构单步正确性。 </p>
<h2 id="第三章-代码的坏味道"><a href="#第三章-代码的坏味道" class="headerlink" title="第三章 代码的坏味道"></a>第三章 代码的坏味道</h2><ol>
<li>命名</li>
<li>重复代码</li>
<li>过长函数</li>
<li>过长参数</li>
<li>全局数据</li>
<li>可变数据</li>
<li>发散式变化- 上下文问题<br>a. 如果改某一个上下文还得处理另外一个，不能仅在系统的某一处进行修改</li>
<li>霰弹式修改<br>a. 如果遇到某种变化，必须要在许多不同的类内做很多小修改</li>
<li>依恋情结<br>a. 一个函数和其他模块的交互远远多于和自己模块内部的交互</li>
<li>数据泥团<br>a. 相同的多个字段，相同的参数<br>b. “删掉众多数据中的一项，其他是否也因此失去意义？若是则有必要去创建一个”</li>
<li>基本类型偏执<br>a. 创建合理有用的类型。比如电话号码等有意义和限制的类型</li>
<li>重复switch<br>a. 重复的switch，意味着要再增加新分支时，对所有switch进行处理。考虑多态。</li>
<li>循环语句Loop<br>a. 以管道取代循环 - 更清晰的显示处理的元素和动作</li>
<li>冗赘的元素<br>a. 简单和明显的代码不需要额外的包一层函数&#x2F;类</li>
<li>夸夸其谈通用性<br>a. 未使用，不必要的抽象类</li>
<li>临时字段<br>a. 指类中仅为特殊情况存在的字段 不易于理解（因为仅在某些条件才用到)</li>
<li>过长的消息链</li>
<li>中间人<br>a. 过多接口委托给了其他类</li>
<li>内幕交易<br>a. 模块之间的数据交互应该明显。共用数据放于管理良好的位置。或者使用另外一个模块作为中介。</li>
<li>过大的类</li>
<li>异曲同工的类</li>
<li>纯数据类</li>
<li>被拒绝的遗赠<br>a. 对于超类部分不想继承，拒绝实现<br>b. [以委托取代子类 “组合和继承的问题”]  </li>
<li>注释</li>
</ol>
<h2 id="第四章-构件测试体系"><a href="#第四章-构件测试体系" class="headerlink" title="第四章 构件测试体系"></a>第四章 构件测试体系</h2><p>自测试代码<br>“类应当包含他们自己的测试代码”<br>—— 确保所有的测试都自动化<br>添加新功能的同时，添加对应的测试。</p>
<p>测试驱动开发 Test Driven Development TDD 红-绿-重构的开发流程</p>
<p>重构需要测试。如果要对之前代码进行重构，改造其使其能自测试，然后再开始重构的工作。</p>
<p>入门自测试：<br>从不涉及用户界面、持久化或外部服务交互的代码。“一旦业务逻辑的部分开始变复杂，我就会将其与UI分离开，以便能更好地理解和测试它”</p>
<p>两个测试步骤：<br>1.设置好一些测试夹具（fixture）（测试所需要的数据和对象等）<br>2.验证测试夹具是否具备某些特性</p>
<p>以作者的输出来看: JavaScript -》 输出 1 passing (61ms)</p>
<p>确保测试按期望的方式去运作，在代码中暂时引入一个错误。总是确保测试不通过时真的会失败。</p>
<p>真实系统可能拥有数千个测试，而好的测试框架应该能帮助简单快速地运行测试。</p>
<p>作者的观点是：有失败测试时，不应该去重构，而是“回退到绿条”</p>
<p>风险驱动的测试，重点放在最担心出错的部分。且在编写单个测试时确保内部的准确性和正确性。</p>
<p>从游戏开发角度来说，UI方面本就不适合TDD，而游戏业务的复杂性和耦合，导致很多环境难以准备。<br>不过从个人实践而言，部分底层的逻辑还是可以考虑使用TDD的。在实际应用过程中还是保持灵活吧，不是为了TDD而TDD。在进行代码重构优化时，重点是确保前后的一致性。<br>这里有两篇相关讨论的网页：<br><a href="https://dev59.com/O3RB5IYBdhLWcg3wc280">在游戏开发中，测试驱动开发是一种常规的方法吗？</a><br><a href="https://gamedev.stackexchange.com/questions/7727/is-test-driven-development-viable-in-game-development">Is Test Driven Development viable in game development?</a></p>
<p>关于自动化测试本身，虚幻也有对应的文档：<br><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/automation-test-framework-in-unreal-engine">自动化系统概述</a></p>
<h1 id="总结和感想"><a href="#总结和感想" class="headerlink" title="总结和感想"></a>总结和感想</h1><p>很实用的一本书。无论是从思想还是从方法论上，都给人以很大启发。这是我们得以立即编码的重要武器。多翻翻吧，真的很有用。</p>
]]></content>
      <categories>
        <category>书本阅读</category>
      </categories>
      <tags>
        <tag>重构:改善既有代码的设计</tag>
      </tags>
  </entry>
  <entry>
    <title>人月神话</title>
    <url>/Books/Tech/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D/</url>
    <content><![CDATA[<h1 id="章节阅读总结"><a href="#章节阅读总结" class="headerlink" title="章节阅读总结"></a>章节阅读总结</h1><h2 id="第一章-焦油坑"><a href="#第一章-焦油坑" class="headerlink" title="第一章 焦油坑"></a>第一章 焦油坑</h2><p>对编程系统产品的一个概述。</p>
<p>点明了一些当前存在的问题。</p>
<ul>
<li>开发技术一直在进步，一旦设计被冻结，在概念上就已经开始陈旧。</li>
<li>对他人代码的依赖和相关文档的欠缺</li>
</ul>
<h2 id="第二章-人月神话"><a href="#第二章-人月神话" class="headerlink" title="第二章 人月神话"></a>第二章 人月神话</h2><p>合理的进度安排 【“重点”】</p>
<ul>
<li>不合理的原因</li>
<li>估算技术 （并非一切都会良好运行）</li>
<li>进度和工作量并不等同[人月衡量的问题]</li>
<li>进度监控和偏离预期时的人力问题。<br>作者的核心观点：”缺乏合理的进度安排时造成项目滞后的主要原因“</li>
</ul>
<p>阶段：<br>  构思 实现 交流</p>
<p>关于人月：<br>  培训和沟通成本</p>
<p>强调系统测试的重要性：<br>计划、编码和测试（构建测试和早期系统测试，系统测试） 在时间安排和最终的分配上，1&#x2F;3 1&#x2F;6 1&#x2F;4 1&#x2F;4<br>不过这里基于不同的项目和开发节奏，应该有所变更</p>
<p>向进度落后的软件项目增加人手，会使进度更加落后</p>
<ul>
<li>这里我感觉到没那么必然，只是管理者必须意识到，增加人手带来的额外开销。</li>
<li>独立任务的划分也很重要</li>
</ul>
<p>“项目的月数依赖于次序的约束，人员的最大数量依赖于独立子任务的数量”</p>
<h2 id="第三章-外科手术团队"><a href="#第三章-外科手术团队" class="headerlink" title="第三章 外科手术团队"></a>第三章 外科手术团队</h2><p>小型精英团队的问题 - 对于大型项目 所需要的时间太久了。<br>而正如之前所述，时间还是很重要的。 大型系统，不可否认需要大量人手。</p>
<p>大型项目分多个部分，每个部分由一个团队处理</p>
<p>外科手术团队 </p>
<ul>
<li>“仅一人操刀，而不是所有人都拿刀乱砍”</li>
</ul>
<p>外科手术团队的关键：</p>
<ol>
<li>有一个关键决策者</li>
<li>几个了解所有设计和全部代码的人</li>
<li>专业化分工</li>
</ol>
<p>大型项目：<br>每部分的概念完整性的提高<br>分解技术</p>
<p>重点核心感觉还是在降低沟通和决策的成本。首席程序员的作用。<br>工具维护人员和其他职能人员在于辅助，让重点人员不必要在部分代码上操心<br>在目前有AI工具的情况下，语言语法部分倒是有了比较大的提升。</p>
<p>从游戏开发角度出发，倒是在功能区分这块做的比较好。</p>
<h2 id="第四章-贵族制-民主制和系统设计"><a href="#第四章-贵族制-民主制和系统设计" class="headerlink" title="第四章 贵族制 民主制和系统设计"></a>第四章 贵族制 民主制和系统设计</h2><p>作者在这章主要描述的是外部规约。<br>“系统对外部世界（用户、其他系统）所呈现的行为、接口和功能的正式、精确的描述。它定义了系统“做什么”，而不是“怎么做”。”</p>
<p>其核心观点是 ：<br>少部分人，作为“架构工作者”，“贵族”，来确定外部规约，换句话说，确定系统的需求。<br>“架构的完整性的确要求系统只反映单一的哲学，用户所见的规约应该来自少数人的思想”<br>设计的一致性和概念的完整性： “设计来自一个人” </p>
<p>将架构工作与实现分离(这里的架构更偏重于当前的需求概念)<br>“架构陈述的是发生什么，而实现描述的是如何让它发生” </p>
<ul>
<li>从工作顺序上来讲，确定需求后，再进行执行。“架构 实现 实施”</li>
</ul>
<p>从游戏开发的角度来看，还是有挺多不同的。这里这里主要还是明确需求的设定吧。<br>定义好需求是什么。</p>
<h2 id="第五章-第二系统效应"><a href="#第五章-第二系统效应" class="headerlink" title="第五章 第二系统效应"></a>第五章 第二系统效应</h2><p>约束架构师的创造热情的准则和机制<br>  – 架构师和建造人员之间彻底、谨慎、和谐的交流</p>
<p>自律 - 第二系统效应</p>
<p>“第二个系统是一个人所设计过的最危险的系统”<br>—— 普通倾向是过度设计第二个系统，向系统添加很多修饰功能和想法<br>—— 另一个表现：存在对某些技术进行细化、精炼的趋势</p>
<p>“保持对特殊诱惑的警觉”<br>—— 避免那些对功能的过多修饰。<br>—— 避免延伸出会因假设和目的的变化而废除的功能。</p>
<p>第二系统效应其实来自于第一个系统开发和迭代过程中的经验和积累。以及对新框架需求的不确定性和拓展性设计。<br>这样看《重构》的理念和提到的东西真的是相辅相成的。<br>坚持“YAGNI”(you arenot going to need it)，如果需求变化了，有需要添加新的功能，可以先重构使得添加变得简单，再处理新功能。</p>
<p>当然，我认为这并不是说就不要做基础的设计，只是不要做的过多了。<br>从个人开发战斗框架相关的经验看，亦是如此。</p>
<h2 id="第六章-传递消息"><a href="#第六章-传递消息" class="headerlink" title="第六章 传递消息"></a>第六章 传递消息</h2><p>书面规约 - 手册</p>
<p>从游戏开发者的角度来说，需求案子。</p>
<p>版本日期<br>修改内容</p>
<p>处理原则的一致性（从工作经验来说，有点难，要看策划的文档水平了，比较还是每个人在写）</p>
<p>形式化和记叙性定义两种方式来进行规约<br>以一种作为标准，另外一种辅助。</p>
<p>会议 </p>
<ul>
<li>小组会议</li>
</ul>
<p>个人总结经验和实践教训：<br>作者本章主要强调了对于书面规约（需求文档）的重要性。文档本身需要描述清楚需求，有一致的编写规范。在多重实现（多模块并行开发）时，严格遵守对应的规约。<br>此外，需求也常是变动的，提到了会议和大会，明确架构师的主导权来确保可以拍板对应问题的方案。也提到了电话日志，通过电话日志来记录对应的反馈问题和回答。</p>
<p>基于个人项目开发经验：<br>在游戏行业中前端的需求主要还是策划案子驱动，对于一致性上应该还是比较难做到高要求保证。行业的需求多变性也意味着案子需常常更新。这块需要及时同步。三方会议，项目组周会都是比较好的实践方案。<br>但在执行过程中，或许测试的介入并没那么理想，还要多多注意吧。</p>
<h2 id="第七章-为什么巴别塔会失败"><a href="#第七章-为什么巴别塔会失败" class="headerlink" title="第七章 为什么巴别塔会失败"></a>第七章 为什么巴别塔会失败</h2><p>交流和组织的重要性：</p>
<p>1 非正式交流<br>2 常规项目会议<br>3 工作手册</p>
<p>工作手册<br>用于了解思路，并可以追溯设计<br>正确的文档结构</p>
<p>虽然道理比较简单，但是如何维护还是大问题。之前参与的游戏项目在程序侧的文档倒是真的很少。<br>因为需求变化很频繁，还是通过代码来而不是单独的文档。</p>
<p>不可否认的是，对于大型项目，文档还是比较必要的。例如虚幻引擎的文档。</p>
<p>组织：<br>交流成本 - 减少交流和协调的数量<br>人力分工和职能专门化<br>管理和技术<br>把时间放在重点问题上</p>
<h2 id="第八章-胸有成竹"><a href="#第八章-胸有成竹" class="headerlink" title="第八章 胸有成竹"></a>第八章 胸有成竹</h2><p>在进行项目时间估计时，不可简单地仅从编码的量来估计。<br>计划、编制文档、测试、系统集成和培训的时间必须被考虑在内。<br>“对于短跑数据做线性外推是没有意义的。就好像把百码短跑时间外推，得出人类可以在3分钟内跑完1英里的结论一样”</p>
<p>一项研究（不一定准）<br>工作量 &#x3D; 常数 X 指令的数量^1.5 【幂函数】</p>
<p>作者强调，在估计时间的时候，不能过于理想化：</p>
<ol>
<li>其他业务和意外的时间</li>
<li>大量交互时的效率下降<br>大约实际耗时为估计的2倍 。而且项目在发展过程中，随着项目规模的变大，对应的编程和调试速度都有下降</li>
</ol>
<p>作者这章主要还是说明，在估计的时候要多去考虑一下其他因素。并举了一些相关的数据例子来说明实际的情况。合理的项目规划和时间安排还是比较重要的，在游戏开发行业亦是如此。实际上也经常会有各种问题打断当前的开发进度。在估时的时候，最好不要仅按程序工作量来估。测试方面的流程和时间，从个人经验来说，是比较紧缺的（这样导致了许多问题和线上修复。）还是看能不能学习和吸取一些教训吧。</p>
<h2 id="第九章-削足适履"><a href="#第九章-削足适履" class="headerlink" title="第九章 削足适履"></a>第九章 削足适履</h2><p>规模控制<br>研究用户及其应用，设置待开发系统的规模。 “规模-速度”权衡方案</p>
<p>作者这里提出了几点：<br>1 和定制驻留空间预算一样，应该指定总体规模预算；和定制规模预算一样，应该制定后台存储访问的预算<br>2 在规定模块有多大的同时，确切定义模块的功能<br>3 编程人员在优化个人相关的部分时，系统架构师需要保持警觉性，确保连贯的系统完整性。从系统整体出发、面向用户</p>
<p>用功能换空间【存储空间和内存空间】<br>考虑空间与时间折中【培训，常用功能的高效实现方案】</p>
<p>“表达时编程的本质”<br>战略上的突破常来自数据或表的重新表达<br>—— 通过重构数据的组织方式、结构或抽象模型，从根本上解决复杂性问题</p>
<p>现代的硬件相比较过去有了非常大的发展和进步。无论是存储空间还是内存空间。<br>不过即便如此，现代游戏的内存占用（或者到显存），也时常是优化的一个重点。（这里不得不提怪物猎人：荒野的多边形怪兽了）。而存储空间也是很多游戏会考虑的一个点。（特别是部分要考虑首包的）</p>
<p>不过从程序角度而言，如果不是小程序（强调小首包），代码方面的实际硬件占用空间是非常小的。<br>而另一方面，对于性能（如CPU占用开销）和内存空间（进一步到显存空间），相关的理念还是适用的。</p>
<p>对于游戏项目，或许还是辩证思考，一方面游戏本身的迭代开发很快，和书本中的操作系统不太一样，另一方面，有《重构》的指导思想，在敏捷开发的过程中，去实际进行性能测试并针对热点改善，效率或许会更高。</p>
<p>总而言之，在开发过程中有意识的去考虑些性能热点以及内存占用热点，在重构的时候考虑数据的表达方式，应该都是挺有帮助的。</p>
<h2 id="第十章-提纲挈领"><a href="#第十章-提纲挈领" class="headerlink" title="第十章 提纲挈领"></a>第十章 提纲挈领</h2><p>文书工作：<br>文档的跟踪、维护机制是项目监督和预计的机制。<br>本身可以作为检查列表、状态控制的依据，也可以作为汇报的数据基础。</p>
<p>产品文档 【时间、地点、人员、项目内容和资金】</p>
<ul>
<li>目标</li>
<li>规约[手册加上性能规约]</li>
<li>进度</li>
<li>预算</li>
<li>组织结构图</li>
<li>工作空间的分配<br>估算、预测、价格</li>
</ul>
<h2 id="第十一章-未雨绸缪"><a href="#第十一章-未雨绸缪" class="headerlink" title="第十一章 未雨绸缪"></a>第十一章 未雨绸缪</h2><p>“试验性工厂”的概念<br>—— 为舍弃而计划</p>
<p>“唯一不变的就是变化本身” </p>
<p>由此，我们需要为变更提前做准备：</p>
<ol>
<li>为变更设计系统<br>作者强调了高级语言和自文档技术(指通过编写清晰、结构化和表达性强的代码本身来减少对独立外部文档的依赖。“代码应当是首要且最准确的文档来源”)</li>
</ol>
<p>以及变更的阶段化，数字版本号，以及对应的日程表和冻结日期。</p>
<p>从游戏开发的角度亦是如此。在游戏开发过程中，有着对应的开发版本规划。不过代码的迭代和需求变更也是常事。个人觉得在设计的时候未雨绸缪是一件好事，但还是保持不过度设计，做好模块的解耦，利用好重构的方法更好一些。</p>
<ol start="2">
<li>为变更计划组织架构<br>设计文档 —— 将自己暴露在每个人的批评之下<br>少数顶级程序作为“技术轻骑兵”可以灵活安排 （从事实际的编程工作）</li>
</ol>
<p>比较全能的思想 —— “项目目标、进展和管理问题必须在所有高层人员红得到共享”</p>
<p>管理人员也要技术课程，高级技术人员也要有管理培训</p>
<p>个人并不否认两者结合的好处，不过也看到现实的一些问题。项目组确实有人身居高位只管理而脱离底层太久，对技术细节没有了解，而自己在技术发展过程中，也会遇到不能单打独斗，需要带领小组一起攻坚的问题。<br>在发展过程中，个人会认为还是一条为主，一条为辅吧。（还是要有兼顾辅路线的心态和准备）。</p>
<p>前进两步 退后一步<br>程序维护 和 Bug相关的问题  —— “缺陷修复总会以固定的概率引入新的Bug”<br>回归测试的重要性和对应的成本</p>
<p>前进一步 后退一步<br>所有修改都倾向于破坏系统的架构，增加了系统的混乱程度。<br>崭新的、基于原有系统的重新设计是完全必要的。</p>
<p>在游戏行业从事，可以说和变化相处的很多。大版本的需求变化，版本内的需求变更，都是常态。<br>作者在本章主要点明了对应的问题，也基于此提出了为变更设计系统和为变更计划组织框架两点。但在具体实施细节上并没有阐述很多。</p>
<p>对于前进两步，退后一步和前进一步，退后一步的两个问题，个人认为是想先点出现实问题，管理层需要在版本规划和时间分配上明确对应的潜在风险和成本。<br>从开发者角度来说，如何解决对应的问题呢？特别是在游戏行业。</p>
<p>我个人还是基于项目经验和最近阅读的书做些不成熟的建议：</p>
<ol>
<li>新功能开发时，可以在合理范围内做好拓展性和设计，避免和现有功能过度耦合。</li>
<li>当然，随着需求变更，或者版本排期时间紧问题，一些临时功能在开发时，常常会逐步导致系统模块和功能的耦合性增加</li>
<li>利用好《重构》武器，优化可读性和耦合度</li>
<li>必要的时候，可以对框架进行优化修改。但是需要提高警惕心，做好对应的测试工作。</li>
</ol>
<p>自己在开发RPG战斗框架时，几个月时间便对战斗流程梳理更改了好多次，以支持策划的新功能。当然，这块也是要明确和策划沟通清楚，强调重构和优化的重要性。<br>我想也是因为这些工作和开发，项目的战斗总体上比较顺利。算是“未雨绸缪”了。</p>
<h2 id="第十二章-干将莫邪"><a href="#第十二章-干将莫邪" class="headerlink" title="第十二章 干将莫邪"></a>第十二章 干将莫邪</h2><p>工具<br>通用工具和专业工具  以及专门为此开发的人员和资源</p>
<p>设备、实用程序、调试辅助程序、测试用例生成工具和处理文档的字处理系统。</p>
<p>要读懂这章，需要站在最上层管理者、项目经理的角度来思考问题。</p>
<p>目标机器<br>—— 某种程度是可以认为是测试设备。<br>因为开发进度原因，都是早期使用需求低，晚期使用需求高。在目标设备有限且少数的情况下，可以考虑分配安排时间块的方式进行管理，提高生产率。</p>
<p>辅助机器和数据服务<br>仿真装置 —— 稳定可靠的平台。（这里对于软件开发者应该是相同，部分bug可能来自于运行平台的问题。且新设备如果不稳定会对开发有比较大的影响）<br>编译器和汇编平台 —— 从游戏行业的角度出发，个人认为，比如打包机。 稳定的打包环境和设备。<br>程序库和管理 —— 从逻辑功能上可以认为类似于SVN源码管理，以及个人的分支（或者说是子项目分支）。开发有对应的备份管理，并有release，使得进展变得正式。[当然，这里还要考虑第三方库&#x2F;插件的使用、升级，以及引擎版本的升级等问题]<br>编程工具 —— 现在的软、硬件已经有很大进步了。不过，项目组一般都会有统一的开发环境（如一些必要插件等）<br>文档系统 —— 类似项目组的知识库。作者提到了“OS&#x2F;360的文档规模是机器庞大的，但阅读计划是被仔细安排的。”<br>性能仿真装置 —— 性能测试</p>
<p>高级语言和交互式编程<br>现代编程，在不涉及到底层系统的软件，在高级语言方面的应用算是常态了。<br>交互式编程个人觉得还是看应用场景。对于游戏开发者而言，编辑器环境的运行时热重载（如lua或者js）个人认为是加分项而不是必须品。</p>
<h2 id="第十三章-整体部分"><a href="#第十三章-整体部分" class="headerlink" title="第十三章 整体部分"></a>第十三章 整体部分</h2><p>开发一个可以运行的系统，测试系统，将经过测试的一系列构件集成到已测试过、可以依赖的系统</p>
<p>剔除bug的设计<br>防范bug的定义 —— 产品的概念完整性  细致的功能定义、仔细的规格说明、规范化的功能描述说，以及这些方法的实施。<br>测试规格说明 —— 提供给外部测试小组，详细的检查说明的完整性和明确性。<br>自上而下的设计 —— 体系化结构设计、设计实现和物理编码实现。模块的独立性，以及细节抑制。<br>结构化编程 —— 以规范化的控制结构组织程序逻辑，使得程序更易于理解，逻辑更清晰</p>
<p>系统集成调试<br>使用经过调试的构件单元 —— 实际的应用过程中，不一定是在所有构件测试运行完后再开始。这里的观点是，在系统测试中使用完好的、经过调试的构件，能比搭建测试平台和进行全面的构建单元测试节省更多时间。<br>搭建充分的测试平台 —— 伪构件(提供接口和伪数据)，以及辅助程序（开发专用的辅助工具）<br>控制变更 —— 对变更和差异的记载，在一个日志中记录所有的变更。<br>一次添加一个构件 —— 注意完整的测试用例和回归测试<br>阶段化、定期变更 —— 将使用中的构件替换成新版本。注意系统化测试流程。阶段化和定期发布，确保稳定的生产周期。作者的观念和经验是，采用阶段大、间隔宽而不是阶段小而频繁。</p>
<p>关于测试方面，结合游戏经验，对于控制变更，可以单独提对应的bug单来处理，而阶段化、定期变更，更像是版本切分支。所有的目标都还是为了维护系统的稳定性，同时确保更改可以追溯。</p>
<p>而在硬件方面的论述和测试，因为和当代差别非常大，这里就不赘述了</p>
<h2 id="第十四章-祸起萧墙"><a href="#第十四章-祸起萧墙" class="headerlink" title="第十四章 祸起萧墙"></a>第十四章 祸起萧墙</h2><p>“延迟的时间是一天天积累下来的”</p>
<p>里程碑的定义和具体作用与限制<br>—— 明显边界和无歧义的里程碑</p>
<p>合理的里程碑规划，以及定时进行的里程碑修订</p>
<p>滞后的影响 —— PERT和关键路径。<br>整个网状结构的展开、任务之间的依赖关系识别和各个任务链的估计</p>
<p>面对滞后的问题:<br>两种信息：需要采取行动计划的问题和用来分析的状态数据。<br>隐藏的问题 —— 项目经理和老板的利益冲突 由此而导致问题被隐藏<br>作者提出的两种方法：<br>1 减少角色冲突和鼓励状态共享<br>2 猛地拉开地毯 —— 定期的总体评审 揭露问题</p>
<p>作者主要强调了项目进度的问题。里程碑边界清晰的重要性。整个团队需要明确关键路径，以及自己的任务是否处于关键路径之上。<br>有必要对计划和控制职能进行人力投资，明确项目的实际进展，关注PERT的更新、修订和报告。</p>
<p>从个人经验和实际实践角度出发，这章看起来是讲大道理，但对关键路径的重视、设定里程碑的具体时间点、计划各个任务的具体时间点这些做法，还是要予以重视的。<br>里程碑的明确性 —— 明确这个版本的主要目标 对于大型子模块而言，如多久能够前后端联调，多久能给策划一个什么样的基础表现<br>关键路径 —— 多人开发大功能时，哪些是互相影响的？ 比如某个玩法的开发是否基于战斗开发之上？<br>任务的具体时间点 —— 每个需求子单的完成时间点。</p>
<p>其实个人做其他事情也是类似的。在进行规划后，明确重点，并总结统计具体的完成状况，才能有比较好进展。</p>
<p>PERT图(Program Evaluation Review Technique) 计划评审技术图<br>项目分解、识别依赖、估算时间、构件网络、计算与分析</p>
<h2 id="第十五章-另外一面"><a href="#第十五章-另外一面" class="headerlink" title="第十五章 另外一面"></a>第十五章 另外一面</h2><p>文档的重要性。<br>以及如何去编写产生优秀的文档</p>
<p>需要什么文档 依据用户的不同需求来进行编写</p>
<p>使用程序<br>目的、环境、范围、实现的功能和使用的算法、输入和输出的格式、操作指令、选项、运行时间、精度和校验</p>
<p>验证程序 —— 测试用例</p>
<p>修改程序<br>流程图或子系统的结构图<br>对所用算法的完整描述<br>对所有文件规划的解释<br>数据流处理的概要描述<br>初始设计中，对已预见修改的讨论</p>
<p>自动文档化的程序<br>基础的函数编写等不再赘述<br>代码的格式一致性和空格应用<br>以段落注释的形式，插入必要的记述性文字</p>
<p>读书学习知识必须要和实际应用结合在一起。提取其中的精华理念并真正的理解和灵活运用。并不是死板地搬运。<br>对于不同的项目有着把不同的适用场景。</p>
<p>对于游戏行业的软件开发而言，自文档化我认为是非常有用的思想。也能够帮助维护好代码的结构。<br>而在“使用程序”方面，可以多看看GitHub上面的项目。<br>流程图没必要太死扣格式和形式，重点在于帮助理解。对于复杂的战斗可以作图进行沟通。从个人实践而言，比如对战斗流程和技能流畅，可以编写对于的流程图来梳理逻辑并和其他岗位的同学进行交流。</p>
<h2 id="剩余内容"><a href="#剩余内容" class="headerlink" title="剩余内容"></a>剩余内容</h2><h3 id="第十六章-没有银弹-十七章-再论“没有银弹”"><a href="#第十六章-没有银弹-十七章-再论“没有银弹”" class="headerlink" title="第十六章  没有银弹 十七章 再论“没有银弹”"></a>第十六章  没有银弹 十七章 再论“没有银弹”</h3><p>根本困难：规格说明、设计和测试这些概念上的结构<br>次要困难：软件、对应概念的实现</p>
<h3 id="第十八章-《人月神话》的观点：是与非"><a href="#第十八章-《人月神话》的观点：是与非" class="headerlink" title="第十八章 《人月神话》的观点：是与非"></a>第十八章 《人月神话》的观点：是与非</h3><p>对之前的章节的重要观点做了详细的概述</p>
<h3 id="第十九章-20年后的《人月神话》"><a href="#第十九章-20年后的《人月神话》" class="headerlink" title="第十九章 20年后的《人月神话》"></a>第十九章 20年后的《人月神话》</h3><p>概念完整性和架构师<br>明确需求目标，明确用户群 —— 第二系统的问题<br>错误的瀑布模型和增量开发<br>面向对象、接口，通过信息隐藏来提高软件设计水平<br>人月神话 —— 人力和时间的平衡远不是线性关系<br>“人就是一切” </p>
<h1 id="总结和感想"><a href="#总结和感想" class="headerlink" title="总结和感想"></a>总结和感想</h1><p>软件行业的发展是非常迅速的。<br>在20世纪70年代的《人月神话》，包括10年后再写的第十七章，再论“没有银弹”，再到20年后的人月神话，和现在仍然有几十年的差距。</p>
<p>而这几十年，硬件和软件行业的发展无疑是非常迅速的。作者的部分案例和观点到如今或许不太使用，但核心观点，根据实际的项目情况和经验，还是很值得学习参考的。</p>
<p>读书，不是读死书。理解其观点、核心，并基于当代的实际情况实践应用，才能有更好的成长。</p>
<p>软件的复杂性，游戏行业迅速的迭代和紧迫的版本规划，都在展示着当今的问题。</p>
<p>个人并不追求“银弹”，因为在此之前，就有许多要解决的问题。需求的排期，项目架构的设计、交流，人月的观点等等。</p>
<p>作者在19章 “20年后的《人员神话》》”中有那么一小段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;这本书如何？你有什么想法吗？&quot;</span><br><span class="line">“噢！这里面的东西我早就知道。”</span><br></pre></td></tr></table></figure>
<p>我并不会自负的说这里面的东西我早就知道，不过部分章节，作者在提出部分观点的时候，我会觉得这就应该是软件项目开发的思维。很庆幸，在大学中所学到的，给我养成了类似的思维。</p>
<p>虽然对于根本困难——概念性的结构，在游戏行业中，我们很难说做的很完美，（虽然是策划定的，但我们也可以发挥主观能动性，避免不合理、不规范的需求），但在次要困难上，我们有了很多当代工具。电子文档的组织、自文档的代码编写思想，以及强大的武器——重构，可以让我们的项目更健壮些，提高编码效率。</p>
<p>当然，对于沟通交流，以及人月的工作量计算、关键路径等问题，在实践中还是需要多留意。</p>
<p>引用作者最后一句话结束吧：<br>“良好的自我判断以及能够使我们认识到自己的不足——谦逊的品格”。<br>在思考和学习中去成长吧，在这片广阔的天地。</p>
]]></content>
      <categories>
        <category>书本阅读</category>
      </categories>
      <tags>
        <tag>人月神话</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity Animation</title>
    <url>/Mine/Unity/Animation/</url>
    <content><![CDATA[<h1 id="Mecanim-动画系统"><a href="#Mecanim-动画系统" class="headerlink" title="Mecanim 动画系统"></a>Mecanim 动画系统</h1><p>Mecanim Animation System<br><a href="https://docs.unity3d.com/6000.0/Documentation/Manual/AnimationSection.html">Unity6 动画系统</a></p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><blockquote>
<p>Animate the properties of models and assets.</p>
</blockquote>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>基于Animation Clips的概念。</p>
<h2 id="Animation-Clip"><a href="#Animation-Clip" class="headerlink" title="Animation Clip"></a>Animation Clip</h2><p>包含对象随着事件如何改变位置、旋转或其他属性的相关信息。</p>
<p>外部导入或者Unity内部创建。<br>Clip相关功能：</p>
<ul>
<li>Transform信息</li>
<li>组件属性</li>
<li>Scripts中的属性</li>
<li>特定时间调用函数</li>
</ul>
<h3 id="Animation-Event"><a href="#Animation-Event" class="headerlink" title="Animation Event"></a>Animation Event</h3><ul>
<li>仅支持单个参数的函数</li>
</ul>
<p>用AnimationEvent Object来传递多个参数：<br>支持一个int,一个float,一个string,一个GameObject引用。</p>
<h2 id="Humanoid-Avatar"><a href="#Humanoid-Avatar" class="headerlink" title="Humanoid Avatar"></a>Humanoid Avatar</h2><blockquote>
<p>The rigged character model,has a specific configuration of bones mapped to Unity’s Avatar format.</p>
</blockquote>
<p>为人形专门设定。<br><a href="https://docs.unity3d.com/6000.0/Documentation/Manual/ConfiguringtheAvatar.html">Importing a model with humanoid animations</a></p>
<p>绑定角色模型 转换为Avatar，进行骨骼、肌肉等绑定和映射。</p>
<p>支持动画重定向、前向和反向动力学。</p>
<h3 id="Root-Motion"><a href="#Root-Motion" class="headerlink" title="Root Motion"></a>Root Motion</h3><p><a href="https://docs.unity3d.com/6000.0/Documentation/Manual/RootMotion.html">How Root Motion works</a><br>和Animator是否启用Apply Root Motion以及Animation Clip中Root Transform 是否Bake Into Pose相关。如果Bake Into Pose则无Root Motion.</p>
<h2 id="Animator-Component"><a href="#Animator-Component" class="headerlink" title="Animator Component"></a>Animator Component</h2><ul>
<li>Animator Controller</li>
<li>Avatar (对于人形 - Humanoid Character)</li>
<li>Apply Root Motion</li>
<li>Update Mode<ul>
<li>Normal:和Update调用同步。受到当前timescale影响。</li>
<li>Animate:Physics 和FixedUpdate调用同步。</li>
<li>Unscaled:Time 和Update调用同步。但忽略当前的timescale，以100%速度进行动画处理。（如Gameplay中暂停，而GUI用这样的动画。）</li>
</ul>
</li>
<li>Culling Mode<ul>
<li>决定在屏幕外是否剔除</li>
<li>Always Animate</li>
<li>Cull Update Transforms:（When renderers are not visible）,禁用重定向、IK和Transform的写入</li>
<li>Cull Completely:（When renderers are not visible）完全禁用</li>
</ul>
</li>
</ul>
<h2 id="Animation-Controller"><a href="#Animation-Controller" class="headerlink" title="Animation Controller"></a>Animation Controller</h2><p><strong>动画状态机</strong>。确定当前播放的Clip，何时改变以及混合。</p>
<ul>
<li>Animation Clips</li>
<li>Animation Transitions</li>
<li>Events</li>
<li>Sub-State Machines</li>
</ul>
<h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h3><p>动画机参数，可以在Script中访问和设置的值。用于控制影响状态机。</p>
<blockquote>
<p>SetFloat、SetInteger、SetBool、SetTrigger(在未消耗前会一直处于激活) 和 ResetTrigger。<br>GetFloat、GetInteger、GetBool、GetTrigger。</p>
</blockquote>
<h3 id="Layers"><a href="#Layers" class="headerlink" title="Layers"></a>Layers</h3><p>创建不同的动画层。<br>可以用层来控制角色不同部分的动画。<br>使用Avatar Mask来制定应用的身体部位。<br>设置Blending属性来控制如何混合动画。</p>
<p>Weight:控制层级的影响幅度。</p>
<p>Sync - 同步层级节点。 可以减少复制工作量。但是Timing可能也会依据同步层级。如果需要单独当前层级的时间影响，勾选Timing。具体的Timing，受到Weight、同步的层级、当前层级三者影响。</p>
<h3 id="Animation-States"><a href="#Animation-States" class="headerlink" title="Animation States"></a>Animation States</h3><p>可以参考B站对应的视频来进一步了解细节。<br><a href="https://www.bilibili.com/video/BV1WL411c7mK/">【Unity动画系统详解 九】Write Defaults</a><br>动画状态。</p>
<p>Motion - 可以使用AnimationClip或者BlendTree。<br>Mirror - 仅适用于Humanoid Animation，镜像。<br>Motion Time - 控制动画Clip对应的时间 如果不代码控制，则会停留在对应的时刻不动。<br>Cycle Offset - 适用于循环动画，参数为0~1，可以控制从不同时间开始循环。<br>Foot IK - 主要还是用于动画重定向的修正，并不是地形的IK修正。<br>Write Defaults:”Whether the AnimatorStates writes the default values for properties that are not animated by its motion”：所以最好不要用。</p>
<ul>
<li>Animator Component在OnEnabled时会遍历所有动画状态，确定这些状态修改了哪些属性，并记录其对应的当前值。作为默认值。如果启用Write Default，某个状态没有用到某个属性时，就会取默认值来处理。</li>
</ul>
<h4 id="AnyState"><a href="#AnyState" class="headerlink" title="AnyState"></a>AnyState</h4><p>可以用做任何状态的转移。</p>
<h4 id="Transitions"><a href="#Transitions" class="headerlink" title="Transitions"></a>Transitions</h4><p>两个状态间可以设置多个Transition，每个可以设置不同的条件和参数。<br>多个Transition之间的关系为或，每个Transition的多个条件之间的关系为与。</p>
<p>Solo和Mute，Mute会禁用转移。</p>
<blockquote>
<p>If one transition has Solo enabled, Unity enables Mute on the other transitions.</p>
</blockquote>
<h5 id="Exit-Time"><a href="#Exit-Time" class="headerlink" title="Exit Time"></a>Exit Time</h5><p>勾选 Has Exit Time<br>勾选后必须等当前状态播放到Exit TIme才会执行转换，否则不转换。会避免立刻转换的</p>
<h5 id="Interruption"><a href="#Interruption" class="headerlink" title="Interruption"></a>Interruption</h5><ul>
<li>和Transitions本身的Interruption Source相关。</li>
<li>Ordered Interruption:只有优先级比当前高的才能打断。</li>
</ul>
<h4 id="Animation-Blend-Trees"><a href="#Animation-Blend-Trees" class="headerlink" title="Animation Blend Trees"></a>Animation Blend Trees</h4><p>用于动画混合。<br>通过不同程度合并每个动画的各个部分来平滑地混合多个动画。一般用于跑步动画等。<br>在多个动画混合时还算有不错的效果。</p>
<p>支持1D、2D、Direct混合等多种模式混合。</p>
<h4 id="State-Machine-Behaviours"><a href="#State-Machine-Behaviours" class="headerlink" title="State Machine Behaviours"></a>State Machine Behaviours</h4><p>状态机行为 - 特殊脚本<br>将Script附加到单个状态上。<br>继承自StateMachineBehaviour。</p>
<ul>
<li>OnStateEnter<ul>
<li>First update frame.</li>
</ul>
</li>
<li>OnStateUpdate<ul>
<li>Invoked on each update frame except for the first and last frame.</li>
</ul>
</li>
<li>OnStateExit<ul>
<li>Last update frame</li>
</ul>
</li>
<li>OnStateMove<ul>
<li>Invoked during the Animator <strong>Root Motion</strong> pass.</li>
</ul>
</li>
<li>OnStateIK<ul>
<li>Invoked during the Animator IK pass.</li>
</ul>
</li>
</ul>
<h3 id="Animator-Override-Controller"><a href="#Animator-Override-Controller" class="headerlink" title="Animator Override Controller"></a>Animator Override Controller</h3><p>在维持State Machine的同时，去修改对应的Animation Clip。</p>
<h1 id="Playables-API"><a href="#Playables-API" class="headerlink" title="Playables API"></a>Playables API</h1><p>实际上Timeline和Animator底层实现都是PlayableAPI。</p>
<p>使用<strong>树形结构PlayableGraph</strong>来对多个数据源进行mix,blend,modify，并最终通过单独输出进行播放。</p>
<p>基于Animator驱动，但原本的Animator组件不需要再设置Animator Controller。</p>
<p>可视化工具:<br><a href="https://github.com/Unity-Technologies/graph-visualizer">GitHub - graph-visualizer</a><br>相关参考视频教程：<br><a href="https://www.bilibili.com/video/BV1SP4y177YQ/">BiliBili Playable 动画系统</a><br>配套的GitHub <a href="https://github.com/IrisFenrir/Fenrir-RPG/tree/main/Scripts/Animation">Fenrir-RPG</a><br>文章:<br><a href="https://zhuanlan.zhihu.com/p/380124248">【Unity】简单使用Playable API控制动画</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzkyMTM5Mjg3NQ==&mid=2247535622&idx=1&sn=b96a2d8ac55b49e74261d91bbffa944c&source=41&poc_token=HI8V3mijCNt_phpQCp1RQT70prtaCq08gh1G_Wh4">微信 Playable API：定制你的动画系统</a></p>
<p>For:</p>
<ul>
<li>animation</li>
<li>audio</li>
<li>scripts</li>
</ul>
<p>优势：</p>
<ul>
<li>允许动态动画混合。可以混合场景中的多个对象</li>
<li>允许简单的播放单个动画</li>
<li>允许动态创建Blending Graphs并逐帧控制混合权重。</li>
<li>允许<strong>运行时创建</strong>PlayableGraph</li>
</ul>
<h2 id="PlayableGraph"><a href="#PlayableGraph" class="headerlink" title="PlayableGraph"></a>PlayableGraph</h2><p>图中每一个节点可以认为是一个“Playable”。</p>
<blockquote>
<p>A C# struct that implements the IPlayable interface</p>
</blockquote>
<p>使用Struct实现以避免垃圾回收。<br>除了PlayableBehaviour以外。</p>
<p><strong>Playable</strong></p>
<img src="/Mine/Unity/Animation/playable.png" class="" title="Playable">

<p><strong>PlayableOutput</strong></p>
<img src="/Mine/Unity/Animation/playableoutput.png" class="" title="alt text">

<p>Playable和PlayableOutput本身并没有太多的公开接口，可以使用静态类PlayableExtensions和PlayableOutputExtensions来进行辅助处理。</p>
<h3 id="ScriptPlayable-和-PlayableBehaviour"><a href="#ScriptPlayable-和-PlayableBehaviour" class="headerlink" title="ScriptPlayable&lt;T&gt; 和 PlayableBehaviour"></a>ScriptPlayable&lt;T&gt; 和 PlayableBehaviour</h3><p>官方文档的示例：<br><a href="https://docs.unity3d.com/6000.0/Documentation/Manual/Playables-Examples.html">Playables Examples</a><br>拓展阅读<br><a href="https://zhuanlan.zhihu.com/p/380710676">【Unity】自定义Animation Playable与Timeline结合</a></p>
<p>PlayableBehaviour:</p>
<blockquote>
<p>Is the base class from which every custom playable script derives.</p>
</blockquote>
<p>用户自定义的类，来对Playable进行直接的访问和控制。</p>
<ul>
<li>可以用于侦听和处理Graph相关的事件。如Start(Graph.Play()时触发)、Stop等</li>
<li>每帧动画计算流程的回调 - PrepareFrame</li>
</ul>
<p>总体上还是起一个封装的效果。</p>
<p>创建示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">ScriptPlayable&lt;MyCustomPlayableBehaviour&gt;.Create(playableGraph);</span><br><span class="line"><span class="comment">//或者已经创建对象的情况下：</span></span><br><span class="line">MyCustomPlayableBehaviour myPlayable = <span class="keyword">new</span> MyCustomPlayableBehaviour();</span><br><span class="line">ScriptPlayable&lt;MyCustomPlayableBehaviour&gt;.Create(playableGraph, myPlayable);</span><br></pre></td></tr></table></figure>


<h3 id="更新频率"><a href="#更新频率" class="headerlink" title="更新频率"></a>更新频率</h3><p>可以通过Graph设置更新频率。SetTimeUpdateMode，枚举为DirectorUpdateMode。</p>
<ul>
<li>DSPClock:基于DSP(Digital Sound Processing) clock的更新，用于与声音同步。</li>
<li>GameTime:基于Time.time的更新，当Time.timeScale &#x3D; 0，动画也会暂停。</li>
<li>UnscaledGameTime:基于Time.unscaledTime的更新，当Time.timeScale &#x3D; 0，动画也会继续播放。</li>
<li>Manual:手动更新，调用PlayableGraph.Evaluate(deltaTime)方法来触发一次更新。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">graph.SetTimeUpdateMode(DirectorUpdateMode.Manual);</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    graph.Evaluate(Time.deltaTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>辅助工具：<br>AnimationPlayableUtilities 也可以看看源码，有挺多示例的。</p>
<h4 id="简单单节点动画示例"><a href="#简单单节点动画示例" class="headerlink" title="简单单节点动画示例"></a>简单单节点动画示例</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">animator = <span class="keyword">this</span>.GetComponent&lt;Animator&gt;();</span><br><span class="line">graph = PlayableGraph.Create(<span class="string">&quot;MyPlayableAnimGraph&quot;</span>);</span><br><span class="line"><span class="comment">//动画节点</span></span><br><span class="line"><span class="keyword">var</span> animNode = AnimationClipPlayable.Create(graph, AnimClips[<span class="number">0</span>]);</span><br><span class="line">animOutput = AnimationPlayableOutput.Create(graph,<span class="string">&quot;AnimOutput&quot;</span>,animator);</span><br><span class="line">animOutput.SetSourcePlayable(animNode);</span><br><span class="line"><span class="comment">//graph.Play();</span></span><br><span class="line">graph.DestroyPlayable(animNode); <span class="comment">//清除Playable节点</span></span><br><span class="line">graph.DestroyOutput(animOutput); <span class="comment">//清除Output节点</span></span><br><span class="line">graph.Destroy();<span class="comment">//清除所有Graph内的节点</span></span><br></pre></td></tr></table></figure>

<h4 id="混合示例"><a href="#混合示例" class="headerlink" title="混合示例"></a>混合示例</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">//混合示例</span></span><br><span class="line"><span class="comment">//第三个参数Normalize 废弃了。</span></span><br><span class="line">mixerPlayable = AnimationMixerPlayable.Create(graph, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> animNode1 = AnimationClipPlayable.Create(graph, WalkAndRuns[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">var</span> animNode2 = AnimationClipPlayable.Create(graph, WalkAndRuns[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//缓存一下节点后面使用。</span></span><br><span class="line">curAnimNodes.Add(animNode1);</span><br><span class="line">curAnimNodes.Add(animNode2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置混合</span></span><br><span class="line"><span class="built_in">float</span> defaultWeight1 = <span class="number">1</span> - mixRange;</span><br><span class="line"><span class="built_in">float</span> defaultWeight2 = mixRange;</span><br><span class="line"><span class="comment">//两种都可</span></span><br><span class="line"><span class="comment">// mixerPlayable.ConnectInput(0, animNode1, 0,defaultWeight1);</span></span><br><span class="line"><span class="comment">// mixerPlayable.ConnectInput(1, animNode2, 0,defaultWeight2);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//采用Graph连接并设置Weight。</span></span><br><span class="line">graph.Connect(animNode1, <span class="number">0</span>, mixerPlayable, <span class="number">0</span>);</span><br><span class="line">graph.Connect(animNode2, <span class="number">0</span>, mixerPlayable, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// mixerPlayable.SetInputWeight(0, defaultWeight1);</span></span><br><span class="line"><span class="comment">// mixerPlayable.SetInputWeight(1, defaultWeight2);</span></span><br><span class="line"></span><br><span class="line">animOutput.SetSourcePlayable(mixerPlayable);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//更新权重</span></span><br><span class="line">    mixerPlayable.SetInputWeight(<span class="number">0</span>, <span class="number">1</span> - mixRange);</span><br><span class="line">    mixerPlayable.SetInputWeight(<span class="number">1</span>, mixRange);</span><br><span class="line">    <span class="comment">//Fix Speed </span></span><br><span class="line">    <span class="comment">//由于Mixer的Length是由多个输入的weight和对应的Clip长度决定的 需要修正速度来确保表现正常</span></span><br><span class="line">    <span class="built_in">float</span> walkLength = WalkAndRuns[<span class="number">0</span>].length;</span><br><span class="line">    <span class="built_in">float</span> runLength = WalkAndRuns[<span class="number">1</span>].length;</span><br><span class="line">    <span class="built_in">float</span> mixLength = walkLength*(<span class="number">1</span>-mixRange) + runLength*mixRange;</span><br><span class="line">    <span class="built_in">float</span> fixWalkSpeed = walkLength / mixLength;</span><br><span class="line">    <span class="built_in">float</span> fixRunSpeed = runLength / mixLength;</span><br><span class="line">    curAnimNodes[<span class="number">0</span>].SetSpeed(fixWalkSpeed);</span><br><span class="line">    curAnimNodes[<span class="number">1</span>].SetSpeed(fixRunSpeed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Layer分层示例"><a href="#Layer分层示例" class="headerlink" title="Layer分层示例"></a>Layer分层示例</h4><p>使用AnimationLayerMixerPlayable，进行混合。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分层示例</span></span><br><span class="line">layerMixerNode = AnimationLayerMixerPlayable.Create(graph, <span class="number">2</span>); <span class="comment">//Mix两层</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bodyAnim = AnimationClipPlayable.Create(graph, WalkAndRuns[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">var</span> faceAnim = AnimationClipPlayable.Create(graph, FaceAnims[<span class="number">0</span>]);</span><br><span class="line">layerMixerNode.ConnectInput(<span class="number">0</span>, bodyAnim,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">layerMixerNode.ConnectInput(<span class="number">1</span>, faceAnim,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//设置对应层的avatarMask</span></span><br><span class="line">layerMixerNode.SetLayerMaskFromAvatarMask(<span class="number">1</span>,avatarMask);</span><br><span class="line"><span class="comment">//默认情况下都是Override。可以设置Addictive</span></span><br><span class="line"><span class="comment">//layerMixerNode.SetLayerAdditive(1,true);</span></span><br><span class="line"></span><br><span class="line">animOutput.SetSourcePlayable(layerMixerNode);</span><br></pre></td></tr></table></figure>

<h4 id="使用AnimatorController"><a href="#使用AnimatorController" class="headerlink" title="使用AnimatorController"></a>使用AnimatorController</h4><p>基于AnimatorControllerPlayable来创建节点然后应用即可。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Controller示例</span></span><br><span class="line">AnimatorControllerPlayable controllerPlayable = AnimatorControllerPlayable.Create(graph, controller);</span><br><span class="line">AnimationClipPlayable animNode = AnimationClipPlayable.Create(graph, AnimClips[<span class="number">0</span>]);</span><br><span class="line">mixerPlayable  = AnimationMixerPlayable.Create(graph, <span class="number">2</span>);</span><br><span class="line">mixerPlayable.ConnectInput(<span class="number">0</span>, controllerPlayable,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">mixerPlayable.ConnectInput(<span class="number">1</span>, animNode,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">animOutput.SetSourcePlayable(mixerPlayable);  </span><br></pre></td></tr></table></figure>

<h4 id="PlayableBehaviour"><a href="#PlayableBehaviour" class="headerlink" title="PlayableBehaviour"></a>PlayableBehaviour</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 用Behaviour来做一个Blend效果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyTestPlayableBehaviour</span>:<span class="title">PlayableBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> mixRange = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">private</span> PlayableGraph graph;</span><br><span class="line">    <span class="keyword">private</span> AnimationMixerPlayable mixer;</span><br><span class="line">    <span class="keyword">private</span> AnimationClipPlayable mixAnimNode1,mixAnimNode2;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InitParams</span>(<span class="params">AnimationClip mixClip1, AnimationClip mixClip2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mixAnimNode1.IsValid())</span><br><span class="line">        &#123;</span><br><span class="line">            graph.DestroyPlayable(mixAnimNode1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(mixAnimNode2.IsValid())</span><br><span class="line">            graph.DestroyPlayable(mixAnimNode2);</span><br><span class="line"></span><br><span class="line">        mixAnimNode1 = AnimationClipPlayable.Create(graph,mixClip1);</span><br><span class="line">        mixAnimNode2 = AnimationClipPlayable.Create(graph,mixClip2);</span><br><span class="line">        mixer.ConnectInput(<span class="number">0</span>, mixAnimNode1, <span class="number">0</span>, <span class="number">1</span> - mixRange);</span><br><span class="line">        mixer.ConnectInput(<span class="number">1</span>, mixAnimNode2, <span class="number">0</span>, mixRange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetMixRange</span>(<span class="params"><span class="built_in">float</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mixRange = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnPlayableCreate</span>(<span class="params">Playable playable</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnPlayableCreate(playable);</span><br><span class="line">        <span class="keyword">this</span>.graph = playable.GetGraph();</span><br><span class="line">        </span><br><span class="line">        mixer = AnimationMixerPlayable.Create(graph,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//把mixer的结果作为当前节点的输入</span></span><br><span class="line">        playable.ConnectInput(<span class="number">0</span>,mixer,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//每动画帧调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">PrepareFrame</span>(<span class="params">Playable playable, FrameData info</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.PrepareFrame(playable,info);</span><br><span class="line">        <span class="built_in">float</span> sourceWeight = <span class="number">1</span> - mixRange;</span><br><span class="line">        <span class="built_in">float</span> mixAnimWeight = mixRange;</span><br><span class="line">        mixer.SetInputWeight(<span class="number">0</span>, sourceWeight);</span><br><span class="line">        mixer.SetInputWeight(<span class="number">1</span>, mixAnimWeight);</span><br><span class="line">        <span class="comment">//CalSpeed</span></span><br><span class="line">        <span class="built_in">float</span> sourceLength = mixAnimNode1.GetAnimationClip().length;</span><br><span class="line">        <span class="built_in">float</span> mixAnimLength = mixAnimNode2.GetAnimationClip().length;</span><br><span class="line">        <span class="built_in">float</span> curLength = sourceWeight * sourceLength + mixAnimWeight * mixAnimLength;</span><br><span class="line">        mixAnimNode1.SetSpeed(sourceLength/curLength);</span><br><span class="line">        mixAnimNode2.SetSpeed(mixAnimLength/curLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="comment">//PlayableBehaviour 1 指定了inputCount</span></span><br><span class="line">myTestSP = ScriptPlayable&lt;MyTestPlayableBehaviour&gt;.Create(graph,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//初始化参数</span></span><br><span class="line">myTestSP.GetBehaviour().InitParams(WalkAndRuns[<span class="number">0</span>],WalkAndRuns[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">animOutput.SetSourcePlayable(myTestSP);</span><br><span class="line">......</span><br></pre></td></tr></table></figure>


<h1 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h1><p>Timeline后面单独有一个Unity Package（2021）。<br><a href="https://docs.unity3d.com/Packages/com.unity.timeline@1.8/manual/index.html">官方文档</a></p>
<blockquote>
<p>To create cinematic content, gameplay sequences, audio sequences, and complex particle effects.</p>
</blockquote>
<ul>
<li>Timeline asset </li>
<li>Timeline instance</li>
</ul>
<p>默认的Timeline中主要还是动画、SetActive等轨道。在应用时，有很多功能还是需要自己通过Playble来自定义。可以看到PacakgeSamples。或者是使用录制功能转换为AnimationClip然后操作。<br>默认的Track:</p>
<ul>
<li>Activation Track 控制对象的激活状态</li>
<li>Animation Track 动画轨道 用于播放Animation Clip等。也可以通过录制来创建对应的片段。</li>
<li>Audio Track 控制音频</li>
<li>Control Track 用于嵌套Timeline、粒子系统、ITimeControl脚本等。</li>
<li>Playable Track 用于Playables API创建的自定义脚本</li>
</ul>
<h2 id="Timeline-Customization-Samples"><a href="#Timeline-Customization-Samples" class="headerlink" title="Timeline Customization Samples"></a>Timeline Customization Samples</h2><ul>
<li>Time dilation track - 控制时间膨胀<ul>
<li>具体的实现代码还是看到示例的TimeDilation文件夹里</li>
<li>TimeDilationPlayableAsset,TimeDilationMixerBehaviour,TimeDilationTrack,TimeDilationBehaviour</li>
</ul>
</li>
<li>Video track - 播放视频</li>
<li>Text track - 控制文本显示</li>
<li>Tween track - 简单的Transform变换</li>
</ul>
<h3 id="从Time-dilation-track看自定义轨道和功能"><a href="#从Time-dilation-track看自定义轨道和功能" class="headerlink" title="从Time dilation track看自定义轨道和功能"></a>从Time dilation track看自定义轨道和功能</h3><ol>
<li>定义轨道类</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">TrackColor(0.855f, 0.8623f, 0.87f)</span>]</span><br><span class="line">[<span class="meta">TrackClipType(typeof(TimeDilationPlayableAsset))</span>] <span class="comment">//指定了PlayableAsset的类，也就是对应的轨道资产。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TimeDilationTrack</span> : <span class="title">TrackAsset</span> <span class="comment">//新轨道类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Creates a runtime instance of the track, represented by a PlayableBehaviour.</span></span><br><span class="line">    <span class="comment">// The runtime instance performs mixing on the timeline clips.</span></span><br><span class="line">    <span class="comment">// 这里注意本质上还是Playable的Mixer。作用是进行混合。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Playable <span class="title">CreateTrackMixer</span>(<span class="params">PlayableGraph graph, GameObject go, <span class="built_in">int</span> inputCount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ScriptPlayable&lt;TimeDilationMixerBehaviour&gt;.Create(graph, inputCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>定义轨道行为</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TimeDilationMixerBehaviour</span> : <span class="title">PlayableBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> m_DefaultTimeScale = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called every frame that the timeline is Evaluated.</span></span><br><span class="line">    <span class="comment">//编写混合逻辑。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">ProcessFrame</span>(<span class="params">Playable playable, FrameData info, <span class="built_in">object</span> playerData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> inputCount = playable.GetInputCount();</span><br><span class="line">        <span class="built_in">float</span> timeScale = <span class="number">0f</span>;</span><br><span class="line">        <span class="built_in">float</span> totalWeight = <span class="number">0f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// blend clips together</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; inputCount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">float</span> inputWeight = playable.GetInputWeight(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//类型转换。这里和定义轨道类的TrackClipType指定的类型相同。</span></span><br><span class="line">            ScriptPlayable&lt;TimeDilationBehaviour&gt; playableInput = (ScriptPlayable&lt;TimeDilationBehaviour&gt;)playable.GetInput(i);</span><br><span class="line">            TimeDilationBehaviour input = playableInput.GetBehaviour();</span><br><span class="line"></span><br><span class="line">            timeScale += inputWeight * input.timeScale;</span><br><span class="line">            totalWeight += inputWeight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// blend to/from the default timeline</span></span><br><span class="line">        Time.timeScale = Mathf.Max(<span class="number">0.0001f</span>, Mathf.Lerp(m_DefaultTimeScale, timeScale, Mathf.Clamp01(totalWeight)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called when the playable graph is created, typically when the timeline is played.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnPlayableCreate</span>(<span class="params">Playable playable</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_DefaultTimeScale = Time.timeScale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called when the playable is destroyed, typically when the timeline stops.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnPlayableDestroy</span>(<span class="params">Playable playable</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Time.timeScale = m_DefaultTimeScale;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>定义轨道资产</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A clip for the timeline dilation track.</span></span><br><span class="line"><span class="comment">//继承自PlayableAsset.</span></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TimeDilationPlayableAsset</span> : <span class="title">PlayableAsset</span>, <span class="title">ITimelineClipAsset</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Using a template for the playable behaviour will allow any serializable fields on the behaviour</span></span><br><span class="line">    <span class="comment">// to be animated.</span></span><br><span class="line">    [<span class="meta">NoFoldOut</span>]</span><br><span class="line">    <span class="keyword">public</span> TimeDilationBehaviour template = <span class="keyword">new</span> TimeDilationBehaviour();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Implementation of ITimelineClipAsset, that tells the timeline editor which</span></span><br><span class="line">    <span class="comment">// features this clip supports.</span></span><br><span class="line">    <span class="keyword">public</span> ClipCaps clipCaps</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> ClipCaps.Extrapolation | ClipCaps.Blending; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called to creates a runtime instance of the clip.</span></span><br><span class="line">    <span class="comment">//重点：返回一个对应的Playable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Playable <span class="title">CreatePlayable</span>(<span class="params">PlayableGraph graph, GameObject owner</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Note that template is passed as a parameter - this</span></span><br><span class="line">        <span class="comment">// creates a clone of the template PlayableBehaviour.</span></span><br><span class="line">        <span class="keyword">return</span> ScriptPlayable&lt;TimeDilationBehaviour&gt;.Create(graph, template);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>定义轨道资产实际的Playable类</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Runtime representation of a time dilation clip.</span></span><br><span class="line"><span class="comment">// The Serializable attribute is required to be animated by timeline, and used as a template.</span></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TimeDilationBehaviour</span> : <span class="title">PlayableBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Tooltip(<span class="string">&quot;Time.timeScale replacement value.&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> timeScale = <span class="number">1f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>附图</li>
</ol>
<img src="/Mine/Unity/Animation/timelineTDT0.png" class="">
<img src="/Mine/Unity/Animation/timelineTDT1.png" class="">


<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p><a href="https://docs.unity3d.com/6000.0/Documentation/Manual/MecanimPeformanceandOptimization.html">Performance and optimization</a></p>
<ul>
<li>Animator在Controller未设置的时候不会花时间处理（Playable算是例外？）</li>
<li>缩放曲线开销比平移和旋转更高。</li>
<li>Layers的weight在0的时候会跳过对应层的更新。</li>
<li>如果不需要用Avatar mask移除人形的IK目标或手指动画。</li>
<li>使用hashes而非strings来查询Animator</li>
<li>设置剔除模式</li>
</ul>
<p>其他的方案:</p>
<ul>
<li>SkinnedMeshRender转为MeshRender以支持GPU Instancing<ul>
<li>GPU Skinning<ul>
<li><a href="https://zhuanlan.zhihu.com/p/26181838820">Unity3D 实现骨骼动画的 GPU Skinning 详解</a></li>
</ul>
</li>
<li>知乎 <a href="https://zhuanlan.zhihu.com/p/28159739">利用GPU实现大规模动画角色的渲染</a></li>
<li>GitHub相关项目<ul>
<li><a href="https://github.com/ForeverZack/Unity-Gpu-Skinning-Tool">Unity-Gpu-Skinning-Tool</a></li>
<li><a href="https://github.com/chenjd/Render-Crowd-Of-Animated-Characters">Render-Crowd-Of-Animated-Characters</a></li>
<li><a href="https://github.com/Unity-Technologies/Animation-Instancing">Unity-Technologies&#x2F;Animation-Instancing</a></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity PostProcessing</title>
    <url>/Mine/Unity/PostProcessing/</url>
    <content><![CDATA[<p><a href="https://docs.unity3d.com/6000.0/Documentation/Manual/PostProcessingOverview.html">Introduction to post-processing</a><br>Unity 后处理</p>
<p>在渲染管线之后，FrameBuffer上处理。<br>后处理和全屏效果。</p>
<p>效果参考和支持<br><a href="https://docs.unity3d.com/6000.0/Documentation/Manual/post-processing-effect-availability-reference.html">Post-processing effect availability reference</a></p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity Physics</title>
    <url>/Mine/Unity/Physics/</url>
    <content><![CDATA[<p>物理</p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p><a href="https://zhuanlan.zhihu.com/p/1930355038871618549">Unity物理系统由浅入深第一节：Unity 物理系统基础与应用</a></p>
<p>RigidBody 刚体 - 赋予物理属性</p>
<p>Collider 碰撞体 - 碰撞形状</p>
<p>Physic Material 物理材质 - 定义交互特性<br>定义碰撞体之间的摩檫力和弹性。分配给Collider。</p>
<p>碰撞事件</p>
<ul>
<li>Collision Callbacks 适用于两个非触发器（至少一个带RigidBody）之间的物理碰撞</li>
<li>Trigger Callbacks 至少一个Collider为Is Trigger的情况下，检测到物体进入&#x2F;离开&#x2F;停留在区域内</li>
<li>只有当碰撞中一个Collider附加了Rigidbody或者其为KinematicRigidbody上的Colider时，才能触发对应的回调。(对于KinematicRigidbody，不会触发CollisionCallback，需要用TriggerCallback)</li>
</ul>
<p>射线检测 Raycast<br>形状检测 Shape Cast</p>
<h1 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h1><p>Unity的物理是在FixedUpdate中进行更新处理的。<br>不要直接用transform的方式移动物体，使用Rigidbody来处理移动</p>
<p><a href="https://docs.unity3d.org.cn/6000.0/Documentation/Manual/choose-collision-detection-mode.html">UnityDoc 选择碰撞检测模式</a><br>Continuous collision detection (CCD)<br><a href="https://docs.unity.cn/cn/2022.3/Manual/ContinuousCollisionDetection.html">连续碰撞检测 (CCD)</a></p>
<p>碰撞的检测模式，可以在刚体Rigid Body里面进行设置</p>
<ul>
<li>Discrete  离散<ul>
<li>不适用于快速碰撞</li>
</ul>
</li>
<li>Continuous Speculative 连续推测<ul>
<li>推断性CCD</li>
<li>适用于旋转情况</li>
<li>不适用于特别高精度级别的快速碰撞</li>
</ul>
</li>
<li>Continuous 连续<ul>
<li>CCD</li>
<li>不适用于旋转导致的碰撞，且仅与静态碰撞器发生碰撞</li>
</ul>
</li>
<li>Continuous Dynamic 连续动态<ul>
<li>CCD</li>
<li>不适用于旋转导致的碰撞</li>
</ul>
</li>
</ul>
<p>从上到下,开销会越来越高。</p>
<p>卡顿情况下的解决方案：<br>射线检测</p>
<h2 id="碰撞层级设置"><a href="#碰撞层级设置" class="headerlink" title="碰撞层级设置"></a>碰撞层级设置</h2><p>可以在Project Settings的Physics中进行碰撞层级的设置。</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>RAGFlow</title>
    <url>/AI/RAGFlow/</url>
    <content><![CDATA[<h1 id="使用RAGFlow处理大语言模型幻觉问题。"><a href="#使用RAGFlow处理大语言模型幻觉问题。" class="headerlink" title="使用RAGFlow处理大语言模型幻觉问题。"></a>使用RAGFlow处理大语言模型幻觉问题。</h1><p>大语言模型：基于Ollama部署。</p>
<p>重点优势：自动化的RAG工作流。</p>
<h2 id="Ollama模型部署和本地配置。"><a href="#Ollama模型部署和本地配置。" class="headerlink" title="Ollama模型部署和本地配置。"></a>Ollama模型部署和本地配置。</h2><p>略。简单且已完成。可以参考其他教程。</p>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>参考文档<br><a href="https://docs.docker.com/engine/install/">Install Docker Engine</a><br><a href="https://docs.docker.com/desktop/">Docker Desktop</a></p>
<p>注意了，使用不同底层性能是有差异的。可以看下面的介绍。还是用WSL2好点。</p>
<blockquote>
<p>碎碎念: 想要开发和涉及AI部分，还是少不了Linux。而不是在Windows平台去处理对应的逻辑。大部分AI训练的模型都是直接用Linux的,且很多依赖在Windows上都要单独去做处理，找对应的编译文件……<br>坑已踩。不过基于Docker去使用模型和直接在Windwos环境下使用模型又有多少性能损失，是一个值得考虑和研究的问题。</p>
</blockquote>
<h3 id="基于WSL的Docekr安装-Windwos部分"><a href="#基于WSL的Docekr安装-Windwos部分" class="headerlink" title="基于WSL的Docekr安装 - Windwos部分"></a>基于WSL的Docekr安装 - Windwos部分</h3><p>说明见WSL2 backend x86_64</p>
<p>Windows WSL(Windows Subsystem for Linux)<br>Windows文档说明 <a href="https://learn.microsoft.com/zh-cn/windows/wsl/install">URL</a></p>
<p>如果安装较慢 进度为0，可以先执行下面步骤1，重启电脑，执行步骤3，重启电脑。<br><a href="https://learn.microsoft.com/zh-cn/windows/wsl/install-manual#step-1---enable-the-windows-subsystem-for-linux">解决安装问题</a></p>
<p>注意Windows版本需求。<br>安装指令还是非常简单的。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wsl <span class="literal">--install</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note：<br>The above command only works if WSL is not installed at all. If you run wsl –install and see the WSL help text, please try running wsl –list –online to see a list of available distros and run wsl –install -d <DistroName> to install a distro. To uninstall WSL, see Uninstall legacy version of WSL or unregister or uninstall a Linux distribution.</p>
</blockquote>
<h3 id="基于WSL的Docekr安装-Docker部分"><a href="#基于WSL的Docekr安装-Docker部分" class="headerlink" title="基于WSL的Docekr安装 - Docker部分"></a>基于WSL的Docekr安装 - Docker部分</h3><p>Docker文档说明 <a href="https://docs.docker.com/desktop/features/wsl/">URL</a><br>安装Docker的博客教程 <a href="https://blog.csdn.net/Natsuago/article/details/145588600">文章</a></p>
<h2 id="RAGFlow"><a href="#RAGFlow" class="headerlink" title="RAGFlow"></a>RAGFlow</h2><p>官方 <a href="https://github.com/infiniflow/ragflow">GitHub</a></p>
<h3 id="GitHub项目运行Docker"><a href="#GitHub项目运行Docker" class="headerlink" title="GitHub项目运行Docker"></a>GitHub项目运行Docker</h3><p>CheckOut下对应的GitSource文件,依据需求,进入Docker文件夹中，设置.env的RAGFLOW_IMAGE。<br>下载有问题的话尝试设置镜像源:<br><a href="https://blog.csdn.net/Lichen0196/article/details/137355517">参考文章</a><br><a href="https://blog.csdn.net/Lyon_Nee/article/details/124169099">Windwos参考文章</a><br><a href="https://blog.csdn.net/qq_62878146/article/details/144191062">镜像问题</a><br>ragFlow部分也要设置镜像：位于.env中：<br>RAGFLOW_IMAGE&#x3D;swr.cn-north-4.myhuaweicloud.com&#x2F;infiniflow&#x2F;ragflow:v0.17.0</p>
<h3 id="配置Ollama"><a href="#配置Ollama" class="headerlink" title="配置Ollama"></a>配置Ollama</h3><p>系统环境变量配置 OLLAMA_ORIGINS 为 *<br>以及OLLAMA_HOST为 0.0.0.0。<br>这里需要注意的一点是，OLLAMA_HOST配置为0.0.0.0 如果是公网IP 有相应风险。<br>如果不使用0.0.0.0 需要另外解决docker访问的问题。可以另寻方案。</p>
<p>CMD 中ip config找到虚拟机对应的地址<br>默认端口号为11434<br>http:&#x2F;&#x2F;虚拟机地址:11434</p>
<h3 id="Embedding模型"><a href="#Embedding模型" class="headerlink" title="Embedding模型:"></a>Embedding模型:</h3><p>.env中有介绍模型的相关内容。v0.17.0非slim版本默认会有zh-cn的embedding模型。但对于英文模型需要额外下载。这部分应该要做额外处理逻辑。<br>目前来看,使用nomic-embed-text-v1.5的可以较好的处理中英文需求。<br>DockerDestop中设置 - 资源 - 网络部分启用主机网络。<br>对应Docker中命令行设置相关镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装huggingface_hub库</span><br><span class="line">pip install -U huggingface_hub</span><br><span class="line"># 设置国内镜像</span><br><span class="line"># 建议将这一行写入 ~/.bashrc。若没有写入，则每次下载时都需要先输入该命令</span><br><span class="line">export HF_ENDPOINT=https://hf-mirror.com  </span><br></pre></td></tr></table></figure>

<h2 id="Docker介绍-DeepSeek生成"><a href="#Docker介绍-DeepSeek生成" class="headerlink" title="Docker介绍[DeepSeek生成]"></a>Docker介绍[DeepSeek生成]</h2><p>Docker 是一个开源的<strong>容器化平台</strong>，用于快速构建、打包、部署和运行应用程序。它通过容器技术将应用及其依赖环境（如代码、库、配置等）打包成一个轻量级、可移植的单元，从而实现<strong>一次构建，随处运行</strong>的目标。<br>以下是 Docker Desktop 在 <strong>Hyper-V 模式</strong> 和 <strong>WSL2 模式</strong> 下的优缺点对比，结合不同场景的实际需求分析：</p>
<h3 id="一、Hyper-V-模式"><a href="#一、Hyper-V-模式" class="headerlink" title="一、Hyper-V 模式"></a><strong>一、Hyper-V 模式</strong></h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ol>
<li><p><strong>高隔离性</strong><br>• 基于完整的虚拟机（如 MobyLinuxVM）运行 Docker，与宿主机完全隔离，适合需要严格环境隔离的场景。<br>• 支持运行不同内核的操作系统（如旧版 Linux 发行版）。</p>
</li>
<li><p><strong>兼容性广</strong><br>• 适用于所有支持 Hyper-V 的 Windows 版本（如 Windows 10 专业版&#x2F;企业版）。</p>
</li>
<li><p><strong>独立资源分配</strong><br>• 可为虚拟机预先分配固定的 CPU 和内存资源，避免资源争用。</p>
</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ol>
<li><p><strong>性能损失较大</strong><br>• 虚拟化层导致 CPU 和内存性能损失约 15%<del>25%，I&#x2F;O 密集型任务（如编译、文件读写）延迟显著。<br>• 文件系统交互需通过虚拟化层中转，挂载 Windows 目录时 I&#x2F;O 速度下降 30%</del>50%。</p>
</li>
<li><p><strong>资源占用高</strong><br>• 需独立运行完整的 Linux 虚拟机，内存占用较高（默认分配 2GB 以上）。</p>
</li>
<li><p><strong>启动速度慢</strong><br>• 冷启动 Docker 服务需 30 秒至 1 分钟，容器启动时间较长。</p>
</li>
</ol>
<hr>
<h3 id="二、WSL2-模式"><a href="#二、WSL2-模式" class="headerlink" title="二、WSL2 模式"></a><strong>二、WSL2 模式</strong></h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a><strong>优点</strong></h4><ol>
<li><p><strong>接近原生性能</strong><br>• 基于轻量级虚拟机运行完整 Linux 内核，CPU 和内存性能损失仅 5%~15%，接近原生 Linux。<br>• 文件系统优化：若将代码存储在 WSL2 的 Linux 分区内，I&#x2F;O 性能与原生 Linux 一致。</p>
</li>
<li><p><strong>动态资源管理</strong><br>• 自动按需分配 CPU 和内存资源，避免资源浪费（如默认动态分配内存）。</p>
</li>
<li><p><strong>开发友好</strong><br>• 支持与 VS Code 无缝集成（通过 Remote-WSL 插件），可直接编辑 Linux 文件。<br>• 支持 GPU 加速（如 CUDA、DirectML），适合机器学习等高性能任务。</p>
</li>
<li><p><strong>快速启动</strong><br>• Docker 服务冷启动时间缩短至 10 秒以内，容器启动仅需 1~2 秒。</p>
</li>
</ol>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ol>
<li><p><strong>兼容性限制</strong><br>• 需 Windows 10 2004 或更高版本，且需启用 WSL2 功能。<br>• 不支持旧版 Linux 内核（依赖 Microsoft 提供的 Linux 内核版本）。</p>
</li>
<li><p><strong>文件系统交互问题</strong><br>• 直接挂载 Windows 目录（如 <code>/mnt/c</code>）时，文件读写性能较低（建议优先使用 WSL2 的 Linux 文件系统）。</p>
</li>
<li><p><strong>资源限制</strong><br>• 默认内存上限为 80% 宿主机内存，需手动调整 <code>.wslconfig</code> 文件以优化配置。</p>
</li>
</ol>
<hr>
<h3 id="三、场景推荐"><a href="#三、场景推荐" class="headerlink" title="三、场景推荐"></a><strong>三、场景推荐</strong></h3><table>
<thead>
<tr>
<th><strong>需求场景</strong></th>
<th><strong>推荐模式</strong></th>
<th><strong>理由</strong></th>
</tr>
</thead>
<tbody><tr>
<td>开发&#x2F;测试环境（高频启停容器）</td>
<td>WSL2</td>
<td>启动快、资源占用低，与 VS Code 集成流畅。</td>
</tr>
<tr>
<td>生产级隔离需求</td>
<td>Hyper-V</td>
<td>提供完整虚拟机隔离，避免宿主机干扰。</td>
</tr>
<tr>
<td>机器学习或 GPU 加速任务</td>
<td>WSL2</td>
<td>支持 GPU 直通和 CUDA 加速，性能接近原生。</td>
</tr>
<tr>
<td>跨平台兼容性测试</td>
<td>Hyper-V</td>
<td>可运行不同内核版本或非 Linux 系统（如 FreeBSD）。</td>
</tr>
<tr>
<td>文件密集型任务（如大数据处理）</td>
<td>WSL2</td>
<td>若数据存储在 Linux 分区内，I&#x2F;O 性能优于 Hyper-V。</td>
</tr>
</tbody></table>
<hr>
<h3 id="四、优化建议"><a href="#四、优化建议" class="headerlink" title="四、优化建议"></a><strong>四、优化建议</strong></h3><ol>
<li><p><strong>WSL2 配置优化</strong><br>• 修改 <code>.wslconfig</code> 文件，增加内存和 CPU 配额（如 <code>memory=8GB</code>）。<br>• 将代码和 Docker 数据卷存储在 WSL2 的 Linux 文件系统内（路径示例：<code>/home/user/project</code>）。</p>
</li>
<li><p><strong>Hyper-V 配置优化</strong><br>• 减少预分配内存（如从 4GB 降至 2GB），避免资源浪费。<br>• 使用 SSD 硬盘以缓解 I&#x2F;O 性能瓶颈。</p>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>• <strong>WSL2 是大多数开发场景的首选</strong>，尤其在性能、资源利用率和开发工具集成方面表现优异。<br>• <strong>Hyper-V 更适合需要严格隔离或运行特殊内核的场景</strong>，但需接受更高的性能损失。<br>• 根据具体需求灵活选择，亦可同时启用两种模式（需切换 Docker Desktop 后端）。</p>
]]></content>
      <categories>
        <category>RAG</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>RAG</tag>
        <tag>RAGFlow</tag>
        <tag>Ollama</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity SRP</title>
    <url>/Mine/Unity/SRP/</url>
    <content><![CDATA[<p><a href="https://docs.unity3d.com/6000.0/Documentation/Manual/rendering-paths-introduction.html">官方Doc Rendering paths in Unity</a><br><a href="https://zhuanlan.zhihu.com/p/353687806">Unity URP&#x2F;SRP 渲染管线浅入深出【匠】</a><br><a href="https://zhuanlan.zhihu.com/p/378828898">【Unity】SRP简单入门</a><br><a href="https://zhuanlan.zhihu.com/p/378781638">【Unity】SRP底层渲染流程及原理</a><br>Scriptable Render Pipeline<br>可编程渲染管线</p>
<h1 id="Render-Pipeline基础"><a href="#Render-Pipeline基础" class="headerlink" title="Render Pipeline基础"></a>Render Pipeline基础</h1><blockquote>
<p> A series of operations that take the contents of a scene, and displays them on a screen</p>
</blockquote>
<p>在Unity的官方文档中定义为这么几个步骤：</p>
<ul>
<li>Culling （Frustum Culling视锥体剔除 Occlusion Culling遮挡剔除）</li>
<li>Rendering -&gt;To Pixel Buffers</li>
<li>Post Processing -&gt;Modify Pixel Buffers</li>
</ul>
<p>常用的</p>
<ul>
<li>Built-in Render Pipeline：</li>
<li>Universal Render Pipeline (URP)</li>
<li>High Definition Render Pipeline (HDRP)</li>
</ul>
<p>URP、HDRP和自定义渲染管线都属于SRP。</p>
<h2 id="Rendering-Paths"><a href="#Rendering-Paths" class="headerlink" title="Rendering Paths"></a>Rendering Paths</h2><blockquote>
<p> The series of operations that draws and lights GameObjects the camera sees. </p>
</blockquote>
<p>主要分为两种类型</p>
<ul>
<li>Forward Rendering</li>
<li>Deferred Rendering</li>
</ul>
<p>默认使用的是Forward。</p>
<h3 id="Forward-Rendering"><a href="#Forward-Rendering" class="headerlink" title="Forward Rendering"></a>Forward Rendering</h3><p>工作原理：</p>
<ul>
<li>Unity lights each GameObject in turn.</li>
<li>Lighting has limits, for example how often or how well Unity can light each GameObject. These limits are different for each render pipeline.</li>
</ul>
<p>URP中还有一个Forward+ rendering path.其类似于Forward Rendering,但对于每个游戏对象的光源没有限制。</p>
<h3 id="Deferred-Rendering"><a href="#Deferred-Rendering" class="headerlink" title="Deferred Rendering"></a>Deferred Rendering</h3><p>工作原理：</p>
<ul>
<li>Unity first creates a <strong>geometry buffer (G-buffer)</strong>, which is a set of <strong>textures</strong> that stores data about the geometry and materials the camera sees.</li>
<li>Unity uses the data from the G-buffer to <strong>light all the GameObjects at once</strong>.</li>
<li>There are fewer limits on lighting, so GameObjects and shadows are more detailed. For example, normal maps and cookies work with all lights.</li>
</ul>
<p><strong>延迟渲染无法渲染透明对象</strong>。因此，在渲染路径的末尾，Unity使用Forward Render Pass 来渲染透明对象</p>
<h1 id="SRP"><a href="#SRP" class="headerlink" title="SRP"></a>SRP</h1><blockquote>
<p>A thin API layer that lets you schedule and configure rendering commands using C# scripts</p>
</blockquote>
<p>两大关键自定义元素：</p>
<ul>
<li>A Render Pipeline Instance<ul>
<li>定义渲染管线功能的类的实例。继承自RenderPipeline，重写Render方法。</li>
</ul>
</li>
<li>A Render Pipeline Asset<ul>
<li>存储Render Pipeline Instance的配置和其所用到的数据的资源。继承自RenderPipelineAsset,重写CreatePipeline方法。</li>
</ul>
</li>
</ul>
<p>ScriptableRenderContext：</p>
<blockquote>
<p>A class that acts as an interface between the custom C# code in the render pipeline and Unity’s low-level graphics code.</p>
</blockquote>
<p>使用其API来调度和执行渲染命令。</p>
<h2 id="光照处理"><a href="#光照处理" class="headerlink" title="光照处理"></a>光照处理</h2><p>内置渲染管线中，会用多个Pass来处理多个动态光。每多一个动态光就会多一个Pass。所以一般都是采用烘培Lightmap的方式。</p>
<p>URP中，全部动态光放在一个Pass中渲染。但限制在于需要限制灯光的数量。</p>
<h2 id="SRP-Batcher"><a href="#SRP-Batcher" class="headerlink" title="SRP Batcher"></a>SRP Batcher</h2><img src="/Mine/Unity/SRP/SRPBatcher.png" class="" title="SRPBatcher">

<p>本质上并不会减少DrawCall,但是可以减少SetPass.<br>相较于DrawCall,SetPass的开销会更高。一个参考指标是SetPassCall不要超过150</p>
<p>要求和说明：</p>
<ul>
<li>支持Mesh、Skinned Mesh Renderer</li>
<li>不支持Particle</li>
<li>不支持Material Property Block。</li>
</ul>
<p>SRP中，材质球在显存中占用固定的CBuffer(Constant Buffer)。其分为了Per Object Large Buffer用于存储对象属性和Material CBuffer用于存储材质信息。仅当材质信息改变时，才需要对Material CBuffer进行更新处理。</p>
<ul>
<li>中断SetPass的条件由Material Break 变为 Shader Variant Break。</li>
<li>减少了CBuffer的相关操作。</li>
</ul>
<h2 id="SRP-编写基础"><a href="#SRP-编写基础" class="headerlink" title="SRP 编写基础"></a>SRP 编写基础</h2><ul>
<li>创建SRP类，继承自RenderPipeline。<ul>
<li>重写Render方法。</li>
</ul>
</li>
<li>创建SRPAsset类，继承自RenderPipelineAsset。<ul>
<li>重写CreatePipeline方法。</li>
</ul>
</li>
</ul>
<h3 id="ScriptableRenderContext"><a href="#ScriptableRenderContext" class="headerlink" title="ScriptableRenderContext"></a>ScriptableRenderContext</h3><p>使用ScriptableRenderContext来处理相关的渲染。<br>可以结合CommondBuffer一起。</p>
<h2 id="SRP底层渲染流程及原理"><a href="#SRP底层渲染流程及原理" class="headerlink" title="SRP底层渲染流程及原理"></a>SRP底层渲染流程及原理</h2><img src="/Mine/Unity/SRP/image.png" class="" title="alt text">

<ul>
<li>Scriptable Culling<ul>
<li>ScriptableRenderContext.Cull</li>
</ul>
</li>
<li>Scriptable Draw<ul>
<li>CommondBuffer.Blit</li>
<li>CommondBuffer.DrawMesh</li>
<li>ScriptableRenderContext.DrawRenderers</li>
<li>ScriptableRenderContext.DrawShadows</li>
<li>…</li>
</ul>
</li>
<li>Scriptable Render Loop<ul>
<li>ScriptableRenderContext.Submit</li>
</ul>
</li>
</ul>
<h3 id="Scriptable-Culling"><a href="#Scriptable-Culling" class="headerlink" title="Scriptable Culling"></a>Scriptable Culling</h3><ul>
<li>Culling Process</li>
<li>RenderNode&#x2F;RenderNodeQueue</li>
</ul>
<h4 id="Shadow-Culling"><a href="#Shadow-Culling" class="headerlink" title="Shadow Culling"></a>Shadow Culling</h4><p>为产生阴影的灯光 创建对应的CullingJob。<br>例如：Shadows.CullShadowCastersDirectional<br>关于这块，几个影响因素：</p>
<ul>
<li>灯光数量 Light Count</li>
<li>哪些灯光会产生阴影 Light.shadows</li>
<li>哪些物体会有阴影（Cast Shadow）(Renderer.shadowCastingMode)</li>
</ul>
<h4 id="Dynamic-Objects-Culling"><a href="#Dynamic-Objects-Culling" class="headerlink" title="Dynamic Objects Culling"></a>Dynamic Objects Culling</h4><p>裁剪场景中的动态物体</p>
<ul>
<li>CullSceneDynamicObjects</li>
<li>IndexList (Unity维护场景中所有Renderer列表，而IndexList存着当前所有可见的Renderer的数组下标。但IndexList本身和Renderer列表登长 )</li>
</ul>
<img src="/Mine/Unity/SRP/image-1.png" class="" title="alt text">

<p>优势：</p>
<ul>
<li>每个CullJob可以分线程执行</li>
</ul>
<p>在CullJob完成后，会有Combine操作使其连续</p>
<h4 id="Extrat-RenderNode-Queue"><a href="#Extrat-RenderNode-Queue" class="headerlink" title="Extrat RenderNode Queue"></a>Extrat RenderNode Queue</h4><p>从内存角度，Renderer在内存中分布是杂乱的。因此在进行顺序读取时效率并不会很高。</p>
<p>为了连续，引入RenderNode。<br>RenderNode：Renderer对象的扁平化(Flatten)版本，将Renderer内数据展开变为一个大的Struct。</p>
<p>多个Node构成Queue。</p>
<ul>
<li>线程安全</li>
<li>Used by the rendering jobs to render the scene</li>
</ul>
<p>ExtraRenderNodeQueue：<br>遍历可见Renderer对象，并将数据拷贝到RenderNode的过程，然后组成RenderNodeQueue。</p>
<p>开销和场景内可见Renderer数量正相关</p>
<h3 id="Scriptable-Draw"><a href="#Scriptable-Draw" class="headerlink" title="Scriptable Draw"></a>Scriptable Draw</h3><ul>
<li>ScriptableRenderContext.ExecuteCommandBuffer</li>
<li>ScriptableRenderContext.DrawRenderers</li>
</ul>
<h4 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h4><p>引擎内部有4个Command存储</p>
<ul>
<li>dynamic_array&lt;ShadowDrawingSettings&gt; m_DrawShadowsCommands;</li>
<li>dynamic_array&lt;DrawRenderersCommand&gt; m_DrawRenderersCommands;</li>
<li>dynamic_array&lt;RenderingCommandBuffer*&gt; m_CommandBuffers;</li>
<li>dynamic_array&lt;Command&gt; m_Commands;</li>
</ul>
<p>以 DrawRenderersCommand为例子：<br>在调用产生DrawRenderersCommand的同时，也会产生一个Command放到m_Commands中</p>
<img src="/Mine/Unity/SRP/image-2.png" class="" title="alt text">

<p>实际上在调用context.DrawRenderers、context.DrawShadows、context.ExecuteCommandBuffer时，都不是立即执行的，而是生成对应的Command，存到队列中。在Submit才会执行。</p>
<h3 id="Submit"><a href="#Submit" class="headerlink" title="Submit"></a>Submit</h3><ul>
<li>PrepareDrawRenderersCommand</li>
<li>Execute commands</li>
</ul>
<h4 id="PrepareDrawRenderersCommand"><a href="#PrepareDrawRenderersCommand" class="headerlink" title="PrepareDrawRenderersCommand"></a>PrepareDrawRenderersCommand</h4><img src="/Mine/Unity/SRP/image-3.png" class="" title="alt text">

<p>问题：</p>
<ul>
<li>One renderer has more than one material</li>
<li>One material has more than one pass</li>
<li>Sort （决定哪些先画的问题）</li>
</ul>
<p>遍历每个renderNode,找到每个material。<br>遍历每个material，找到所有pass。每个pass生成一个ScriptableLoopObjectData。<br>然后对ScriptableLoopObjectData进行排序。确定渲染数据。</p>
<h4 id="ScriptableRenderLoop"><a href="#ScriptableRenderLoop" class="headerlink" title="ScriptableRenderLoop"></a>ScriptableRenderLoop</h4><img src="/Mine/Unity/SRP/image-4.png" class="" title="alt text">
<p>遍历Commands，依据类型获取数据，执行对应的逻辑。</p>
<p>ScriptableLoopObjectData中包含标识标识是否为SRP兼容，图中橙色为兼容，紫色为不兼容。</p>
<img src="/Mine/Unity/SRP/image-5.png" class="" title="alt text">
<p>依据兼容与否，走SRP batcher或普通的Draw。</p>
<h3 id="SRP-Batcher-1"><a href="#SRP-Batcher-1" class="headerlink" title="SRP Batcher"></a>SRP Batcher</h3><img src="/Mine/Unity/SRP/SRPBatcher.png" class="" title="SRPBatcher">
<p>对应流程:</p>
<img src="/Mine/Unity/SRP/image-6.png" class="" title="alt text">

<img src="/Mine/Unity/SRP/image-7.png" class="" title="alt text">
<p>因此可在Profile中看到多次ApplyShader和SRPBatcher.Flush。</p>
<p>传统的优化方案依旧适用于SRPBatcher，重点是让能Batch在一起的，尽可能在Sort的时候排在一起。</p>
<p>打断合批的原因</p>
<ul>
<li>kSRPBatchBreakDifferentShader</li>
<li>kSRPBatchBreakCauseMultiPassShader</li>
<li>kSRPBatchBreakKeywordsChange</li>
<li>kSRPBatchEndOfBatchFlush</li>
<li>kSRPBatchNotCompatibleNode</li>
<li>kSRPBatchMaterialNeedDeviceStateChange</li>
<li>kSRPBatchFirstCall</li>
<li>kSRPBatchMaterialBufferOverride</li>
</ul>
<p>使用FrameDebugger来查看并优化。</p>
<h4 id="buffer填充数据"><a href="#buffer填充数据" class="headerlink" title="buffer填充数据"></a>buffer填充数据</h4><p>PerObjectBuffer</p>
<img src="/Mine/Unity/SRP/image-8.png" class="" title="alt text">

<p>Shader有对应的Feature才会填充。<br>填充数据少则一次合批的数量可以更多。</p>
<p>在填充完PerObjectData后，组成一个大的CBuffer统一传到GPU</p>
<h1 id="Shader-And-Material"><a href="#Shader-And-Material" class="headerlink" title="Shader And Material"></a>Shader And Material</h1><p><a href="https://docs.unity3d.com/6000.2/Documentation/Manual/materials-and-shaders.html">UnityDoc Materials and shaders</a></p>
<blockquote>
<p>碎碎念：Unity竟然把Material的介绍放到Shader前面……</p>
</blockquote>
<h2 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h2><blockquote>
<p>A program that runs on a GPU</p>
</blockquote>
<p>Unity中将着色器分为三类：</p>
<ul>
<li>Part of the Graphics pipeline。用于计算像素的颜色。一般使用Shader objects。</li>
<li>Compute shaders在GPU的常规图形管线外执行计算。</li>
<li>Ray tracing处理光线追踪</li>
</ul>
<h3 id="SubShader-and-Pass"><a href="#SubShader-and-Pass" class="headerlink" title="SubShader and Pass"></a>SubShader and Pass</h3><h4 id="SubShader"><a href="#SubShader" class="headerlink" title="SubShader"></a>SubShader</h4><p>SubShader - 依据硬件条件确定执行的SubShader。只会有一个SubShader执行。Unity会按顺序尝试每一个SubShader，使用第一个能够在当前平台运行的。</p>
<p>可以为高低端GPU提供不同的实现。<br>可以为不同的渲染管线(前向&#x2F;延迟)提供不同的实现</p>
<h4 id="Pass"><a href="#Pass" class="headerlink" title="Pass"></a>Pass</h4><p>Pass - 每一个Pass都是一个渲染流程，用于实现不同的渲染效果。多Pass意味着多次从顶点处理、光栅化到像素处理的全过程。<br>多个Pass的混合通过帧缓冲区来处理。具体的机制取决于渲染状态的设置。如覆盖、透明度混合、加法混合。</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 没有设置混合模式，默认是：Blend One Zero</span></span><br><span class="line">    <span class="comment">// 意味着：当前颜色 × 1 + 缓冲区颜色 × 0 = 完全覆盖</span></span><br><span class="line">&#125;</span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    Blend SrcAlpha OneMinusSrcAlpha <span class="comment">// 传统透明度混合</span></span><br><span class="line">    <span class="comment">// 当前颜色 × SrcAlpha + 缓冲区颜色 × (1 - SrcAlpha)</span></span><br><span class="line">&#125;</span><br><span class="line">Pass</span><br><span class="line">&#123;</span><br><span class="line">    Blend One One <span class="comment">// 加法混合</span></span><br><span class="line">    <span class="comment">// 当前颜色 × 1 + 缓冲区颜色 × 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Shader-Variant"><a href="#Shader-Variant" class="headerlink" title="Shader Variant"></a>Shader Variant</h3><p><a href="https://docs.unity3d.com/6000.2/Documentation/Manual/shader-variants.html">UnityDoc Reducing shader variants</a><br><a href="https://developer.unity.cn/projects/67160447edbc2a9ccb33996c">Unity Shader 变体指南</a></p>
<blockquote>
<p>Shader variants(shader permutations) —— one way of introducing conditional behavior into shader code</p>
</blockquote>
<p>主要还是用于Shader代码中的条件处理。<br>Unity在对Shader源文件编译成Shader程序时，依据关键字，将生成一至多个Shader变体(依赖于不同的条件。每个都是独立的文件)。本质上是一种静态分支形式。</p>
<p>关键字:</p>
<ul>
<li>#pragma multi_compile<ul>
<li>会为所有关键字组合生成对应的着色器变体。</li>
<li>可能会有很长的编译时间。因为组合数量可能很恐怖</li>
<li>使用shader_feature或剥离着色器变体来优化。</li>
</ul>
</li>
<li>#pragma shader_feature<ul>
<li>仅需要着色器依据材质属性时。Unity会依据Build中的材质去生成对应的变体，不会生成多余的变体。</li>
<li>可以缩短构建时间并减少文件大小。</li>
<li>不太适合用于C#脚本。在运行时如果使用不在Build内的变体，Unity会尝试用与其最相似的一个来处理逻辑。</li>
</ul>
</li>
</ul>
<p>附：</p>
<ul>
<li>动态分支，关键字为#pragma dynamic_branch 则不会生成多个变体文件，但是会影响GPU的性能。</li>
</ul>
<p>优缺点：</p>
<ul>
<li>缺点<ul>
<li>大量着色器导致更长的构建时间</li>
<li>内存占用问题和着色器编译卡顿</li>
</ul>
</li>
<li>优点<ul>
<li>在不影响GPU性能的情况下，实现条件分支</li>
</ul>
</li>
</ul>
<h4 id="变体加载流程"><a href="#变体加载流程" class="headerlink" title="变体加载流程"></a>变体加载流程</h4><p>关于预编译相关的逻辑：<br><a href="https://www.jianshu.com/p/300ba79057c5">【Unity Shader】加载时机和预编译</a></p>
<p>这里其实是有两种情况的：</p>
<ol>
<li>着色器变种已经打包到APP中，只需要加载该变体，创建GPUProgram</li>
<li>着色器变种没用被打包，这时需要shaderlab文件进行解析和编译相应的变种，然后创建GPUProgram</li>
</ol>
<p>通过材质确定需要加载的着色器变体。从项目资源中加载所需的着色器。</p>
<p>如果该变体已经存在于内存中，Unity会直接使用它。</p>
<p>否则:</p>
<ul>
<li>若着色器已经在资源中（例如，在AB中或Resources文件夹中），Unity会从这些资源中加载着色器。如果之前已经编译了该着色器变体（例如，通过Shader Variant Collection），Unity会直接使用预编译的代码。预编译可以大大减少运行时编译的开销。（对应情况1） </li>
<li>否则进行动态编译（对应情况2）。<ol>
<li>解析着色器代码：读取HLSL代码和着色器的配置。</li>
<li>应用关键字和设置：根据材质的设置和启用的关键字，应用相应的变体配置。</li>
<li>生成GPU代码：将处理后的HLSL代码转换为GPU能够理解和执行的代码。</li>
</ol>
</li>
</ul>
<p>这里也要留意，加载变体本身也是有对应开销的。也有预加载对应的逻辑。</p>
<h4 id="Strip-Shader-Variants"><a href="#Strip-Shader-Variants" class="headerlink" title="Strip Shader Variants"></a>Strip Shader Variants</h4><p><a href="https://docs.unity3d.com/6000.2/Documentation/Manual/shader-variant-stripping.html">UnityDoc Strip shader variants</a></p>
<p>基础的思想还是尽可能的使用shader_feature而不是multi_compile。</p>
<p>或者使用关键字来限制对应的应用阶段。</p>
<p>使用SVC(Shader Variant Collection)来优化变体。</p>
<h2 id="Material"><a href="#Material" class="headerlink" title="Material"></a>Material</h2><blockquote>
<p>To describe the appearance of surfaces</p>
</blockquote>
<p>Shader和对应的材质属性属性</p>
<h3 id="Material-Variant"><a href="#Material-Variant" class="headerlink" title="Material Variant"></a>Material Variant</h3><p>似于复制材质。</p>
<ul>
<li>父材质改变时，自动改变</li>
<li>支持一些操作（如子材质改变同步到父材质、父材质设置部分属性锁定,使得子材质无法修改）</li>
<li>支持重新设置父材质</li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>UE蓝图笔记</title>
    <url>/UE/Engine/UEBlueprintNote/</url>
    <content><![CDATA[<h1 id="蓝图断点与流程显示"><a href="#蓝图断点与流程显示" class="headerlink" title="蓝图断点与流程显示"></a>蓝图断点与流程显示</h1><p>断点的话，右键对应的节点添加断点即可。</p>
<p>运行时打开对应的蓝图，并在编辑器中选中对应的对象，可以观看其运行流程。</p>
<img src="/UE/Engine/UEBlueprintNote/image.png" class="" title="alt text">
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>Blueprint</tag>
      </tags>
  </entry>
  <entry>
    <title>UE-Module</title>
    <url>/UE/Engine/UEModule/</url>
    <content><![CDATA[<h1 id="虚幻引擎模块-Module-Doc"><a href="#虚幻引擎模块-Module-Doc" class="headerlink" title="虚幻引擎模块[Module] - Doc"></a>虚幻引擎模块[Module] - Doc</h1><p><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/unreal-engine-modules">官方参考文章地址</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>模块（Modules）是 虚幻引擎（UE）的软件架构的基本构建块。它们在独立的代码单元中封装了具体的编辑器工具、运行时功能、库或其他功能。</p>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>使用模块整理项目可带来以下好处：</p>
<ul>
<li><p>模块会强制实施良好的代码分离，可用于封装功能并隐藏代码的内部成分。</p>
</li>
<li><p>模块编译为单独的编译单元。这意味着，只有已更改的模块才需要编译，较大项目的编译时间会显著缩短。</p>
</li>
<li><p>模块在依赖性图表中链接在一起，并且仅允许实际使用的代码包含头文件，以符合Include What You Use (IWYU)标准。这意味着，你的项目中未使用的模块将安全地排除在编译之外。</p>
</li>
<li><p>你可以控制在运行时何时加载和卸载具体的模块。这样一来，可以管理哪些系统可用并激活，从而优化项目的性能。</p>
</li>
<li><p>你可以基于特定条件（例如，项目是为哪个平台编译的），在你的项目中纳入或排除模块。</p>
</li>
</ul>
<p>总结起来，如果你遵守模块的最佳实践，相较于将项目代码全部放在一个模块中而言，你的项目代码会更加井然有序，能更高效地编译，并且可复用程度更高。</p>
<h1 id="模块实现和接入"><a href="#模块实现和接入" class="headerlink" title="模块实现和接入"></a>模块实现和接入</h1><img src="/UE/Engine/UEModule/img1.png" class="" title="alt text">
<img src="/UE/Engine/UEModule/img2.png" class="" title="alt text">
<p>这部分的逻辑处理可以参考引擎中的GAS插件。</p>
<img src="/UE/Engine/UEModule/img4.png" class="" title="alt text">
<img src="/UE/Engine/UEModule/img5.png" class="" title="alt text">
<p>这里还挺有意思的，以GAS的为例子，对应的FGameplayAbilitiesMoudle类是放在对应的.cpp文件进行声明和实现的。本质上这个类仅内部使用（类声明下面就是IMPLEMENT_MODULE的宏）。起到内部封装，减少耦合和依赖，可以优化编译速度。</p>
<img src="/UE/Engine/UEModule/img6.png" class="" title="alt text">
<p>由此 我们对于项目的Build.cs有了进一步了解。自己的Gameplay其实本来也算是一个模块。具体的声明可以去看看ModuleManager.h中对应的宏</p>
<img src="/UE/Engine/UEModule/img7.png" class="" title="alt text">
<p>可以在对应的文件里面去配置模块的加载方式。[Module types, Loading phases, Other params]</p>
<p>关于DLL部分的内容 可以再补充一下。</p>
<h2 id="Gameplay-Module"><a href="#Gameplay-Module" class="headerlink" title="Gameplay Module"></a>Gameplay Module</h2><p>明确一点，游戏本身是一个主模块。<br>很简单的尝试创一个新的项目，在Source&#x2F;项目名称.cpp内就可以看到对应的IMPLEMENT_PRIMARY_GAME_MODULE声明。<br>新创建的模块和主模块处于同一目录层级。</p>
<img src="/UE/Engine/UEModule/img8.png" class="" title="alt text">
<p>新模块不一定要有.h文件。GAS模块本身对Interface做了拓展，有一个.h文件来处理。<br>比如NavMeshModule就只有对应的cpp文件。<br>其他部分和原来的模块是差不太多的。</p>
<h3 id="模块INI-文件配置"><a href="#模块INI-文件配置" class="headerlink" title="模块INI 文件配置"></a>模块INI 文件配置</h3><img src="/UE/Engine/UEModule/img9.png" class="" title="alt text">
<h3 id="应用策略"><a href="#应用策略" class="headerlink" title="应用策略"></a>应用策略</h3><p>实际项目应用时应当考虑是否真的有必要为游戏性代码做模块区分。<br>而且Gameplay模块间的依赖和耦合性也是问题。</p>
<img src="/UE/Engine/UEModule/img10.png" class="" title="alt text">

<h1 id="模块的私有和共有依赖性"><a href="#模块的私有和共有依赖性" class="headerlink" title="模块的私有和共有依赖性"></a>模块的私有和共有依赖性</h1><p>关于模块链接,这里还有一篇文章可以再细看看。可以进一步了解其逻辑原理。<br><a href="https://zhuanlan.zhihu.com/p/107270501">UE4 模块,PrivateDependencyModuleNames?</a></p>
<h2 id="DLL的链接"><a href="#DLL的链接" class="headerlink" title="DLL的链接"></a>DLL的链接</h2><p>了解模块的链接，还是回到DLL的链接。</p>
<p>整一个预处理-编译-汇编-链接的过程</p>
<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><ul>
<li>头文件展开和宏定义替换 - 每个cpp单独展开。#pragma once仅确保当前编译单元内不会重复展开</li>
<li>处理所有预编译指令 #xxxxx</li>
</ul>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>由 高级语言 -&gt; 生成汇编代码文件 (.s)</p>
<h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>由 汇编 - &gt; 二进制 生成 二进制目标文件(.o)文件<br>为每一个源文件生成一个目标文件。</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>合并符号表 符号解析和符号地址重定位<br>将多个目标文以及所需的库文件(.so等)链接成最终的可执行文件(executable file)</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://zhuanlan.zhihu.com/p/88255667">C&#x2F;C++编译链接</a></p>
<p><a href="https://www.cnblogs.com/Terry-Liu/p/17408432.html">编译的四个过程-预处理、编译、汇编、链接</a></p>
<p><a href="https://learn.microsoft.com/zh-cn/cpp/preprocessor/preprocessor-directives?view=msvc-170">预处理器指令</a></p>
<h2 id="UEModule的依赖"><a href="#UEModule的依赖" class="headerlink" title="UEModule的依赖"></a>UEModule的依赖</h2><p>回到官方文档以及参考文章<br><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/unreal-engine-modules">官方doc</a><br>模块的依赖性问题 Build.cs<br>模块的改动需要更新项目文件。<br>模块的公开部分 - Public - 公共头文件</p>
<h3 id="私有和公共依赖性"><a href="#私有和公共依赖性" class="headerlink" title="私有和公共依赖性"></a>私有和公共依赖性</h3><p>共有和私有 - 对于当前模块A 若A依赖于模块B。<br>A -&gt; B.如果仅在私有方式使用 -&gt; 在Priavte文件当中。<br>那么可以放入PrivateDependencyModulesName<br>但如果有公开使用（如Public的.h中使用） 那么需要放入PublicDependencyModuleNames。</p>
<p>当C引用A的时候  C - &gt; A -&gt; B，在C包含A的头文件时，不会存在问题。</p>
<p>“你可以在头文件中使用前向声明，将许多依赖性设置为私有而不是公共。”<br>-&gt; public 的.h中先进行前向声明。</p>
<p>模块中的Private和Public文件夹  - &gt; 控制模块代码对于其他模块的可用性</p>
<p>IncludePathModuleNames,DependencyModuleNames的区别?<br>定义在头文件中（以及部分独立的内联函数）可以正常用。<br>而依赖于cpp实现 需要链接的就不行。</p>
<ul>
<li>IncludePath - 添加头文件</li>
<li>Dependency - 添加头文件 链接lib .so .a等类型 处理模块间的编译顺序依赖</li>
</ul>
<h1 id="模块API宏"><a href="#模块API宏" class="headerlink" title="模块API宏"></a>模块API宏</h1><p>主要参考以下文章进行总结<br><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/module-api-specifiers-in-unreal-engine">官方文章</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/671652937">知乎文章 - 虚幻引擎类和函数等前的 XXX_API 的作用和原理研究</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/698099444">知乎文章 - UEC++编译链接LinkError问题解决汇总</a></p>
<h2 id="简述和注意点"><a href="#简述和注意点" class="headerlink" title="简述和注意点:"></a>简述和注意点:</h2><h3 id="基础定义"><a href="#基础定义" class="headerlink" title="基础定义"></a>基础定义</h3><p>模块等前定义的 XXX_API 的一个主要作用为为对应的模块等启用 dllexport 等扩展特性语法。（XXX模块对应的模块宏就为XXX_API）</p>
<p>这个表示把整个类全部公开给其它的模组提供调用，如果不加上这个API宏、那也会出现Link Error。因为没暴露地址的模组就算在Build.cs加上了模组名，也依然是无法在C++的编译链接阶段查找地址失败从而导致编译错误。</p>
<p>如果是工具类本身就想整个对外提供调用，那放在class后面加上模组API宏也是没问题。但是对于大部分我们自己写的游戏逻辑，把整个class宏公布出去会导致整个类都被编译器捕获，当该模组被其他模组所引用的时候，这整个类都会被重新编译，导致了编译时间变长。这本质上对运行时间是没影响，但项目大起来，难免会多出很多无谓的编译时间。所以这个时候我们可以考虑不在class后面加上宏API，而仅仅只在想被外部模组调用的类方法加上宏，也是可以实现链接成功。</p>
<h3 id="蓝图调用特殊逻辑"><a href="#蓝图调用特殊逻辑" class="headerlink" title="蓝图调用特殊逻辑"></a>蓝图调用特殊逻辑</h3><p>因为有了宏API的设定，就有了一些只有蓝图可以做，但C++不可以做的事情。比如说原生的UE5插件AnimToTexture，里面的Editor类，就只能够用蓝图调用，而不允许被其它模组的C++调用的。因为这些类并没有对外声明模组API宏，导致了里面的类只能被模组本身访问，但不能被其它C++访问。但由于又声名了BlueprintCallable，所以能被蓝图调用。所以这种情况下，只能说是开发者有意为之的事情。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>这里以GAS相关的逻辑代码作为示例：<br>首先看到有对应API声明的：</p>
<img src="/UE/Engine/UEModule/image.png" class="" title="alt text">
<img src="/UE/Engine/UEModule/image2.png" class="" title="alt text">
<p>因此，自定义子类去继承和处理对应的逻辑是没有问题的。<br>但如果要改写部分函数，比如处理GCN_Looping,直接用内部变量编译就会失败。如对下面的Struct进行引用：</p>
<img src="/UE/Engine/UEModule/image3.png" class="" title="alt text">
<p>该struct属于GAS模块，但是没有声明API，因此自定义类（不属于该模块的），用到时就会报错。</p>
<h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><p>如果要深入研究，还是要去看UHT的具体逻辑。</p>
<h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><p>dllexport 、dllimport<br>dllexport 和 dllimport 存储类特性是 C 和 C++ 语言的 Microsoft 专用扩展。 可以使用它们从 DLL 中导出或向其中导入函数、数据和对象。<br>使用 dllexport 意味着定义，而使用 dllimport 则意味着声明。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>dllexport 、dllimport 的作用为，让指定的类、属性或函数对外可见或对当前模块可见，需要与 __declspec 配合使用，皆为 C++ 语法特性。<br>在虚幻引擎中，为了提高代码的可读性、编码方便性以及兼容平台差异性，对其做了进一步封装，即为 DLLEXPORT 和 DLLIMPORT ，之后通过编译系统进一步封装到 XXX_API 等宏中，自动完成。</p>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>Module</tag>
      </tags>
  </entry>
  <entry>
    <title>UE Input输入</title>
    <url>/UE/Engine/UE_Input/</url>
    <content><![CDATA[<p><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/enhanced-input-in-unreal-engine#%E8%BE%93%E5%85%A5%E4%BF%AE%E9%A5%B0%E5%99%A8">官方文章Doc</a></p>
<h1 id="基础输入-Actor-Input"><a href="#基础输入-Actor-Input" class="headerlink" title="基础输入 [Actor Input]"></a>基础输入 [Actor Input]</h1><p>Acotr Input<br>响应玩家输入</p>
<p>启用ActorInput</p>
<ul>
<li>将PlayerController与对应的Actor绑定在一起 启用输入</li>
<li>配套的禁用输入 Disable Input</li>
</ul>
<p>使用事件来启用&#x2F;禁用输入</p>
<ul>
<li>CollisionComp的Overlap</li>
</ul>
<p>此外 输入是有优先级以及“消耗”这一说法的。 [见Consume Input]</p>
<h1 id="增强输入-Enhanced-Input"><a href="#增强输入-Enhanced-Input" class="headerlink" title="增强输入 [Enhanced Input]"></a>增强输入 [Enhanced Input]</h1><p>键输入的重新映射</p>
<p>概念：</p>
<ul>
<li>输入动作 Input Actions</li>
<li>输入映射上下文 Input Mapping Context</li>
<li>输入修饰器 Input Modifers</li>
<li>输入触发器 Input Tiggers</li>
</ul>
<h2 id="输入动作"><a href="#输入动作" class="headerlink" title="输入动作"></a>输入动作</h2><p>输入动作在概念上相当于 操作（Action） 和 轴（Axis） 映射名称，但它们是数据资产。</p>
<p>每个输入动作应该表示用户可以执行的某件事，例如”蹲伏”或”发射武器”。</p>
<p>你可以在蓝图或C++中添加 输入侦听器（Input Listeners） ，侦听输入动作的状态何时发生变化。</p>
<p>输入动作可以是多种不同的类型，这些类型将确定行为。</p>
<p>可以创建简单的布尔动作或更复杂的3D轴。动作类型将确定值。布尔动作采用简单的布尔值， Axis1D为浮点值， Axis2D为FVector2D， Axis3D 为整个Fvector。</p>
<p>布尔动作用于状态为开或关的输入。这相当于旧版输入系统中的较旧动作映射。<br>对于游戏手柄控制杆值等控制点，你可以使用2D轴动作来保存控制杆位置的X和Y值。<br>你可以使用3D轴保存更复杂的数据，例如运动控制器信息。</p>
<p>示例 IA_Move</p>
<h3 id="触发状态"><a href="#触发状态" class="headerlink" title="触发状态"></a>触发状态</h3><p>触发状态（Trigger State） 表示动作的当前状态。<br>通常，使用”已触发”状态。你可以绑定到C++和蓝图中的特定状态。</p>
<ul>
<li>已触发（Triggered）： 动作已触发。这意味着它完成了所有触发器要求的求值。例如，”按下并松开”触发器会在用户松开按键时发送。</li>
<li>已开始（Started）： 发生了开始触发器求值的某个事件。例如，”双击”触发器的第一次按键将调用一次”已开始”状态。</li>
<li>进行中（Ongoing）： 触发器仍在进行处理。例如，当用户按下按钮时，在达到指定持续时间之前，”按住”动作处于进行中状态。根据触发器，此事件将在收到输入值之后在对动作求值时，每次更新触发一次。</li>
<li>已完成（Completed）： 触发器求值过程已完成。</li>
<li>已取消（Canceled）： 触发已取消。例如，在”按住”动作还没触发之前，用户就松开了按钮。</li>
</ul>
<h3 id="输入侦听器"><a href="#输入侦听器" class="headerlink" title="输入侦听器"></a>输入侦听器</h3><p>如题所述，用于侦听对应的事件。</p>
<h2 id="输入映射上下文"><a href="#输入映射上下文" class="headerlink" title="输入映射上下文"></a>输入映射上下文</h2><p>主要还是起一个Mapping的作用</p>
<p>输入动作的集合，表示玩家可以处于的特定上下文。它们描述了给定输入动作的触发规则。映射上下文可以动态地为每个用户添加、移除或安排优先次序。<br>Input Action 以及 用户出发InputAction的方式。如键、按钮、动作轴等。</p>
<p>键下有对应的Triggers和Modifers。为各个用户输入的输入触发器和输入修饰器列表，可用于确定如何筛选或处理输入的原始值，以及它必须满足哪些限制才能驱动顶层的输入动作。</p>
<p>通过本地玩家的增强输入本地玩家子系统（Enhanced Input Local Player Subsystem）将一个或多个上下文应用到本地玩家，并安排它们的优先次序，避免多个操作由于尝试使用同一输入而发生冲突。</p>
<p>将实际的键与输入动作[InputAction]绑定，并为每个动作指定额外触发器或修饰器。将输入映射上下文添加到增强输入子系统时，你还可以指定其优先级。如果你有多个上下文映射到同一个输入动作，那么在触发输入动作时，将考虑优先级最高的上下文，而忽略其他上下文。</p>
<p>例如，你可以为一个可以游泳、行走、驾驶载具的角色提供多个输入映射上下文。一个用于通用动作（始终可用且始终映射到相同用户输入），其他分别用于各类移动模式。</p>
<p>开发人员随后可以将与载具相关的输入动作放入单独的输入映射上下文中，这些操作将在本地玩家进入载具时添加到玩家，并在退出载具时从本地玩家中移除。[使用多个输入映射上下文]</p>
<p>这样做有助于确保不合适的输入动作无法运行，从而优化并预防漏洞。此外，使用互斥的输入映射上下文还有助于避免输入冲突，因此当某个用户输入被用于不同的输入动作时，该输入绝不会意外触发错误的操作。</p>
<h2 id="输入修饰器"><a href="#输入修饰器" class="headerlink" title="输入修饰器"></a>输入修饰器</h2><p>InputModifiers<br>预处理器。</p>
<p>增强输入插件随附多种输入修饰器，可以执行各种任务，例如更改轴顺序、实现”死区”、将轴输入转换为世界空间。</p>
<p>很适合用于应用灵敏度设置，在多个帧上平滑输入，或基于玩家状态更改输入的行为。</p>
<p>比如可以实现反向操作的效果。<br>详细见Modify Raw函数。</p>
<h3 id="方向输入"><a href="#方向输入" class="headerlink" title="方向输入"></a>方向输入</h3><p>手柄 - 摇杆<br>键盘 - 由一维(键盘WASD输入)转为二维：</p>
<ul>
<li>默认情况下 单键为一维度 可以认为是X轴，值为0或1.0</li>
<li>使用Swizzle Input Axis Values 将其改为Y轴（适用于W与D键）</li>
<li>使用Negate负值来实现反方向</li>
</ul>
<p>不过这里有一点还是值得思考的：键盘单键输入就是0&#x2F;1.0 和摇杆还不太一样。</p>
<p>按鸣潮的做法，键鼠时，用ctrl来控制慢走&#x2F;快走，而摇杆就可以“轻推”。</p>
<h2 id="输入触发器"><a href="#输入触发器" class="headerlink" title="输入触发器"></a>输入触发器</h2><p>用于确定用户输入在经过一系列可选输入修饰器的处理后，是否会激活输入映射上下文中的相应输入动作。</p>
<p>大部分输入触发器都会分析输入本身，检查最小动作值并验证各种模式。</p>
<p>例如短暂点击、长时间按住或典型的”按下”或”释放”事件。</p>
<p>此规则的一个例外是”同时按键”输入触发器，该触发器仅通过另一个输入动作触发。</p>
<p>默认情况下，任意用户输入活动都会在每次更新时触发一次。</p>
<p>输入触发器有三种类型：</p>
<ul>
<li>显式（Explicit） 类型:将使输入在输入触发器成功时成功。</li>
<li>隐式（Implicit） 类型:将使输入仅在输入触发器和所有其他隐式类型输入触发器都成功时成功。</li>
<li>阻碍（Blocker） 类型：将使输入在输入触发器成功时失败。</li>
</ul>
<p>处理用户输入后，输入触发器可能返回以下三种状态之一：</p>
<ul>
<li>无（None） :表明未满足输入触发器的条件，因此输入触发器失败。</li>
<li>持续（Ongoing） :表明部分满足了输入触发器的条件，并且输入触发器正在处理，但尚未成功。</li>
<li>已触发（Triggered） :表明已满足输入触发器的所有条件，因此输入触发器成功。</li>
</ul>
<p>长按示例:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Input Trigger Timed Base 会检查输入是否已被按住一段时间，如是，则接受该输入并返回 持续（Ongoing） 状态。</span></span><br><span class="line"><span class="comment">插件提供的&quot;Input Trigger Timed Base&quot;类永远不会返回 已触发（Triggered） 状态。你要在新建的输入触发器子类中重载该函数，来确定它如何响应用户输入。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">**UInputTriggerHold.h**</span><br><span class="line"></span><br><span class="line"><span class="comment">/** UInputTriggerHold</span></span><br><span class="line"><span class="comment">    触发器会在输入保持激活状态达到HoldTimeThreshold秒之后触发。</span></span><br><span class="line"><span class="comment">    触发器可以选择触发一次或反复触发。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">UCLASS</span>(NotBlueprintable, MinimalAPI, meta = (DisplayName = <span class="string">&quot;Hold&quot;</span>))</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UInputTriggerHold</span> <span class="keyword">final</span> : <span class="keyword">public</span> UInputTriggerTimedBase</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> bTriggered = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ETriggerState <span class="title">UpdateState_Implementation</span><span class="params">(<span class="type">const</span> UEnhancedPlayerInput* PlayerInput, FInputActionValue ModifiedValue, <span class="type">float</span> DeltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ETriggerEventsSupported <span class="title">GetSupportedTriggerEvents</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> ETriggerEventsSupported::Ongoing; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入要保持多久才能导致触发？</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, Config, BlueprintReadWrite, Category = <span class="string">&quot;Trigger Settings&quot;</span>, meta = (ClampMin = <span class="string">&quot;0&quot;</span>))</span><br><span class="line">    <span class="type">float</span> HoldTimeThreshold = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此触发器应该仅触发一次，还是在满足保持时间阈值之后每帧触发？</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, Config, BlueprintReadWrite, Category = <span class="string">&quot;Trigger Settings&quot;</span>)</span><br><span class="line">    <span class="type">bool</span> bIsOneShot = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> FString <span class="title">GetDebugState</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> HeldDuration ? FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Hold:%.2f/%.2f&quot;</span>), HeldDuration, HoldTimeThreshold) : <span class="built_in">FString</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> ~~~</span><br><span class="line">**UInputTriggerHold.<span class="function">cpp**</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">ETriggerState <span class="title">UInputTriggerHold::UpdateState_Implementation</span><span class="params">(<span class="type">const</span> UEnhancedPlayerInput* PlayerInput, FInputActionValue ModifiedValue, <span class="type">float</span> DeltaTime)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// 更新HeldDuration并派生基础状态 </span></span><br><span class="line">    ETriggerState State = Super::<span class="built_in">UpdateState_Implementation</span>(PlayerInput, ModifiedValue, DeltaTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在HeldDuration达到阈值时触发 </span></span><br><span class="line">    <span class="type">bool</span> bIsFirstTrigger = !bTriggered; </span><br><span class="line">    bTriggered = HeldDuration &gt;= HoldTimeThreshold; </span><br><span class="line">    <span class="keyword">if</span> (bTriggered) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">return</span> (bIsFirstTrigger || !bIsOneShot) ? ETriggerState::Triggered : ETriggerState::None; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> State; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="平台设置"><a href="#平台设置" class="headerlink" title="平台设置"></a>平台设置</h2><p>映射上下文重定向（Mapping Context Redirect）。<br>默认情况下，它包含输入映射上下文的映射，允许你将一个上下文重定向到另一个上下文。<br>要应用此重定向，请将其添加到你的 项目设置（Project Settings） &gt; 增强输入（Enhanced Input） &gt; 平台设置（Platform Settings） &gt; 输入数据（Input Data）。</p>
<h2 id="其他课题与思考"><a href="#其他课题与思考" class="headerlink" title="其他课题与思考"></a>其他课题与思考</h2><p>常见的一个游戏功能就是玩家按键自定义。<br>这一块应该通过输入映射上下文就可以实现了。<br>这块再做一个本地保存应该就好。</p>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>UE基础功能</tag>
      </tags>
  </entry>
  <entry>
    <title>UE5.5-GameplayCue</title>
    <url>/UE/GAS/UE55GASGC/</url>
    <content><![CDATA[<h1 id="GameplayCue"><a href="#GameplayCue" class="headerlink" title="GameplayCue"></a>GameplayCue</h1><p>重要的类：<br>GameplayCueSet</p>
<p>但是游戏中的资源加载并不是这样进行的。</p>
<p>映射关系： Tag -&gt; GC</p>
<p>GC的收集过程：<br>将GameplayCue资产放在指定的目录下。<br>具体的可以在.ini里面配置。<br>以Lyra为例子</p>
<img src="/UE/GAS/UE55GASGC/image.png" class="" title="alt text">

<p>资源的加载：<br>关键类为UAbilitySystemGlobals与UGameplayCueManager。<br>可以看到GameplayCueManager里。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//UAbilitySystemGlobals部分</span><br><span class="line">//GameplayAbilitiesDeveloperSettings.h</span><br><span class="line">//注意宏里面Config的关键字</span><br><span class="line">/** Look in these paths for GameplayCueNotifies. These are your &quot;always loaded&quot; set. */</span><br><span class="line">UPROPERTY(Config, EditDefaultsOnly, Category=GameplayCue, meta = (ConfigRestartRequired=true))</span><br><span class="line">TArray&lt;FString&gt;	GameplayCueNotifyPaths;</span><br><span class="line">TArray&lt;FString&gt; UAbilitySystemGlobals::GetGameplayCueNotifyPaths()</span><br><span class="line">&#123;</span><br><span class="line">PRAGMA_DISABLE_DEPRECATION_WARNINGS</span><br><span class="line">    //Use set so we can append just unique paths</span><br><span class="line">    TSet&lt;FString&gt; ReturnPaths = TSet(GameplayCueNotifyPaths);</span><br><span class="line">PRAGMA_ENABLE_DEPRECATION_WARNINGS</span><br><span class="line"></span><br><span class="line">    ReturnPaths.Append(GetDefault&lt;UGameplayAbilitiesDeveloperSettings&gt;()-&gt;GameplayCueNotifyPaths);</span><br><span class="line">    return ReturnPaths.Array();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//CueManager部分</span><br><span class="line">TArray&lt;FString&gt; UGameplayCueManager::GetAlwaysLoadedGameplayCuePaths()</span><br><span class="line">&#123;</span><br><span class="line">    return UAbilitySystemGlobals::Get().GetGameplayCueNotifyPaths();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UGameplayCueManager::InitializeRuntimeObjectLibrary()</span><br><span class="line">&#123;</span><br><span class="line">    UE_SCOPED_ENGINE_ACTIVITY(TEXT(&quot;Initializing GameplayCueManager Runtime Object Library&quot;));</span><br><span class="line"></span><br><span class="line">    RuntimeGameplayCueObjectLibrary.Paths = GetAlwaysLoadedGameplayCuePaths();</span><br><span class="line">    if (RuntimeGameplayCueObjectLibrary.CueSet == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        RuntimeGameplayCueObjectLibrary.CueSet = NewObject&lt;UGameplayCueSet&gt;(this, TEXT(&quot;GlobalGameplayCueSet&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RuntimeGameplayCueObjectLibrary.CueSet-&gt;Empty();</span><br><span class="line">    RuntimeGameplayCueObjectLibrary.bHasBeenInitialized = true;</span><br><span class="line"></span><br><span class="line">    RuntimeGameplayCueObjectLibrary.bShouldSyncScan = ShouldSyncScanRuntimeObjectLibraries();</span><br><span class="line">    RuntimeGameplayCueObjectLibrary.bShouldSyncLoad = ShouldSyncLoadRuntimeObjectLibraries();</span><br><span class="line">    RuntimeGameplayCueObjectLibrary.bShouldAsyncLoad = ShouldAsyncLoadRuntimeObjectLibraries();</span><br><span class="line"></span><br><span class="line">    InitObjectLibrary(RuntimeGameplayCueObjectLibrary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lyra项目示例"><a href="#Lyra项目示例" class="headerlink" title="Lyra项目示例"></a>Lyra项目示例</h2><p>还是看到Lyra项目<br>对应的三个例子分别为<br>GE:<br>GE_GameplayCueTest_Burst<br>GE_GameplayCueTest_BurstLatent<br>GE_GameplayCueTest_Looping</p>
<p>GC:<br>GCN_Test_Burst<br>GCN_Test_BurstLatent<br>GCNL_Test_Looping</p>
<p>GE的Burst与BurstLatent都是Instant类型。<br>但对应的GC不同，一个派生自GCN_Burst（即Static）,一个派生自GCN_BurstLatent(即Actor)。<br>两者都只需要在OnBurst处理自定义逻辑即可。<br>而后者由于有存在Actor，可以在逻辑中使用延迟等操作。</p>
<p>&#x2F;&#x2F;关于Actor存在数目可以再关注一下bAllowMultipleWhileActiveEvents与bAllowMultipleWhileActiveEvents</p>
<p>而Looping，在GE处就要处理Looping逻辑。见Period。<br>GC则会有OnLoopingStart、OnRecurring、OnRemoval对应的逻辑事件处理。</p>
<h3 id="调用链条"><a href="#调用链条" class="headerlink" title="调用链条"></a>调用链条</h3><p>最上层的调用：<br>UAbilitySystemGlobals::Get().GetGameplayCueManager()-&gt;InvokeGameplayCueExecuted_FromSpec(Owner, SpecToUse, PredictionKey);<br>↓<br>GameplayCueManager的AddPendingCueExecuteInternal<br>↓<br>GameplayCueManager的FlushPendingCues<br>↓<br>取到ASC的GetReplicationInterface函数作为RepInterface，调用ASC的Call_InvokeGameplayCueExecuted_FromSpec<br>↓<br>ASC的NetMulticast_InvokeGameplayCueExecuted_Implementation<br>↓<br>ASC的InvokeGameplayCueEvent[这里指定了事件类型为Executed]</p>
<h2 id="总结和部分问题"><a href="#总结和部分问题" class="headerlink" title="总结和部分问题"></a>总结和部分问题</h2><p>因为GC实际上是由GameplayTag去触发的，但是在编辑器中不是很直观。可以考虑做一个工具来直观的展示对应的Tag和GC的对应关系。</p>
<h2 id="持续Buff的GCN"><a href="#持续Buff的GCN" class="headerlink" title="持续Buff的GCN"></a>持续Buff的GCN</h2><h3 id="问题描述和思考流程"><a href="#问题描述和思考流程" class="headerlink" title="问题描述和思考流程"></a>问题描述和思考流程</h3><p>如果应用多个GE的时候，GC表现不太对。<br>实际上，如果是单个的Buff，是要用到GE的Stacking功能来做。<br>【比如身上有中毒buff】</p>
<p>但是有一个问题。GCN是依赖于Tag与Event来处理的。<br>如果想要做一个中毒的表现，而多个buff可能会加上不同时间&#x2F;伤害等信息的中毒。<br>-&gt; GCN应该是用同一个Tag。但是需要所有buff都结束，才移除GCN。<br>换句话说 应该是Removed要判定？<br>对于中毒这个特效，应该只需要创建一个GCN就可以了。但是，removed必须要判定为所有的毒类型Buff都移除了才能执行。</p>
<p>这里需要关注<br>Cue的添加与WhileActive事件<br>ASC的AddGameplayCue_Internal<br>-&gt; wasInList</p>
<p>Cue的移除<br>ASC的RemoveGameplayCue_Internal函数。</p>
<p>这里如果移除的时候判定Tag可能会好一点。<br>可以自己重写试试。</p>
<p>获取到对应的ASC 并判断其Cue数量。<br>这里还存在虚幻引擎的模组API宏问题。（对于GCN_Looping这部分）禁止了接口暴露。</p>
<p>但实际上移除的时候是移除所有Tag的…</p>
<img src="/UE/GAS/UE55GASGC/image2.png" class="" title="alt text">

<img src="/UE/GAS/UE55GASGC/image3.png" class="" title="alt text">

<img src="/UE/GAS/UE55GASGC/image4.png" class="" title="alt text">

<img src="/UE/GAS/UE55GASGC/image5.png" class="" title="alt text">

<p>目前已经基于该思路验证并实现了这种持续GCN的效果。<br>算是一种实现方案。</p>
<p>不过，基于此，还需要考虑AOI以及ASC转移时的相关问题。</p>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>GAS</tag>
        <tag>Lyra</tag>
      </tags>
  </entry>
  <entry>
    <title>UE GAS Modifier相关信息</title>
    <url>/UE/GAS/UE55GASModifierInfos/</url>
    <content><![CDATA[<h1 id="总"><a href="#总" class="headerlink" title="总"></a>总</h1><p>列举各个Modifier相关的信息</p>
<h2 id="FGameplayModifierInfo"><a href="#FGameplayModifierInfo" class="headerlink" title="FGameplayModifierInfo"></a>FGameplayModifierInfo</h2><p>用于定义修改器的规则<br>关键数据 </p>
<ul>
<li>目标属性</li>
<li>修改方式</li>
<li>修改值</li>
<li>生效条件(Tags)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * FGameplayModifierInfo</span><br><span class="line"> *	Tells us &quot;Who/What we&quot; modify</span><br><span class="line"> *	Does not tell us how exactly</span><br><span class="line"> */</span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line">struct GAMEPLAYABILITIES_API FGameplayModifierInfo</span><br><span class="line">&#123;</span><br><span class="line">	GENERATED_USTRUCT_BODY()</span><br><span class="line">	</span><br><span class="line">	/** The Attribute we modify or the GE we modify modifies. */</span><br><span class="line">	UPROPERTY(EditDefaultsOnly, Category=GameplayModifier, meta=(FilterMetaTag=&quot;HideFromModifiers&quot;))</span><br><span class="line">	FGameplayAttribute Attribute;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * The numeric operation of this modifier: Override, Add, Multiply, etc</span><br><span class="line">	 * When multiple modifiers aggregate together, the equation is:</span><br><span class="line">	 * ((BaseValue + AddBase) * MultiplyAdditive / DivideAdditive * MultiplyCompound) + AddFinal</span><br><span class="line">	 */</span><br><span class="line">	UPROPERTY(EditDefaultsOnly, Category=GameplayModifier)</span><br><span class="line">	TEnumAsByte&lt;EGameplayModOp::Type&gt; ModifierOp = EGameplayModOp::Additive;</span><br><span class="line"></span><br><span class="line">	/** Magnitude of the modifier */</span><br><span class="line">	UPROPERTY(EditDefaultsOnly, Category=GameplayModifier)</span><br><span class="line">	FGameplayEffectModifierMagnitude ModifierMagnitude;</span><br><span class="line"></span><br><span class="line">	/** Evaluation channel settings of the modifier */</span><br><span class="line">	UPROPERTY(EditDefaultsOnly, Category=GameplayModifier)</span><br><span class="line">	FGameplayModEvaluationChannelSettings EvaluationChannelSettings;</span><br><span class="line"></span><br><span class="line">	UPROPERTY(EditDefaultsOnly, Category=GameplayModifier)</span><br><span class="line">	FGameplayTagRequirements	SourceTags;</span><br><span class="line"></span><br><span class="line">	UPROPERTY(EditDefaultsOnly, Category=GameplayModifier)</span><br><span class="line">	FGameplayTagRequirements	TargetTags;</span><br><span class="line"></span><br><span class="line">	/** Equality/Inequality operators */</span><br><span class="line">	bool operator==(const FGameplayModifierInfo&amp; Other) const;</span><br><span class="line">	bool operator!=(const FGameplayModifierInfo&amp; Other) const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="FModifierSpec"><a href="#FModifierSpec" class="headerlink" title="FModifierSpec"></a>FModifierSpec</h2><p>存储GEModifier的最终计算值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** Holds evaluated magnitude from a GameplayEffect modifier */</span><br><span class="line">USTRUCT()</span><br><span class="line">struct FModifierSpec</span><br><span class="line">&#123;</span><br><span class="line">	GENERATED_USTRUCT_BODY()</span><br><span class="line"></span><br><span class="line">	FModifierSpec() : EvaluatedMagnitude(0.f) &#123; &#125;</span><br><span class="line"></span><br><span class="line">	float GetEvaluatedMagnitude() const &#123; return EvaluatedMagnitude; &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">	/** In the event that the modifier spec requires custom magnitude calculations, this is the authoritative, last evaluated value of the magnitude */</span><br><span class="line">	UPROPERTY()</span><br><span class="line">	float EvaluatedMagnitude;</span><br><span class="line"></span><br><span class="line">	/** These structures are the only ones that should internally be able to update the EvaluatedMagnitude. Any gamecode that gets its hands on FModifierSpec should never be setting EvaluatedMagnitude manually */</span><br><span class="line">	friend struct FGameplayEffectSpec;</span><br><span class="line">	friend struct FActiveGameplayEffectsContainer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="FGameplayModifierEvaluatedData"><a href="#FGameplayModifierEvaluatedData" class="headerlink" title="FGameplayModifierEvaluatedData"></a>FGameplayModifierEvaluatedData</h2><p>修改器具体结果数据<br>关键数据 </p>
<ul>
<li>目标属性</li>
<li>修改方式</li>
<li>修改值</li>
<li>FActiveGEHandle</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** Data that describes what happened in an attribute modification. This is passed to ability set callbacks */</span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line">struct FGameplayModifierEvaluatedData</span><br><span class="line">&#123;</span><br><span class="line">	GENERATED_USTRUCT_BODY()</span><br><span class="line"></span><br><span class="line">	FGameplayModifierEvaluatedData()</span><br><span class="line">		: Attribute()</span><br><span class="line">		, ModifierOp(EGameplayModOp::Additive)</span><br><span class="line">		, Magnitude(0.f)</span><br><span class="line">		, IsValid(false)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FGameplayModifierEvaluatedData(const FGameplayAttribute&amp; InAttribute, TEnumAsByte&lt;EGameplayModOp::Type&gt; InModOp, float InMagnitude, FActiveGameplayEffectHandle InHandle = FActiveGameplayEffectHandle())</span><br><span class="line">		: Attribute(InAttribute)</span><br><span class="line">		, ModifierOp(InModOp)</span><br><span class="line">		, Magnitude(InMagnitude)</span><br><span class="line">		, Handle(InHandle)</span><br><span class="line">		, IsValid(true)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/** What attribute was modified */</span><br><span class="line">	UPROPERTY()</span><br><span class="line">	FGameplayAttribute Attribute;</span><br><span class="line"></span><br><span class="line">	/** The numeric operation of this modifier: Override, Add, Multiply, etc  */</span><br><span class="line">	UPROPERTY()</span><br><span class="line">	TEnumAsByte&lt;EGameplayModOp::Type&gt; ModifierOp;</span><br><span class="line"></span><br><span class="line">	/** The raw magnitude of the applied attribute, this is generally before being clamped */</span><br><span class="line">	UPROPERTY()</span><br><span class="line">	float Magnitude;</span><br><span class="line"></span><br><span class="line">	/** Handle of the active gameplay effect that originated us. Will be invalid in many cases */</span><br><span class="line">	UPROPERTY()</span><br><span class="line">	FActiveGameplayEffectHandle	Handle;</span><br><span class="line"></span><br><span class="line">	/** True if something was evaluated */</span><br><span class="line">	UPROPERTY()</span><br><span class="line">	bool IsValid;</span><br><span class="line"></span><br><span class="line">	FString ToSimpleString() const</span><br><span class="line">	&#123;</span><br><span class="line">		return FString::Printf(TEXT(&quot;%s %s EvalMag: %f&quot;), *Attribute.GetName(), *EGameplayModOpToString(ModifierOp), Magnitude);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>UEGAS</tag>
        <tag>GAS Modifier</tag>
      </tags>
  </entry>
  <entry>
    <title>GASPredictionKey自学简记</title>
    <url>/UE/GAS/UEGamplayPrediction%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="关键点：PredictionKey"><a href="#关键点：PredictionKey" class="headerlink" title="关键点：PredictionKey"></a>关键点：PredictionKey</h1><p>由GA激活生成的PKey，并由此去影响GAS系统中的各个其他部分。</p>
<p>客户端预测先行，在收到服务器校验结果后，执行对应的回滚操作。</p>
<h2 id="概念：预测窗口-Prediction-Window"><a href="#概念：预测窗口-Prediction-Window" class="headerlink" title="概念：预测窗口 Prediction Window"></a>概念：预测窗口 Prediction Window</h2><blockquote>
<p>“We do not predict over multiple frames”</p>
</blockquote>
<p>在多个行为激活形成链条时，每个行为有自己的PKey，但又和之前的PKey相关联。<br>服务端并不确定Reject某个PKey对应的行为，是否会导致后续的行为也被拒绝。这里在实现的时候可能需要额外注意下。</p>
<h2 id="关于预测窗口"><a href="#关于预测窗口" class="headerlink" title="关于预测窗口"></a>关于预测窗口</h2><p>GA如果依赖于外部事件，或者定时器，在异步等待过程中，可能会收到服务器的confirm&#x2F;reject回调。而PKey在ActivateAbility返回时就结束了。因此后面激活的内容是无法绑定到这个PKey上的。</p>
<p>【这里可以验证一下 PKey在下发回客户端执行的事情（比如说广播），如果是广播形式，那么确实后面的内容就有问题了。】</p>
<p>预测窗口和预测键不会跨帧。但是预测本身是可以支持跨帧的。这里主要处理的是异步的GATask等逻辑。为了实现跨多帧的预测逻辑，就需要多个预测窗口。每个帧内的操作都是独立的预测窗口，每个异步操作需要自己的同步执行块。</p>
<p>这里异步操作对应的预测窗口创建：<br>• Ability中去创建新的PredictionWindow - 见<code>FScopedPredictionWindow</code></p>
<h2 id="学习方案和计划"><a href="#学习方案和计划" class="headerlink" title="学习方案和计划"></a>学习方案和计划</h2><p>虽然目前国内有着许多AI工具，但是在专业领域里面，AI工具的幻觉还是比较严重的。此外，虚幻引擎的GAS系统也在不断更新和迭代。虚幻4的GAS和虚幻5的GAS在很多接口上面和设计逻辑上面都有着许多的不同。</p>
<p>在学习时，一方面是要注重设计的理念和思想，一方面是基于目前应用的版本。或者是使用最新版本的引擎和插件来学习。</p>
<p>在学习和了解时，要基于项目源码。以及一些参考的项目示例。<br>比较好的是虚幻的ActionRPG项目和Lyra项目。不过ActionRPG项目的代码和实现逻辑在研究过后发现是比较旧的，网上的UE5版本的也是基于UE4版本的来改动的。此外，ActionRPG还是本地单机项目，在网络预测上面的逻辑还是比较少，可以说仅参考部分逻辑吧。</p>
<p>要保持思考，特别是针对目前网络同步的部分，很多实现比较简单，在真实项目应用时，需要多考虑一些。UE一些实现方案对于一些游戏项目也存在问题，要做对应的适配处理。</p>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>GAS</tag>
      </tags>
  </entry>
  <entry>
    <title>UE5.5-GAS-ReadMe</title>
    <url>/UE/GAS/UE55GAS/</url>
    <content><![CDATA[<!-- - <meting-js id="13344900252" server="netease" type="playlist" type="playlist" mutex="true" preload="auto" theme="var(--anzhiyu-main)" order="list"></meting-js>   -->

<h3 id="GAS"><a href="#GAS" class="headerlink" title="GAS"></a>GAS</h3><h1 id="Purpose-of-this-Documentation"><a href="#Purpose-of-this-Documentation" class="headerlink" title="Purpose of this Documentation"></a>Purpose of this Documentation</h1><p>This documentation is meant to support and enhance the <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/gameplay-ability-system-for-unreal-engine">official Gameplay Ability System Unreal Developer Community documentation</a>.  In particular, this document lives in the code repository under <a href="./">Gameplay Ability System plug-in folder</a> and thus any user reading this documentation can submit a pull request to clarify functionality, update inaccurate information, or work with the community to flesh out areas that are missing.</p>
<p>It is worth noting there are extensive resources that the wider end-user developer community has written.  One such source of knowledge is the <a href="https://github.com/tranek/GASDocumentation">tranek GAS documentation</a> which is highly detailed and an excellent resource for implementation details, but risks falling out of date with new feature additions or changes.</p>
<h1 id="Overview-of-the-Gameplay-Ability-System"><a href="#Overview-of-the-Gameplay-Ability-System" class="headerlink" title="Overview of the Gameplay Ability System"></a>Overview of the Gameplay Ability System</h1><p>The Gameplay Ability System is a framework for building abilities and interactions that Actors can own and trigger. This system is designed mainly for RPGs, action-adventure games, MOBAs, and other types of games where characters have abilities that need to coordinate mechanics, visual effects, animations, sounds, and data-driven elements, although it can be adapted to a wide variety of projects. The Gameplay Ability System also supports replication for multiplayer games, and can save developers a lot of time scaling up their designs to support multiplayer.</p>
<p>The concepts that the Gameplay Ability System uses are:</p>
<ul>
<li><a href="#gameplay-attributes">Gameplay Attributes</a>:  An enhancement to float properties that allow them to be temporarily modified (buffed) and used in complex calculations such as damage.</li>
<li><a href="#gameplay-tags">Gameplay Tags</a>:  A hierarchical naming system that allows you to specify states of Actors, and properties of Assets.  A powerful query system allows designers to craft logic statements around these.</li>
<li><a href="#gameplay-cues">Gameplay Cues</a>:  A visual and audio effects system based on Gameplay Tags which allow decoupling of the FX and the implementation.</li>
<li><a href="#gameplay-abilities">Gameplay Abilities</a>:  The code that actually triggers when an action is performed.  Typically a Blueprint graph.</li>
<li><a href="#gameplay-effects">Gameplay Effects</a>:  Predefined rulesets about how to apply all of the above.</li>
</ul>
<p>One of the designers’ often mentioned goals of the Gameplay Ability System is to maintain a record of who triggered a complex set of interactions, so that we can keep proper account of which Actor did what.  For instance, if a Player activates a <a href="#gameplay-abilities">Gameplay Ability</a> that spawns a poison cloud (possibly represented with a <a href="#gameplay-cue">Gameplay Cue</a>) that then does damage-over-time using a <a href="#gameplay-effects">Gameplay Effect</a> which eventually reduces an Actor’s Health <a href="#gameplay-attributes">Gameplay Attribute</a> to zero, we should be able to award the kill to the initiating Player.</p>
<p>It is worth mentioning the damage system upfront, as it’s a pervasive example throughout the documentation.  You may be familiar with the <a href="https://www.unrealengine.com/blog/damage-in-ue4">AActor::TakeDamage function</a> which was used for many years.  At Epic, we no longer use that system internally; instead all damage is done through the Gameplay Ability System.  By using the Gameplay Ability System, we allow buffs&#x2F;debuffs and an extensive and ever-changing list of damage types based on Gameplay Tags.  You can look at <a href="https://dev.epicgames.com/documentation/unreal-engine/lyra-sample-game-in-unreal-engine">Lyra</a> as an example that uses the Gameplay Ability System extensively, as well as a rudimentary damage system.</p>
<hr>
<h1 id="Ability-System-Component-asc"><a href="#Ability-System-Component-asc" class="headerlink" title="Ability System Component asc}"></a>Ability System Component {#asc}</h1><p>The Ability System Component (commonly abbreviated ASC) is the top-level ActorComponent that you use to interface with the Gameplay Ability System (commonly abbreviated GAS).  It is a monolithic class that encapsulates almost all of the functionality GAS uses.  By funneling all of the functionality through the ASC, we are able to better encapsulate and enforce the rules about activation, replication, prediction, and side-effects.</p>
<p>While the Ability System Component <em>is</em> an ActorComponent, we typically recommend against putting it on a Player’s Pawn.  Instead, for a Player, it should be on the PlayerState.  The reason for this is that the Pawn is typically destroyed upon death in multiplayer games, and GAS typically has functionality (be it <a href="#gameplay-attributes">Gameplay Attributes</a>, <a href="#gameplay-tags">Gameplay Tags</a>, or <a href="#gameplay-abilities">Gameplay Abilities</a>) that should persist beyond death.  For non-player AI-driven characters (e.g. AI that are not bots), it is suitable to put the ASC on the Pawn because it needs to replicate data to <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/actor-role-and-remote-role-in-unreal-engine#actorrolestates">Simulated Proxies</a>.</p>
<hr>
<h1 id="Gameplay-Attributes-gameplay-attributes"><a href="#Gameplay-Attributes-gameplay-attributes" class="headerlink" title="Gameplay Attributes gameplay-attributes}"></a>Gameplay Attributes {#gameplay-attributes}</h1><p>Gameplay Attributes (often just referred to as simply <em>Attributes</em>) are essentially <em>float</em> properties that are wrapped in a FGameplayAttributeData instance.  The reason for doing so is to allow for a <em>BaseValue</em> which one can think of as an unaltered intrinsic value of the Actor, and a <em>CurrentValue</em> which one can think of as the value that currently applies, after all of the buffs and debuffs of the Actor are taken into account.  These <em>Attributes</em> must live in an <a href="#attribute-sets">AttributeSet</a>.  There is Editor tooling around the use of <em>Attributes</em> that allow them to be selected and used inside <a href="#gameplay-effects">Gameplay Effects</a> (and others) to ensure buffs and debuffs work correctly.</p>
<p>Attributes are often replicated, thus keeping the client in sync with the server values, but that does not <em>always</em> need to be the case.  For instance, certain <em>meta-Attributes</em> can be used to store temporary data used for calculations, allowing these intermediate results to have full buff&#x2F;debuff aggregation capabilities; these <em>meta-Attributes</em> are not replicated because they are typically reset after a calculation.</p>
<p>Since Gameplay Attributes are easily accessible through native or Blueprint code, it’s tempting to modify them directly.  However, the Gameplay Ability System is designed such that all modifications to the Attributes should be done through <a href="#gameplay-effects">Gameplay Effects</a> to ensure they can be network predicted and rolled-back gracefully.</p>
<p><a href="https://dev.epicgames.com/documentation/unreal-engine/gameplay-attributes-and-attribute-sets-for-the-gameplay-ability-system-in-unreal-engine">Developer Community Gameplay Attribute &amp; AttributeSet Docs</a></p>
<h2 id="AttributeSets-attribute-sets"><a href="#AttributeSets-attribute-sets" class="headerlink" title="AttributeSets attribute-sets}"></a>AttributeSets {#attribute-sets}</h2><p>AttributeSets are simply classes derived from <a href="./Source/GameplayAbilities/Public/AttributeSet.h">UAttributeSet class</a>.  The AttributeSets typically contain multiple Gameplay Attributes that encompass all properties for a specific game feature (such as a jetpack item, but the most commonly cited example is the damage system).  AttributeSets must be added to the <a href="#asc">Ability System Component</a> by the server.  AttributeSets are typically replicated to the client, but not all Attributes are replicated to the client (they are configured on a per-Attribute basis).</p>
<h2 id="Attribute-Modifiers-attribute-modifiers"><a href="#Attribute-Modifiers-attribute-modifiers" class="headerlink" title="Attribute Modifiers attribute-modifiers}"></a>Attribute Modifiers {#attribute-modifiers}</h2><p>Attribute Modifiers are how we buff and debuff Attributes.  These are setup through the <a href="#gameplay-effects">Gameplay Effects’</a> <code>Modifiers</code> property.  Once a modifier is ‘active’, it is stored in the <a href="#asc">Ability System Component</a> and all requests for the value go through a process called <em>aggregation</em>.</p>
<p>The rules for <em>aggregation</em> can be unexpected to a new user.  For instance, if there are multiple values that modify a single attribute, the modifiers are added together before the result is computed.  Let’s take an example of a multiplier of 10% added to damage, and another multiplier of 30% added to damage.  If one were purely looking at the numbers, one could think <code>Damage * 1.1 * 1.3 = 1.43</code> thus damage would be modified by <em>43%</em>.  However, the system takes these modifier operators into account and adds them separately before performing the final multiplier calculation, giving an expected result of <code>10% + 30% = 40%</code>.</p>
<hr>
<h1 id="Gameplay-Abilities-gameplay-abilities"><a href="#Gameplay-Abilities-gameplay-abilities" class="headerlink" title="Gameplay Abilities gameplay-abilities}"></a>Gameplay Abilities {#gameplay-abilities}</h1><p>Gameplay Abilities are derived from the <a href="./Source/GameplayAbilities/Public/GameplayAbility.h">UGameplayAbility class</a>.  They define what an in-game ability does, what (if anything) it costs to use, when or under what conditions it can be used, and so on.  Because Gameplay Abilities are implemented in native or Blueprints, it can do anything a Blueprint graph can do.  Unlike traditional Blueprints, they are capable of existing as instanced objects running asynchronously – so you can run specialized, multi-stage tasks (called <a href="#gameplay-ability-tasks">Gameplay Ability Tasks</a>.  Examples of Gameplay Abilities would be a character dash, or an attack.</p>
<p>Think of a Gameplay Ability as the bundle of functions that correspond to the action you’re performing.  There are complex rules about who can activate them, how they activate, and how they are predicted (locally executed ahead of the server acknowledgement).  You trigger them through the Ability System Component (typically through a TryActivate function).  But they can also be triggered through complex interactions (if desired) such as through Gameplay Events, <a href="#gameplay-tags">Gameplay Tags</a>, <a href="#gameplay-effects">Gameplay Effects</a>, and Input (which the <a href="#asc">ASC</a> handles internally).</p>
<p><a href="https://dev.epicgames.com/documentation/unreal-engine/using-gameplay-abilities-in-unreal-engine">Developer Community Gameplay Abilities docs</a></p>
<h2 id="Gameplay-Ability-Tasks-gameplay-ability-tasks"><a href="#Gameplay-Ability-Tasks-gameplay-ability-tasks" class="headerlink" title="Gameplay Ability Tasks gameplay-ability-tasks}"></a>Gameplay Ability Tasks {#gameplay-ability-tasks}</h2><p>Gameplay Abilities often make use of <a href="https://dev.epicgames.com/documentation/unreal-engine/gameplay-ability-tasks-in-unreal-engine">Gameplay Ability Tasks</a>.  Gameplay Ability Tasks are latent Blueprint nodes that allow your Gameplay Ability to ‘pause’ for the frame while it awaits some event.  They can also perform network functionality which hide complex implementation details from the Blueprint designer.</p>
<h2 id="Gameplay-Ability-Specs"><a href="#Gameplay-Ability-Specs" class="headerlink" title="Gameplay Ability Specs"></a>Gameplay Ability Specs</h2><p>The Gameplay Ability Specs are runtime-defined data which augment and tie together parameters used for the Gameplay Ability.  It serves two purposes:</p>
<ol>
<li>To configure the Gameplay Ability parameters prior to giving&#x2F;granting the ability.  For instance, it defines what ‘Level’ of the ability you are granting.</li>
<li>To store information about the granted Gameplay Ability that is shared between all instances of the Gameplay Ability.</li>
</ol>
<p>A lot of the <a href="#asc">Ability System Component</a>‘s interface deals with Gameplay Ability Specs, or after being granted, typically a Gameplay Ability Spec Handle.  The Handles are a way to succinctly refer to a Gameplay Ability Spec in both native and Blueprint code without worrying about the dangers of holding onto a pointer (and having that pointer be reallocated).  Whenever you want to refer to an already-granted Ability, use an Ability Spec Handle instead.</p>
<p>The corresponding class for <a href="./Source/GameplayAbilities/Public/GameplayAbilitySpec.h">FGameplayAbilitySpec</a> and <a href="./Source/GameplayAbilities/Public/GameplayAbilitySpecHandle.h">FGameplayAbilitySpecHandle</a>.</p>
<h2 id="Gameplay-Ability-Instancing-Policy"><a href="#Gameplay-Ability-Instancing-Policy" class="headerlink" title="Gameplay Ability Instancing Policy"></a>Gameplay Ability Instancing Policy</h2><p>The instancing policy determines when a Gameplay Ability is instanced (the Gameplay Ability object is created) and thus controls the lifetime of the GA.  The safest, and most feature-supported choice is InstancedPerActor.</p>
<h3 id="InstancedPerActor"><a href="#InstancedPerActor" class="headerlink" title="InstancedPerActor"></a>InstancedPerActor</h3><p>When choosing InstancedPerActor, the Gameplay Ability will be instanced when its corresponding Gameplay Ability Spec is first given (granted) to the Actor.  The instance lives until the Gameplay Ability Spec is removed from the Actor.  This lifetime mimics what most users expect:  You are granted an ability and immediately have an instance of it.</p>
<p>The lifetime semantics come with some pitfalls you should be aware of:</p>
<ul>
<li>Since the ability continues to exist after it has ended, none of the variables will be reset for next activation.  Thus it’s the user’s responsibility to reset the variables to the defaults in EndAbility.</li>
<li>Prior to UE5.5, you could receive function calls such as OnGiveAbility&#x2F;OnRemoveAbility on the <em>instance</em> immediately, before the ability had ever been activated.  This isn’t true of the other instancing types, which execute said functions on the CDO.  UE5.5 deprecates such functions in favor of explicit execution on the CDO.</li>
<li>There is a function you may see often called GetPrimaryInstance.  The Primary Instance refers to the InstancedPerActor’s one-and-only instance; it does not apply to other instancing types.</li>
</ul>
<h3 id="InstancedPerExecution"><a href="#InstancedPerExecution" class="headerlink" title="InstancedPerExecution"></a>InstancedPerExecution</h3><p>When choosing InstancedPerExecution, you receive a new instance of the Gameplay Ability for each and every activation.  Some things you should be aware of:</p>
<ul>
<li>The instancing happens on activation (not prior to it).  It is possible to Grant &amp; Revoke an InstancedPerExecution ability without ever instancing it.</li>
<li>Replicated Gameplay Abilities (GA’s which contain RPC’s or Replicated Variables) are relatively expensive, as a new GA must be sent for every activation.</li>
<li>Unlike InstancedPerActor, an individual instance is always active (otherwise it would have not been created).  It is garbage collected immediately upon ending.</li>
</ul>
<h3 id="NonInstanced-Deprecated"><a href="#NonInstanced-Deprecated" class="headerlink" title="NonInstanced (Deprecated)"></a>NonInstanced (Deprecated)</h3><p>Prior to UE5.5, we had functionality for Non-Instanced Gameplay Abilities.  Since these Gameplay Abilities were never instanced, they could not be replicated or even hold state (e.g. contain variables).  All functions were called on the ClassDefaultObject and thus all state had to be held on the Gameplay Ability Spec.  This made them very confusing to use.  The same functionality can be achieved by simply using InstancedPerActor and never revoking it; the cost is just a single allocation (instance) of a UGameplayAbility.</p>
<h2 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h2><p>There is a replication policy variable on the Gameplay Abilities.  The setting controls whether or not you are able to use Remote Procedure Calls (RPC’s) or Replicated Variables (now deprecated, see below).  It does <em>not</em> control if a Gameplay Ability will activate both on Server &amp; Client – that is controlled via the Execution Policy.</p>
<p>Keep in mind that Gameplay Abilities exist only on the locally controlled actors and on the server.  As such, you cannot replicate data meant to be visible on Simulated Proxies using Gameplay Abilities.  You would have to use other mechanisms, such as Attributes for replicated variables, or use RPC’s directly on the Actors.</p>
<h3 id="Replicated-Variables-in-Gameplay-Abilities"><a href="#Replicated-Variables-in-Gameplay-Abilities" class="headerlink" title="Replicated Variables in Gameplay Abilities"></a>Replicated Variables in Gameplay Abilities</h3><p>The usage of replicated variables is deprecated as of UE5.5.  The deprecation warning is controlled by a Console Variable “AbilitySystem.DeprecateReplicatedProperties”, so that users can turn off the warning and continue using the feature until they are ready to fix the issue.</p>
<p>The reasoning is to prevent users from stumbling upon an impossible-to-solve bug regarding replication ordering:</p>
<ul>
<li>Replicated variables are guaranteed to be delivered, but not in any particular order with respect to each other or RPC functions.</li>
<li>Gameplay Ability activation (and most synchronizing functions such as Target Data) rely on RPC’s exchanged between the Client and Server.</li>
<li>Therefore, when executing an RPC (e.g. Gameplay Ability Activation) and performing operations on a replicated variable, you would never be guaranteed to have an up-to-date or stale value.</li>
</ul>
<p>For more information, see the <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/replicated-object-execution-order-in-unreal-engine">EDC article on object replication order</a>.</p>
<p>If you believe you need a replicated variable, the solution is to instead use a Reliable RPC to send that data over.  Using a Reliable RPC will ensure proper ordering with the underlying synchronization mechanisms of GAS.</p>
<h3 id="Remote-Procedure-Calls-in-Gameplay-Abilities"><a href="#Remote-Procedure-Calls-in-Gameplay-Abilities" class="headerlink" title="Remote Procedure Calls in Gameplay Abilities"></a>Remote Procedure Calls in Gameplay Abilities</h3><p>Remote Procedure Calls (RPC’s) are the preferred method of communicating data between the client&#x2F;server.  By making a Reliable RPC, you can ensure proper ordering with the other Gameplay Ability functions that support replication such as Activation.  There is currently no restriction against Unreliable RPC’s, but know that order or delivery is not guaranteed.</p>
<p>Using a Multicast RPC will produce a validation warning (typically visible when compiling the Blueprint).  Since Gameplay Abilities never exist on Simulated Proxies, Multicast RPC’s make little sense in the context of a Gameplay Ability.</p>
<h3 id="RPC-Batching-to-Ensure-Proper-Activation-and-ReplicatedTargetData-Order"><a href="#RPC-Batching-to-Ensure-Proper-Activation-and-ReplicatedTargetData-Order" class="headerlink" title="RPC Batching to Ensure Proper Activation and ReplicatedTargetData Order"></a>RPC Batching to Ensure Proper Activation and ReplicatedTargetData Order</h3><p>There is a trick Epic uses internally to bundle the Gameplay Ability activation and Replicated Target Data.  Normally, if one were to implement a Locally Predicted Gameplay Ability that calls Activate() which in turn sets Replicated Target Data, the two would arrive at the Server in separate RPC’s:</p>
<ol>
<li>ServerTryActivateAbility (which will in turn call Activate)</li>
<li>ServerSetReplicatedTargetData (which will then set the data to the desired value – but Activate has already run!)</li>
</ol>
<p>There is a structure called <a href="./Source/GameplayAbilities/Public/GameplayAbilityTypes.h">FScopedServerAbilityRPCBatcher</a> which is designed to use a single RPC to send both Activation and Target Data.  To use it, do the following:</p>
<ol>
<li>In your <code>UAbilitySystemComponent</code>-derived class, override <code>ShouldDoServerAbilityRPCBatch</code> to return true.</li>
<li>In native code, Create an FScopedServerAbilityRPCBatcher on the stack.</li>
<li>Activate your Ability through your desired function (e.g. TryActivateAbility).</li>
<li>During the initial Activation of your ability, perform any CallServerSetReplicatedTargetData call.</li>
<li>When the destructor of the FScopedServerAbilityRPCBatcher executes (by going out of scope), it will call a batched RPC that contains both the Activation and the ReplicatedTargetData.</li>
</ol>
<p>By using this structure, you will be guaranteed that the Server has the desired RPC data prior to calling the Gameplay Ability’s activation function.</p>
<hr>
<h1 id="Gameplay-Effects-gameplay-effects"><a href="#Gameplay-Effects-gameplay-effects" class="headerlink" title="Gameplay Effects gameplay-effects}"></a>Gameplay Effects {#gameplay-effects}</h1><p>The purpose of Gameplay Effects is to modify an Actor in a predictable (and undoable) way.  Think of the verb Affect when you think of Gameplay Effects.  These are not Visual Effects or Sound Effects (those are called Gameplay Cues).  The Gameplay Effects are <em>applied</em> using <a href="#gameplay-effect-specs">Gameplay Effect Specs</a> through the Ability System Component.</p>
<ul>
<li>Gameplay Effects that have a Duration (non-Instant) will automatically undo any modifications to the Actor upon removal. Instant ones will modify the Attribute’s <em>BaseValue</em>.</li>
<li>These are typically data-only Blueprints, though native implementations are also supported.</li>
<li>They should be static after compile time; there is no way to modify them during runtime (Gameplay Effect Specs are the runtime version).</li>
<li>They are essentially a complex datatable of things that should occur to a Target Actor when ‘applied’.</li>
<li>Composed from these pieces:<ul>
<li>Duration &#x2F; Timing data (such as how long the Effect lasts for, or how it periodically executes).</li>
<li>Rules for Stacking the Gameplay Effects.</li>
<li>Attribute Modifiers (data that controls how a Gameplay Attribute is modified and thus can be undone).</li>
<li>Custom Executions (a user definable function that executes every time a Gameplay Effect is applied).</li>
<li>Gameplay Effect Components (fragments of code &#x2F; behavior to execute when applied).</li>
<li>Rules for applying Gameplay Cues (the VisualFX and AudioFX).</li>
</ul>
</li>
</ul>
<h2 id="Gameplay-Effect-Components-gameplay-effect-components"><a href="#Gameplay-Effect-Components-gameplay-effect-components" class="headerlink" title="Gameplay Effect Components gameplay-effect-components}"></a>Gameplay Effect Components {#gameplay-effect-components}</h2><p>Gameplay Effect Components are introduced in UE5.3 to declutter the Gameplay Effect user interface and allow users of the Engine to provide their own game-specific functionality to Gameplay Effects.  </p>
<p>Read the interface for <a href="./Source/GameplayAbilities/Public/GameplayEffectComponent.h">UGameplayEffectComponent</a></p>
<h2 id="Gameplay-Effect-Specs-gameplay-effect-specs"><a href="#Gameplay-Effect-Specs-gameplay-effect-specs" class="headerlink" title="Gameplay Effect Specs gameplay-effect-specs}"></a>Gameplay Effect Specs {#gameplay-effect-specs}</h2><p>These are the runtime wrapper structs for a Gameplay Effect.  They define the Gameplay Effect, any dynamic parameters (such as SetByCaller data), and the tags as they existed when the Spec was created.  The majority of the runtime API’s use a <em>GameplayEffectSpec</em> rather than a <em>GameplayEffect</em>.</p>
<h2 id="Gameplay-Effect-Executions-gameplay-effect-executions"><a href="#Gameplay-Effect-Executions-gameplay-effect-executions" class="headerlink" title="Gameplay Effect Executions gameplay-effect-executions}"></a>Gameplay Effect Executions {#gameplay-effect-executions}</h2><p>Gameplay Effect Executions are game-specific, user-written functions that are configured to execute when particular Gameplay Effects execute.  They typically read from and write to <a href="#gameplay-attributes">Gameplay Attributes</a>.  These are used when the calculations are much more complex than can be achieved with a simple attribute modifier.  Examples of this would be a damage system (see the <a href="https://dev.epicgames.com/documentation/unreal-engine/lyra-sample-game-in-unreal-engine">Lyra Example</a>).</p>
<hr>
<h1 id="Gameplay-Tags-gameplay-tags"><a href="#Gameplay-Tags-gameplay-tags" class="headerlink" title="Gameplay Tags gameplay-tags}"></a>Gameplay Tags {#gameplay-tags}</h1><p>The Gameplay Ability System uses Gameplay Tags extensively throughout.  See the <a href="https://dev.epicgames.com/documentation/unreal-engine/using-gameplay-tags-in-unreal-engine">official Developer Community documentation</a> for more details.</p>
<hr>
<h1 id="Gameplay-Cues-gameplay-cues"><a href="#Gameplay-Cues-gameplay-cues" class="headerlink" title="Gameplay Cues gameplay-cues}"></a>Gameplay Cues {#gameplay-cues}</h1><p>Gameplay Cues are a system for decoupling visual and audio fx from gameplay code.  On start-up, special Gameplay Cue asset folders are scanned for <a href="./Source/GameplayAbilities/Public/GameplayCueSet.h">Gameplay Cue Sets</a>, and <em>Gameplay Cue Notify</em> classes.</p>
<p>The implementer of a gameplay feature will either call the <a href="#asc">Ability System Component</a>‘s GameplayCue functions, or the <a href="./Source/GameplayAbilities/Public/GameplayCueManager.h">GameplayCueManager</a>‘s Gameplay Cue functions with a specific <a href="#gameplay-tag">Gameplay Tag</a>.  The effects artist will then create a <em>Gameplay Cue Notify</em> that corresponds to that tag.  The Gameplay Cue Manager is responsible for routing that specific tag to the proper <em>Gameplay Cue Notify</em>.</p>
<h2 id="Gameplay-Cue-replication"><a href="#Gameplay-Cue-replication" class="headerlink" title="Gameplay Cue replication"></a>Gameplay Cue replication</h2><p>The details of Gameplay Cue replication are complex and worth noting.  Because these are cosmetic-only, there are unreliable RPC’s that are used to communicate the execution of short-lived “<em>Burst</em>“ cues.  We also use variable replication to synchronize the existance of longer cues (typically referred to as <em>Looping</em> or <em>Actor Notfies</em>).  This two-tiered approach ensures that Gameplay Cues can be dropped as unimportant, but also ensures important cues can be visible to any clients that <em>become relevant</em> according to the network system.</p>
<p>Due to these Gameplay Cues needing to obey network relevancy (i.e. far away players should not replicate their Cues, but newly relevant ones should) and the fact that the PlayerState is <em>always relevant</em>, there is a <em>replication proxy</em> system.  The Player’s Pawn (who has its <a href="#asc">ASC</a> on the PlayerState) should implement the <a href="./Source/GameplayAbilities/Public/AbilitySystemReplicationProxyInterface.h">IAbilitySystemReplicationProxyInterface</a>.  When turning on the ASC’s ReplicationProxyEnabled variable, all unreliable Gameplay Cue RPC’s will go through the proxy interface (the Pawn, which properly represents relevancy).</p>
<p>An advanced form of replication proxies also exists for the property replication so it may follow the same relevancy rules.  See <code>FMinimalGameplayCueReplicationProxy</code> in the <a href="./Source/GameplayAbilities/Public/GameplayCueInterface.h">GameplayCueInterface</a>.</p>
<p>Due to the Burst Cues being replicated by RPC and the Looping Cues being replicated by replicated variables, one can run into an issue where the unreliable burst RPC gets dropped but the looping events (OnBecomeRelevant&#x2F;OnCeaseRelevant) arrive.  Less obvious, the unreliable OnBurst RPC can arrive but the OnBecomeRelevant&#x2F;OnCeaseRelevant can be dropped if the Cue is removed on the server quick enough to result in no state changes for network serialization.</p>
<p>See the section on <a href="#gc-events">Gameplay Cue Events</a> below for guidelines on how to implement your Gameplay Cue while taking into consideration network replication.</p>
<h2 id="Gameplay-Cue-Events-gc-events"><a href="#Gameplay-Cue-Events-gc-events" class="headerlink" title="Gameplay Cue Events gc-events}"></a>Gameplay Cue Events {#gc-events}</h2><p>When implementing a Gameplay Cue Notify Actor, the (legacy) naming of the functions may be confusing.  In UE5.5 the Blueprint (user-facing) names have changed in order to better represent what each function does.  They are laid out below.</p>
<h3 id="OnExecute"><a href="#OnExecute" class="headerlink" title="OnExecute"></a>OnExecute</h3><p>The execute function is the easiest to reason about:  It happens when you <em>Execute</em> a one-shot Gameplay Cue (aka a Static Notify &#x2F; non-Looping Gameplay Cue).  The code path to Execute a Gameplay Cue (for Static Notifies) is different than the code path to Add a Gameplay Cue (for Looping Gameplay Cues aka Actor Notifies).</p>
<p>Due to the code path for execution being different, the caller of the Gameplay Cue must know that the receiver of the Gameplay Cue is a Static Notify in order for this to execute properly.  The call should route through ExecuteGameplayCue see <a href="./Source/GameplayAbilities/Public/GameplayCueFunctionLibrary.h">GameplayCueFunctionLibrary</a>.</p>
<h3 id="OnBurst-native-OnActive"><a href="#OnBurst-native-OnActive" class="headerlink" title="OnBurst (native: OnActive)"></a>OnBurst (native: OnActive)</h3><p>This event executes only once when a <em>Looping Gameplay Cue</em> first fires.  Due to it being delivered by unreliable RPC, it can be dropped silently by a client.  You can use this to implement cosmetic effects that are only relevant if a client witnessed the Gameplay Cue triggering.</p>
<h3 id="OnBecomeRelevant-native-WhileActive"><a href="#OnBecomeRelevant-native-WhileActive" class="headerlink" title="OnBecomeRelevant (native: WhileActive)"></a>OnBecomeRelevant (native: WhileActive)</h3><p>This event executes when the <em>Looping Gameplay Cue</em> first comes into network relevancy (usually when it’s first added).  For instance, PawnA can have a Gameplay Cue activated, PawnB can join the game and still receive PawnA’s OnBecomeRelevant – but not receive OnBurst.</p>
<p>This is important to understand as OnBecomeRelevant and OnCeaseRelevant are both guaranteed to fire on the same Cue, whereas OnBurst is not guaranteed.</p>
<h3 id="OnCeaseRelevant-native-OnRemove"><a href="#OnCeaseRelevant-native-OnRemove" class="headerlink" title="OnCeaseRelevant (native: OnRemove)"></a>OnCeaseRelevant (native: OnRemove)</h3><p>This event executes when the <em>Looping Gameplay Cue</em> gets removed from network relevancy.  Usually that’s when the server executes the removal of the Cue, but could also be when the client loses relevancy (e.g. by distance) of the viewed Cue.</p>
<p>In UE5.5, a warning is introduced if a Gameplay Cue implements OnBurst and OnCeaseRelevant and not OnBecomeRelevant.  The reasoning is that the opposite of OnCeaseRelevant is OnBecomeRelevant, not OnBurst and it’s likely that the old naming scheme (OnActive&#x2F;OnRemove) was a source of confusion.</p>
<hr>
<h1 id="How-Gameplay-Prediction-Works"><a href="#How-Gameplay-Prediction-Works" class="headerlink" title="How Gameplay Prediction Works"></a>How Gameplay Prediction Works</h1><p>There is documentation for how the Gameplay Prediction mechanisms work at the top of <a href="./Source/GameplayAbilities/Public/GameplayPrediction.h">GameplayPrediction.h</a>.</p>
<hr>
<h1 id="Ability-System-Globals"><a href="#Ability-System-Globals" class="headerlink" title="Ability System Globals"></a>Ability System Globals</h1><p>There is a class called <a href="./Source/GameplayAbilities/Public/AbilitySystemGlobals.h">AbilitySystemGlobals</a> which provide project customization points for how to handle specific base Ability System scenarios.  For example, there a functions you can override to implement derived classes of types used throughout the code (such as <code>AllocGameplayEffectContext</code>).</p>
<p>In UE5.5, a lot of these settings have started migrating to the <a href="./Source/GameplayAbilities/Public/GameplayAbilitiesDeveloperSettings.h">GameplayAbilitiesDeveloperSettings</a> (which can be accessed using the Editor and choose the Project Settings menu item).  The rough division of responsibilities:  If it’s a global setting (like a variable) then it should be configurable through Gameplay Abilities Developer Settings; if it’s functionality (such as allocating project-specific classes) it should be in <a href="./Source/GameplayAbilities/Public/AbilitySystemGlobals.h">AbilitySystemGlobals</a>.</p>
<hr>
<h1 id="Debugging-the-Gameplay-Ability-System"><a href="#Debugging-the-Gameplay-Ability-System" class="headerlink" title="Debugging the Gameplay Ability System"></a>Debugging the Gameplay Ability System</h1><h2 id="Legacy-ShowDebug-Functionality"><a href="#Legacy-ShowDebug-Functionality" class="headerlink" title="Legacy ShowDebug Functionality"></a>Legacy ShowDebug Functionality</h2><p>Prior to UE5.4, the way to debug the Gameplay Ability System was to use the “ShowDebug AbilitySystem” command.  Once there, you can cycle through the categories using the command <code>AbilitySystem.Debug.NextCategory</code> or explicitly choose a category using <code>AbilitySystem.Debug.SetCategory</code>.  This system is no longer maintained and may be deprecated in future versions.  You should instead be looking at the <a href="#gameplay-debugger">Gameplay Debugger</a> functionality.</p>
<h2 id="Gameplay-Debugger-gameplay-debugger"><a href="#Gameplay-Debugger-gameplay-debugger" class="headerlink" title="Gameplay Debugger gameplay-debugger}"></a>Gameplay Debugger {#gameplay-debugger}</h2><p>New in UE5.4, there is enhanced Gameplay Debugger functionality for the Gameplay Ability System.  This functionality is preferred over the ShowDebug system and should be your first line of defense in debugging GAS.  To enable it, open the Gameplay Debugger typically by using <code>shift-apostrophe</code> (<code>shift-&#39;</code>) to select the locally controlled player, or simply the <code>apostrophe</code> (<code>&#39;</code>) key to select the Actor that is closest to your reticule.</p>
<p>The debugger will show you the AbilitySystemComponent’s current state as it pertains to Gameplay Tags, Gameplay Abilities, Gameplay Effects, and Gameplay Attributes.  In a networked game, the color coding helps to differentiate between how the server and client view their state.</p>
<h2 id="Console-Commands"><a href="#Console-Commands" class="headerlink" title="Console Commands"></a>Console Commands</h2><p>There are console commands that help both in developing and debugging GAS.  They are a great way to verify that your assumptions are correct about how abilities and effects should be activated, and coupled with the <a href="#gameplay-debugger">Gameplay Debugger</a>, what your state should be once executed.</p>
<p>All Ability System debug commands are prefixed with <code>AbilitySystem</code>.  The functionality we’re reviewing here exists in the <a href="./Source/GameplayAbilities/Private/AbilitySystemCheatManagerExtension.cpp">AbilitySystemCheatManagerExtension</a>.  The source code also serves as an excellent reference  how to properly trigger the Gameplay Abilities and Gameplay Effects in native code (and what the expected results would be, depending on their configurations).</p>
<p>By implementing these in a Cheat Manager Extension, you are able to properly execute them as a local player, or on the server.  Many of the commands allow such a distinction with the <code>-Server</code> argument (read the command documentation or source code for more information).</p>
<p>One of the gotchas when using these commands is that the assets should be loaded prior to their use.  This is easily done in the Editor by simply right-clicking on the assets you want to use and clicking “Load Assets”.</p>
<p><code>AbilitySystem.Ability.Grant &lt;ClassName/AssetName&gt;</code> Grants an Ability to the Player.  Granting only happens on the Authority, so this command will be sent to the Server.<br><code>AbilitySystem.Ability.Activate [-Server] &lt;TagName/ClassName/AssetName&gt;</code> Activate a Gameplay Ability.  Substring name matching works for Activation Tags (on already granted abilities), Asset Paths (on non-granted abilities), or Class Names on both.  Some Abilities can only be activated by the Client or the Server and you can control all of these activation options by specifying or ommitting the <code>-Server</code> argument.<br><code>AbilitySystem.Ability.Cancel [-Server] &lt;PartialName&gt;</code> Cancels (prematurely Ends) a currently executing Gameplay Ability.  Cancelation can be initiated by either the Client or Server.<br><code>AbilitySystem.Ability.ListGranted</code> List the Gameplay Abilities that are granted to the local player.  Since granting is done on the Server but replicated to the Client, these should always be in sync (so no option for -Server).</p>
<p><code>AbilitySystem.Effect.ListActive [-Server]</code> Lists all of the Gameplay Effects currently active on the Player.<br><code>AbilitySystem.Effect.Remove [-Server] &lt;Handle/Name&gt;</code> Remove a Gameplay Effect that is currently active on the Player.<br><code>AbilitySystem.Effect.Apply [-Server] &lt;Class/Assetname&gt; [Level]</code> Apply a Gameplay Effect on the Player.  Substring name matching works for Asset Tags, Asset Paths, or Class Names.  Use -Server to send to the server (default is apply locally).</p>
<p>Gameplay Cues have their own set of debug commands.</p>
<p><code>AbilitySystem.LogGameplayCueActorSpawning</code> Log when we create GameplayCueNotify_Actors.<br><code>AbilitySystem.DisplayGameplayCues</code> Display GameplayCue events in world as text.<br><code>AbilitySystem.GameplayCue.DisplayDuration</code> Configure the amount of time Gameplay Cues are drawn when <code>DisplayGameplayCues</code> is enabled.<br><code>AbilitySystem.DisableGameplayCues</code> Disables all GameplayCue events in the world.<br><code>AbilitySystem.GameplayCue.RunOnDedicatedServer</code> Run gameplay cue events on dedicated server.<br><code>AbilitySystem.GameplayCueActorRecycle</code> Allow recycling of GameplayCue Actors.<br><code>AbilitySystem.GameplayCueActorRecycleDebug</code> Prints logs for GC actor recycling debugging.<br><code>AbilitySystem.GameplayCueCheckForTooManyRPCs</code> Warns if gameplay cues are being throttled by network code.</p>
<h2 id="Visual-Logger"><a href="#Visual-Logger" class="headerlink" title="Visual Logger"></a>Visual Logger</h2><p>New in UE5.4, there has been extra care put into the <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/visual-logger-in-unreal-engine">Visual Logger</a> facilities for the Gameplay Ability System.  The <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/visual-logger-in-unreal-engine">Visual Logger</a> is useful to see the complex interactions of Gameplay Abilities and Gameplay Effects over time.  The Visual Logger always captures the verbose logs and saves a snapshot of the state of the Ability System Component on every frame there is a log entry.</p>
<p>In UE5.4, the <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/visual-logger-in-unreal-engine">Visual Logger</a> now correctly orders the events between clients and servers when using Play In Editor.  This makes the Visual Logger especially useful for debugging how the client and server interact when activating abilities, gameplay effects, and modifying attributes.</p>
]]></content>
      <categories>
        <category>UE Source</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>GAS</tag>
        <tag>UE Source</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity Shadow</title>
    <url>/Mine/Unity/Shadow/</url>
    <content><![CDATA[<p>阴影Shadow</p>
<p>光源可以产生两种阴影：</p>
<ul>
<li>Real-time Shadows 实时阴影<ul>
<li>Unity stores the shadows cast from each Light in <strong>shadow map textures</strong>. The textures update each frame; shadows move when the lights move.</li>
</ul>
</li>
<li>Baked Shadows 烘培阴影<ul>
<li>The Unity <strong>lightmapper</strong> stores the shadows received by each GameObject in <strong>static lightmap textures</strong>, <strong>shadow mask textures</strong>, or <strong>Light Probes</strong>. Shadows don’t move when the lights move.</li>
</ul>
</li>
</ul>
<p>物体的阴影投射：<br>是否生成阴影除了和光源相关还和对应MeshRenderer的设置相关。可以在Mesh Renderer的Lighting内设置。</p>
<h2 id="Shadow-Mapping"><a href="#Shadow-Mapping" class="headerlink" title="Shadow Mapping"></a>Shadow Mapping</h2><p><a href="https://zhuanlan.zhihu.com/p/45653702">Unity实时阴影实现——Shadow Mapping</a><br><a href="https://zhuanlan.zhihu.com/p/382202359">影子传说——三种Shadowmap改进算法的原理与在Unity中的实现</a></p>
<blockquote>
<p>The process of creating shadow textures called shadow maps.</p>
</blockquote>
<p>正如上面所述，实时阴影通过Shadow Map纹理来实现。</p>
<p>原理上和摄像机生成深度纹理一致。</p>
<ul>
<li>第一个过程，在光源处设置相机绘制场景，深度测试和写入打开，生成shadow map。</li>
<li>第二个过程，正常绘制场景，把当前片段转换到光源空间，计算得到的深度与采样shadow map得到的深度比较大小，判断当前片段是否在阴影中。</li>
</ul>
<p>阴影贴图的大小影响细节表现，但也会占用更多的内存带宽。</p>
<p>点光源 - 在6个方向上进行捕获，似于6个聚光灯。</p>
<p>可以调整Shadow Distance来优化远处的阴影。</p>
<h2 id="Shadow-Cascades-级联阴影"><a href="#Shadow-Cascades-级联阴影" class="headerlink" title="Shadow Cascades 级联阴影"></a>Shadow Cascades 级联阴影</h2><p><a href="https://docs.unity3d.com/6000.0/Documentation/Manual/shadow-cascades.html">Introduction to shadow cascades</a><br>目标：在不提高阴影贴图分辨率的情况下，提高阴影的视觉保真度。</p>
<p><strong>仅适用于定向光源</strong>。</p>
<p>Built-In有0-2-4共3档级联数量可以选择。</p>
<p>性能影响：</p>
<ul>
<li>增加级联阴影的数量会增加Shadow Rendering Pass的DrawCall。减少级联数量可以显著的减少其Draw Call。</li>
<li>可以依据不同Scene来设定级联的数量</li>
<li>You can configure different shadow cascade settings and shadow resolution settings for different quality levels using multiple URP Assets.</li>
</ul>
<h3 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h3><p>定向光源可以照亮整个场景 - Shadow Map将覆盖非常大的场景范围。<br>这将导致“Perspective Aliasing”(透视锯齿)问题:Shadow Map靠近相机的像素看起来更大且会有锯齿。</p>
<p>究其原因，是Shadow Map不同区域按摄像机透视不成比例的进行放大（由视锥决定）。<strong>靠近相机的阴影部分的贴图分辨率更低</strong>。</p>
<p>使用Soft Shadows：优化透视锯齿，但会占用更多内存和带宽。</p>
<p>级联阴影：<br>依据与摄像机的<strong>距离</strong>将视锥体分为两个区域，<strong>近的区域使用缩小的Shadow Map（分辨率相同）</strong>。<br>These staged reductions in shadow map size are known as cascaded shadow maps (sometimes called parallel split shadow maps).</p>
<img src="/Mine/Unity/Shadow/cascadedShadow.png" class="" title="Cascades Shadow">

<h3 id="URP-设置"><a href="#URP-设置" class="headerlink" title="URP 设置"></a>URP 设置</h3><p>可以在URP Asset里面单独配置</p>
<img src="/Mine/Unity/Shadow/URPSetting.png" class="" title="alt text">]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>UE - GameplayFramework</title>
    <url>/UE/OfficialDocLearn/GameplayFramework/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>虚幻在5.3版本后，官方文档(英文)修改了GameplayFramework的Overview视图。其更明晰了。中文版的视图见5.5版本。</p>
<p>本文基于官方文档、虚幻5.5源码和大钊InsideUE4Gameplay框架文章进行梳理和整理。</p>
<h2 id="旧框架视图"><a href="#旧框架视图" class="headerlink" title="旧框架视图"></a>旧框架视图</h2><img src="/UE/OfficialDocLearn/GameplayFramework/gameframework.png" class="">

<h2 id="新视图"><a href="#新视图" class="headerlink" title="新视图"></a>新视图</h2><img src="/UE/OfficialDocLearn/GameplayFramework/gameplay-schematic.png" class="">

<h1 id="Basic-Gameplay-Framework"><a href="#Basic-Gameplay-Framework" class="headerlink" title="Basic Gameplay Framework"></a>Basic Gameplay Framework</h1><h2 id="类概览"><a href="#类概览" class="headerlink" title="类概览"></a>类概览</h2><ul>
<li>Actor</li>
<li>Actor Component</li>
<li>Pawn</li>
<li>Character</li>
<li>Controller[PlayerController &amp; AI Controller]</li>
<li>World</li>
<li>GameMode</li>
<li>GameInstance</li>
<li>GameInstanceSubSystem</li>
<li>GameState</li>
<li>PlayerState</li>
<li>GameplayStatics</li>
<li>UserInterface(UI)</li>
<li>HUD</li>
<li>Camera</li>
</ul>
<p>虚幻新框架视图会显得更明晰一些。其</p>
<h1 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h1><p>源码:Actor.h<br>AActor</p>
<blockquote>
<p>Actor is the base class for an Object that can be placed or spawned in a level.</p>
</blockquote>
<p>但Actor本身是抽象的。比如AInfo。其位置信息也是由其组件来存。<br>可以认为，Actor即世界中的元素。</p>
<p>进一步理解Actor还是要从其功能特点入手：</p>
<ul>
<li>Actor Components的容器</li>
<li>网络复制 变量复制和RPC。<br> 虚幻的网络角色还是位于Actor的。</li>
<li>Tick（主TickFunction，见PrimaryActorTick）</li>
</ul>
<p>而Transform信息，则位于Actor的RootComponent(USceneComponent)中。<br>对于一些常用的操作，Actor封装了方法，内部实现都是转发到对应的Component来真正处理对应的逻辑。</p>
<h1 id="ActorComponent"><a href="#ActorComponent" class="headerlink" title="ActorComponent"></a>ActorComponent</h1><p>源码：ActorComponent.h<br>UActorComponent</p>
<blockquote>
<p>the base class for components that define reusable behavior that can be added to different types of Actors.</p>
</blockquote>
<p>部分Component家族:</p>
<ul>
<li><p>USceneComponent<br>“a transform and supports attachment” 位置属性和嵌套支持。ActorComponent本身并不支持嵌套。Actor本身的AttachToActor实际上也是通过USceneComponent来做的。</p>
<p>对于蓝图类，其默认会处理USceneComponent。具体的处理逻辑可以看到ActorConstruction.cpp中ExecuteConstruction。可以进一步了解SCS(SimpleConstructionScript简单构造脚本)相关内容。</p>
</li>
<li><p>UPrimitiveComponent<br>“SceneComponents that contain or generate some sort of geometry” 用于渲染或碰撞。比如派生的子类UMeshComponent。</p>
</li>
<li><p>ChildActorComponent<br>“Spawns an Actor when registered, and destroys it when unregistered.”</p>
</li>
</ul>
<h1 id="GameInstance"><a href="#GameInstance" class="headerlink" title="GameInstance"></a>GameInstance</h1><p>UGameInstance<br>整一个游戏实例。（Play in Editor时会为每一个Editor实例生成一个）在使用Dedicated Server或Listen Server时，服务端也存在着对应的一个GameInstance。<br>在游戏创建的时候生成，并且一直存在，直到游戏销毁。</p>
<p>可以用于存放切换关卡时仍然要保留的数据。</p>
<h2 id="WorldContext"><a href="#WorldContext" class="headerlink" title="WorldContext"></a>WorldContext</h2><p>FWorldContext</p>
<blockquote>
<p>A context for dealing with UWorlds at the engine level</p>
</blockquote>
<p>用于跟踪世界信息。<br>当进行World切换时，便会利用到WorldContext。如其内部包含TravelURL、TravelType、LastURL等信息。</p>
<p>FWorldContext由GameInstance持有，并且内部存在着指向当前World的指针:ThisCurrentWorld。</p>
<p>相关Travel逻辑:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UEngine::TickWorldTravel</span><br><span class="line">UEngine::LoadMap</span><br><span class="line"> - 处理NewWorld(如FindWorldInPackage)，并且WorldContext调用SetCurrentWorld更新指向World。</span><br></pre></td></tr></table></figure>
<p>在Travel中会创建一个新的World，并更新对应的WorldContext信息。</p>
<h1 id="GameInstanceSubsystem"><a href="#GameInstanceSubsystem" class="headerlink" title="GameInstanceSubsystem"></a>GameInstanceSubsystem</h1><p>UGameInstanceSubsystem<br>其生命周期和GameInstance相同。<br>更多的可以去看看Subsystem.h<br>和部分引擎结构共享相同的生命周期。</p>
<h1 id="World"><a href="#World" class="headerlink" title="World"></a>World</h1><p>UWorld</p>
<blockquote>
<p>The top level object representing a map or a sandbox in which Actors and Components will exist and be rendered. </p>
</blockquote>
<p>从运行时的逻辑讲，一般只有一个World存在。但在编辑器中，是存在多个World的。每个可交互的编辑器视口便是一个World。</p>
<p>可以认为是逻辑上的世界。</p>
<p>而在World下，有几个比较关键的概念:</p>
<ul>
<li>TObjectPtr<class ULevel>	&#x2F;&#x2F;PersistentLevel  一开始遍加载的Level。可以认为是“主关卡”</li>
<li>TArray&lt;TObjectPtr&lt;ULevel&gt;&gt; &#x2F;&#x2F;Levels 当前世界中的Level集合。(不进行序列化)</li>
<li>TObjectPtr<class AGameStateBase> GameState &#x2F;&#x2F;游戏数据GameState</li>
<li>TObjectPtr<AGameModeBase>	AuthorityGameMode &#x2F;&#x2F;服务器上的当前GameMode</li>
<li>PhysicsScene &#x2F;&#x2F;全局的物理场景</li>
<li>ControllerList</li>
<li>PlayerControllerList</li>
<li>网络相关的NetDriver和NetworkManager</li>
</ul>
<p>总体而言，World是一个逻辑世界概念。其包含了关卡集合、GameMode、GameState、各类控制器、物理、网络等众多信息。<br>在运行过程中，World也会有更换流程（比如WorldTravel中，使用WorldContext存储上下文信息，会创建新的World并设置给WorldContext）。</p>
<h1 id="Level"><a href="#Level" class="headerlink" title="Level"></a>Level</h1><p>ULevel</p>
<blockquote>
<p>A Level is a collection of Actors (lights, volumes, mesh instances etc.).</p>
</blockquote>
<p>关卡。用于组织Actors。</p>
<p>关键信息：</p>
<ul>
<li>TObjectPtr<AWorldSettings> WorldSettings; &#x2F;&#x2F;关卡属性</li>
<li>TArray&lt;TObjectPtr&lt;AActor&gt;&gt; Actors;       &#x2F;&#x2F;处于关卡中的所有Actor。包括AWorldSettings</li>
<li>TObjectPtr<class ALevelScriptActor> LevelScriptActor &#x2F;&#x2F;关卡蓝图的基类</li>
</ul>
<h2 id="WorldSetting"><a href="#WorldSetting" class="headerlink" title="WorldSetting"></a>WorldSetting</h2><p>AWorldSettings</p>
<blockquote>
<p>Actor containing all script accessible world properties.</p>
</blockquote>
<p>准确说存储着关卡的相关信息。Level的加载也会影响到World，对于Streaming Level的动态加载&#x2F;卸载不涉及到UWorld的创建，不会影响其相关设置。</p>
<h1 id="笔记内容"><a href="#笔记内容" class="headerlink" title="笔记内容"></a>笔记内容</h1><img src="/UE/OfficialDocLearn/GameplayFramework/img.png" class="">

<h1 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h1><p>写在前面：<br>最好先去看看World和Level之间的关系，也可以看看源码</p>
<ul>
<li>Game Instance </li>
<li>UWorld</li>
<li>ULevel</li>
<li>AActor</li>
</ul>
<p>Game Instance</p>
<ul>
<li>整一个游戏实例 服务端也有一个<br>Game Instance Subsystem</li>
</ul>
<p>GameMode</p>
<ul>
<li>Server Only</li>
<li>With Level [准确说是With World]</li>
<li>Managing the overall rules and structure of a gameplay session</li>
</ul>
<p>GameState</p>
<ul>
<li>A GameMode to A Game State [With Level][准确说是With World]</li>
<li>Replication</li>
</ul>
<p>Player State</p>
<ul>
<li>Associate with Player [With Level][准确说是With World]</li>
<li>Replication</li>
</ul>
<p>Player</p>
<ul>
<li>由GameMode处理生成</li>
<li>Pawn &amp;&amp; Controller</li>
</ul>
<p>其他部分<br>这里的概念还是可以参考知乎的文章<br><a href="https://zhuanlan.zhihu.com/p/22924838">Level And World</a><br>重读也会有不同的理解。</p>
<p>关卡和对象的结构组织 和资源的加载、销毁有着对应的关系，还是要重视的。</p>
<p>GameInstance</p>
<ul>
<li>WorldContext </li>
<li>World<ul>
<li>GameMode</li>
<li>Levels<ul>
<li>Level <ul>
<li>WorldSettings</li>
<li>LevelScriptActor</li>
<li>Actors[内部其实涵盖AWorldSettings 与 ALevelScriptActor]</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
      </tags>
  </entry>
  <entry>
    <title>2025 - UE - ShangHaiFest</title>
    <url>/UE/Share/25ShangHaiFest/</url>
    <content><![CDATA[<p>个人对25UE上海Fest公开直播部分做的小重点记录。<br>下次有机会一定到买票去现场看看。<br>关于其他演讲，官方说10月1号后会有陆续放出，可以再关注关注。</p>
<h2 id="莉莉丝的远光84"><a href="#莉莉丝的远光84" class="headerlink" title="莉莉丝的远光84"></a>莉莉丝的远光84</h2><p>跨平台开发<br>Unreal的跨平台开发框架</p>
<p>性能优化 - Scalability + Significant Manager  Unreal Insights</p>
<p>Unreal的内容生产工具</p>
<ul>
<li>大地图</li>
<li>高品质角色 </li>
<li>高品质动画 ALS Animation Motion Matching</li>
<li>角色技能 GAS 框架</li>
</ul>
<p>Fortnite 项目实践分享</p>
<h2 id="51World"><a href="#51World" class="headerlink" title="51World"></a>51World</h2><p>AI<br>交互式变化：</p>
<ul>
<li>自然语言交互</li>
<li>上下文情景感知</li>
<li>个性化内容生成</li>
</ul>
<p>实时空间计算</p>
<p>数据标准升维</p>
<h2 id="5-6重点回顾"><a href="#5-6重点回顾" class="headerlink" title="5.6重点回顾"></a>5.6重点回顾</h2><p>Performance的提升</p>
<p>Lumen光追性能的提升</p>
<p>Skeletal Mesh Pipeline的重写、 CPU和GPU的异步运行支持</p>
<p>布料模拟的优化</p>
<p>Niagara Fluids 流体优化</p>
<p>动画方面：<br>Multi Character Motion Matching<br>Sequencer 的缝合轨迹 在动画间切换</p>
<p>大世界方面：<br>Steaming</p>
<p>物理：</p>
<ul>
<li>异步的物理状态创建 Physics State Creation</li>
<li>Groud Scatter from PCG - runs on GPU</li>
<li>FastGeo Plugin - for streaming static geometry</li>
</ul>
<p>移动端：<br>Mobile Preview的优化</p>
<p>打包方面：<br>可以了解一下，有相关支持可以在不重新打包的情况下进行迭代</p>
<p>Metahuman的优化</p>
<h2 id="5-7"><a href="#5-7" class="headerlink" title="5.7"></a>5.7</h2><p>可以去看看roadmap</p>
<p>Nanite的优化。</p>
<p>Experimental </p>
<ul>
<li>Recommaned Not shipping on it</li>
<li>API变化、文档变化、工作流变化等<br>Beta</li>
<li>Likely have shipped internal projects on this</li>
<li>Likely reasonably ready for everyone within 2 releases.</li>
</ul>
<p>关于引擎版本维护<br>不更改引擎。限制更改。<br>Best Practices：</p>
<ul>
<li>Use components&#x2F;Plugin based development</li>
<li>Use&#x2F;Add minimally invasive extension points and extend in plugins</li>
<li>Document&#x2F;comment changes</li>
<li>Revert changes down the line when Epic improvements arrive</li>
<li>Do shadow integrations on special integration branch</li>
<li>Dont change all the things.Focus on an area unique to your game.</li>
</ul>
<p>UE开发方式和工具</p>
<ul>
<li>Horde <a href="https://www.flyandnotdown.com/post/2098fb78-2f78-802b-85b7-d466d3f811b4">参考文章</a></li>
<li>Zen <a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/zen-loader-in-unreal-engine">官网</a></li>
<li>Unreal Build Accelerator(UBA)</li>
</ul>
<h3 id="5-7新特性"><a href="#5-7新特性" class="headerlink" title="5.7新特性"></a>5.7新特性</h3><h4 id="渲染工作流程与可拓展性"><a href="#渲染工作流程与可拓展性" class="headerlink" title="渲染工作流程与可拓展性"></a>渲染工作流程与可拓展性</h4><p>Substrate Materials</p>
<ul>
<li>next generation material expression</li>
</ul>
<p>MegaLights (Beta)<br>灯光性能<br>目标是硬件光线追踪</p>
<p>Nanite Foliage &amp; Skinning(Experimental)</p>
<ul>
<li>Scale,render  &amp; animate dense,high detail foliage assets</li>
<li>future?: Nanite for character?</li>
</ul>
<p>60Hz优化计划</p>
<ul>
<li>Frame pacing</li>
<li>GPU Profile（Experimental）</li>
</ul>
<p>New Material Translator(Experimental)</p>
<ul>
<li>删除重复着色器 优化着色器</li>
</ul>
<p>Virtual Texture(已经支持并建议使用)</p>
<ul>
<li>流式传输所需要的部分纹理</li>
</ul>
<h4 id="Simulation"><a href="#Simulation" class="headerlink" title="Simulation"></a>Simulation</h4><p>Niagara</p>
<ul>
<li>MegaLights 支持粒子光源</li>
<li>Nanite Renderer</li>
<li>Stateless emitters</li>
</ul>
<p>Chaos Physics<br>Character simulation(Experimental)</p>
<ul>
<li>fast in runtime, pre calculation in editor</li>
</ul>
<h4 id="World-Creation"><a href="#World-Creation" class="headerlink" title="World Creation"></a>World Creation</h4><p>官方Doc World Building Guide<br><a href="https://dev.epicgames.com/community/learning/knowledge-base/r6wl/unreal-engine-world-building-guide">World Building Guide</a></p>
<p>PCG(Procedural Content Generation)(Production Ready)</p>
<ul>
<li>both editor and runtime</li>
<li>can run GPU only</li>
</ul>
<p>New Foliage &amp; Vegetation tools(Experimental) </p>
<p>Mesh Terrain(Experimental)</p>
<ul>
<li>not simple height field</li>
</ul>
<p>Fast Geo Steaming(Production Ready)[大世界]</p>
<p>Memory tracking for world partition in insight(Production Ready)</p>
<p>Custom HLODs （(Production Ready)）</p>
<h4 id="Character-Animation"><a href="#Character-Animation" class="headerlink" title="Character &amp; Animation"></a>Character &amp; Animation</h4><p>Animation Authoring</p>
<ul>
<li>Selection Sets(Beta)</li>
<li>On Mesh Controls(Experimental)</li>
</ul>
<p>Sequencer</p>
<ul>
<li>Sequence Validation(Experimental)</li>
</ul>
<p>Rigging</p>
<p>Retargeting</p>
<p>Animation Runtime &amp; Gameplay</p>
<p>Unreal Animation Framework(experimental)</p>
<ul>
<li>State Machine UX,state reEntry</li>
<li>Motion Matching Chooser integration</li>
<li>Adjustment Blending,abstract Hierarchy</li>
<li>Various UI&#x2F;UX</li>
</ul>
<p>Mover 2.0</p>
<ul>
<li>New spring-based movement model 基于弹簧的运动模型</li>
<li>Network physics driven kinematic movement</li>
<li>Debugger</li>
</ul>
<p>Mutable<br>Customizable Character System</p>
<ul>
<li>Mutable Graph</li>
<li>Mutable Core</li>
<li>Mutable Editor<br>如果要做自定角色可以看看<br>(Mentioned as important system)、</li>
</ul>
<p>MetaHuman Framework</p>
<h4 id="Framework-Gameplay-Systems"><a href="#Framework-Gameplay-Systems" class="headerlink" title="Framework &amp; Gameplay Systems"></a>Framework &amp; Gameplay Systems</h4><p>NetworkingSystems</p>
<p>Iris replication systems(Beta)</p>
<ul>
<li>performance benefits</li>
</ul>
<p>Multi server replication plugin(Experimental)</p>
<p>State Tree</p>
<ul>
<li>for make complex state systems</li>
</ul>
<p>Gameplay Camera System(Experimental)</p>
<p>Mass Framework</p>
<h4 id="Developer-Creator-Iteration-Workflows"><a href="#Developer-Creator-Iteration-Workflows" class="headerlink" title="Developer &amp; Creator Iteration Workflows"></a>Developer &amp; Creator Iteration Workflows</h4><p>Incremental Cooking(Beta)<br>之前是 iterative cooking。</p>
<ul>
<li>Only cook the delta for assets that have changed in your scene.</li>
<li>编辑器环境cook优化</li>
</ul>
<p>Build Health Analytics(Experimental)</p>
<p>Zen Platform Streaming<br>优化打包测试调试流程</p>
<p>Cook Improvements</p>
<ul>
<li>Speed提升</li>
<li>内存占用提升</li>
</ul>
<p>Unreal Build Accelerator<br>联合编译</p>
<ul>
<li>Hugely improved code &amp; shader complication speeds</li>
</ul>
<p>Audio</p>
<p>MetaSound</p>
<h2 id="卡顿优化-Hitches"><a href="#卡顿优化-Hitches" class="headerlink" title="卡顿优化 Hitches"></a>卡顿优化 Hitches</h2><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>1.What is slow？<br>Use Profiler</p>
<p>2.Why is it slow?<br>Investigate,with facts,not guess.</p>
<p>3.How do we fix it?<br>Use info from the point we start fixing it. Not Before.</p>
<p>实际上和重构那本书所述，不要盲目的优化，基于分析，也仅基于分析，而不是臆想。</p>
<h3 id="常见卡顿原因"><a href="#常见卡顿原因" class="headerlink" title="常见卡顿原因"></a>常见卡顿原因</h3><p>List of common hitches：</p>
<ol>
<li><p>Level Steaming</p>
<ul>
<li>Actors for static geometry<ul>
<li>PLAs(Packed Level Actors)</li>
<li>PCG (Single Actor per cell with ISM component)</li>
<li>ISM&#x2F;HISM ((Hierarchical Instance Static Mesh))</li>
<li>Foliage Tool</li>
<li>Use Mass or Niagara</li>
<li>Cell Transformers (For World Partitioned Maps)</li>
<li>Fast Geo Streaming Plugin</li>
</ul>
</li>
</ul>
</li>
<li><p>The Physics<br>推荐视频<br><a href="https://dev.epicgames.com/community/learning/talks-and-demos/3KWR/unreal-engine-collision-data-in-ue5-practical-tips-for-managing-collision-settings-queries-unreal-fest-2023">Collision Data in UE5: Practical Tips for Managing Collision Settings &amp; Queries | Unreal Fest 2023</a></p>
<ul>
<li>optimizing meshes for physics<ul>
<li>Simple and complex physics.Use simple as complex, only override on a per-mesh basis.</li>
<li>Prefer in order: Sphere,Capsule,Box,Convex Polygon(Capsule的低于Box的)</li>
<li>No Physcis</li>
<li>Set up proper collision channels.</li>
<li>Disable Unnecessary Overlaps</li>
<li>Skip Updating Overlaps during level streaming</li>
<li>Reduce the physics scene size</li>
<li>Editor View Modes and Chaos Visual Debugger to find issues.</li>
<li>Use Physics Proxies</li>
<li>Use Async Traces(Only C++. Delay to next frame)</li>
<li>Async Physics Initialization(Experimental)</li>
</ul>
</li>
</ul>
</li>
<li><p>Actor Spawning</p>
<ul>
<li>Needs to complete immediately</li>
<li>Simplify Actor. Limit the number spawn dynamically each frame.</li>
<li>Delay compoents initialization.（如Skeletal animations）</li>
<li>对象池+隐藏</li>
</ul>
</li>
<li><p>PSO Compliation （Pipeline State Object Compilation，管线状态对象编译）<br><a href="https://www.unrealengine.com/zh-CN/tech-blog/game-engines-and-shader-stuttering-unreal-engines-solution-to-the-problem">游戏引擎与着色器卡顿：虚幻引擎的解决方案</a><br>(DX12,Vulkan and Metal have a new way of dispatching draw calls)</p>
<ul>
<li>Need to include the fully compiled shader code.Need to compiled on the user’s device. Takes time.</li>
<li>PSO Precaching(UE 5.3)</li>
<li>PSO Compliation Strategy</li>
</ul>
</li>
<li><p>Garbage Collection</p>
<ul>
<li>Reduce UObject count<ul>
<li>留意StaticMeshActors、Use WorldPartition</li>
<li>(&lt;50,000) profile.</li>
</ul>
</li>
<li>Change GC Strategy. Manually GC.</li>
<li>Reachablitlity Analysis. Incremental Reachability Analysis.(Experimental)</li>
</ul>
</li>
<li><p>Synchronous Loading<br>“Load Asset Blocking”<br>同步加载,也会影响到异步加载</p>
<ul>
<li>flushes the asynchronous loading queue.</li>
<li>Dont do blocking loads.Use Async versions instead.</li>
</ul>
</li>
<li><p>Blueprint&#x2F;Content<br>“Too much problem”.</p>
<ul>
<li>Do less. Use Fake things, Not Everything need to tick every frame.</li>
<li>LOD HLODs. AI Behaviors,audio,particles,etc</li>
<li>Spread things out.(Beginplay可以Incremental for streamed in levels.)</li>
<li>Unreal Insights工具</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>2025ShangHaiFest</tag>
      </tags>
  </entry>
  <entry>
    <title>UE-PuerTS</title>
    <url>/UE/Script/PuerTS/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>热更新算是现在游戏中非常重要的一部分。虚幻本身使用C++在热更上有很多不便，特别是如果要上移动IOS平台。</p>
<p>目前虚幻引擎的游戏一般使用两种脚本语言，Lua与TypeScript。<br>实际上蓝图也有可以热更的特点，虚幻运行着对应的蓝图虚拟机。<br>但是蓝图在双端逻辑共用，多人协作以及版本管理上有着比较致命的缺点。</p>
<p>关于Lua和Typescript的选择，插件作者有那么一篇文章：<br><a href="https://zhuanlan.zhihu.com/p/195320417">puerts偿还了xLua哪些技术债</a></p>
<h1 id="PuerTS"><a href="#PuerTS" class="headerlink" title="PuerTS"></a>PuerTS</h1><p><a href="https://puerts.github.io/docs/puerts/unreal/install/">官方文档</a></p>
<p>PuerTS的实际应用还是要结合项目来。</p>
<p>初步接触的话，感觉这篇文章介绍的不错：<br><a href="https://zhuanlan.zhihu.com/p/679045148">UE5 从零搭建UE的puerts开发环境</a></p>
<p>下载完对应资源后，在项目Build.cs加入JsEnv模块引用，之后可以在对应GameInstance创建JsEnv环境。</p>
<p>实际学习，要结合官方的Demo来。<br>这里主要有两个Demo:<br>第一个主要通过创建JsEnv环境，并附带了各个基础的用法。<br><a href="https://github.com/chexiongsheng/puerts_unreal_demo/tree/master">puerts_unreal_demo</a><br>第二个主要展示了继承引擎类功能的用法<br><a href="https://github.com/chexiongsheng/BlockBreakerStarter/">BlockBreakerStarter</a></p>
<p>有什么问题，还是要结合源码来。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="C-Ts-JsEnv"><a href="#C-Ts-JsEnv" class="headerlink" title="C++ -&gt; Ts JsEnv"></a>C++ -&gt; Ts JsEnv</h3><p>C++侧创建JsEnv</p>
<ul>
<li>Start 主模块的开始 对应游戏Main的初始化 各个Mgr</li>
<li>TickFunction的绑定 驱动TS层游戏架构的Update</li>
<li>对一些其他重要的Delegate进行绑定</li>
</ul>
<h4 id="SpawnActor"><a href="#SpawnActor" class="headerlink" title="SpawnActor"></a>SpawnActor</h4><p>注意PuerTS中的调用依赖于反射(如果不加静态绑定的话) 不能直接SpawnActor(SpawnActor没有对应的UFUNCTION宏)<br>UE.GameplayStatics.BeginDeferredActorSpawnFromClass  声明了BlueprintInternalUseOnly 具体的可以看看对应的符号说明。<br>UE.GameplayStatics.FinishSpawningAcotr</p>
<p>&#x2F;&#x2F;注意SpawnActor如果指定名称 重名了会奔溃…<br>可以看到LevelActor.cpp 对应500多行的 StaticFindObjectFast</p>
<h4 id="Blueprint"><a href="#Blueprint" class="headerlink" title="Blueprint"></a>Blueprint</h4><p>ts层面的蓝图加载和卸载 load与unload<br>可以看到插件部分的 uelazyload.js中的逻辑代码<br>在C++部分的并没有Unload。这块是TS层维护的。</p>
<p>不过关于C++的Load这块，也可以到UObjectGlobals.cpp去看看</p>
<p>枚举这部分目前看是不需要再Load和Unload了，可以直接用</p>
<h3 id="蓝图Mixin"><a href="#蓝图Mixin" class="headerlink" title="蓝图Mixin"></a>蓝图Mixin</h3><p>蓝图类 进行蓝图Mixin 重定向蓝图的函数。<br>TS类的方法替代蓝图的方法。也是可以看到uelazyload的mixin。<br>JsEnvImpl.cpp Mixin<br>UJSGeneratedClass::Mixin<br>Class的AddNativeFunction。<br>进行了重定向。因为这里改的其实是蓝图 重定向后 即便是用原来蓝图类生成的Actor 其Function也会重定向到新的Function。<br>这里和MixIn的时序还有关系。在执行到Ts MixIn前还是原Fun 执行后就是新Fun。<br>原理还是比较清晰的。可以看到源码。</p>
<h3 id="继承引擎类"><a href="#继承引擎类" class="headerlink" title="继承引擎类"></a>继承引擎类</h3><p>由C++来驱动TS。</p>
<h2 id="GC相关"><a href="#GC相关" class="headerlink" title="GC相关"></a>GC相关</h2><p>可以看看FAQ。注意持有关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一般还是stub持有ue对象。</span><br><span class="line"></span><br><span class="line">“ue对象持有stub对象”，在ts持有并不能阻止ue的gc，有三种情况会产生这种类型的对象：</span><br><span class="line">- ts继承ue类型</span><br><span class="line">- mixin中参数指明objectTakeByNative</span><br><span class="line">- makeUClass（这功能已经废弃，不建议使用）</span><br><span class="line"></span><br><span class="line">但即使改对象不会被gc释放，依然不能保证一个ue对象不被销毁，ue下可以调用api强制删除一个对象（可能是用户自己调用，也可能是引擎调用，比较常见是切场景后，所有该场景挂的actor都会自动销毁）。</span><br></pre></td></tr></table></figure>

<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>在前文也提到了，要结合项目来。<br>这里看了几个issues 也挺有启发的吧。<br><a href="https://github.com/Tencent/puerts/issues/1781">https://github.com/Tencent/puerts/issues/1781</a><br><a href="https://github.com/Tencent/puerts/issues/745">https://github.com/Tencent/puerts/issues/745</a><br>插件作者其实还是比较强调尽量避免使用继承引擎类方式。</p>
<p>如果项目本身框架比较好，主要由TS层来驱动业务逻辑，那么利用好JsEnv的创建以及必要的Delegates绑定应该能实现大部分需求了。大部分场景应当是TS业务来驱动引擎业务。</p>
<p>如果涉及到需要由C++来调用TS的场景，蓝图Mixin其实也提供了很强大的功能。</p>
<p>不过，最终还是得结合项目来。包括开发流程和团队经验等各种因素吧。</p>
<h2 id="其他参考文章"><a href="#其他参考文章" class="headerlink" title="其他参考文章"></a>其他参考文章</h2><p><a href="https://www.bilibili.com/video/BV1vW4y117Kh/?spm_id_from=333.337.search-card.all.click&vd_source=71e3a2be4d607905747242edebec9203">[UnrealCircle]鸣潮——TypeScript、PuerTS、V8优化实践 | 库洛游戏 王宏波</a><br>这个视频还是非常值得一看的。<br>包括V8内部的一些逻辑，需要注意的内存GC问题，开发经验和已有优化策略。</p>
<p>当然，时间比较久了，PuerTS本身也有做优化(如LoadModule那部分)</p>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>PuerTS</tag>
      </tags>
  </entry>
  <entry>
    <title>UE - 官方文档学习</title>
    <url>/UE/OfficialDocLearn/UESummary/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>虚幻引擎并不是一个“轻量”的引擎。而在游戏的制作过程中，所设计到的知识是方方面面的。自己在行业中学习，越做游戏，了解的知识越多，越深知自己要学习的东西还有很多。</p>
<p>作为前端开发人员，或者游戏从业者，多了解相关的知识也不是坏事，而不是局限于自己所负责的业务。</p>
<p>当然，很多时候，技术只是达成目的的手段，但多广泛了解一下各个技术也不是什么坏事。每个方面的知识都可以很深，在学习，了解的时候，可以浅尝辄止，有个大概的概念，选取一两个重点去学习，其他的用到的时候再深入。</p>
<p>这篇主要用作个人官方文档笔记的导航页和梳理页。</p>
<p>部分基于有道云笔记的图片，会加上记录的文本内容用于索引。</p>
<h1 id="物理"><a href="#物理" class="headerlink" title="物理"></a>物理</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><a href="/UE/OfficialDocLearn/Physcis/PhyscisTotal/" title="UE - Physcis总览">物理总览</a>

<h2 id="网络复制"><a href="#网络复制" class="headerlink" title="网络复制"></a>网络复制</h2><a href="/UE/OfficialDocLearn/Physcis/PhyscisNetwork/" title="UE - PhyscisNetworkReplication">网络复制</a>

<h2 id="碰撞"><a href="#碰撞" class="headerlink" title="碰撞"></a>碰撞</h2><a href="/UE/OfficialDocLearn/Physcis/PhyscisCollision/" title="UE - PhyscisCollision">碰撞</a>

<h1 id="GameplayFramework"><a href="#GameplayFramework" class="headerlink" title="GameplayFramework"></a>GameplayFramework</h1><a href="/UE/OfficialDocLearn/GameplayFramework/" title="UE - GameplayFramework">GameplayFramework</a>

<h1 id="关卡"><a href="#关卡" class="headerlink" title="关卡"></a>关卡</h1><h2 id="Level"><a href="#Level" class="headerlink" title="Level"></a>Level</h2><a href="/UE/OfficialDocLearn/Levels/Level/" title="UE - Level">Level</a>

<h2 id="WorldPartition"><a href="#WorldPartition" class="headerlink" title="WorldPartition"></a>WorldPartition</h2><a href="/UE/OfficialDocLearn/Levels/WorldPartition/" title="UE - WorldPartition">WorldPartition</a>

<h2 id="LevelInstancing"><a href="#LevelInstancing" class="headerlink" title="LevelInstancing"></a>LevelInstancing</h2><a href="/UE/OfficialDocLearn/Levels/LevelInstancing/" title="UE - LevelInstancing">LevelInstancing</a>

<h1 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h1><h2 id="行为树"><a href="#行为树" class="headerlink" title="行为树"></a>行为树</h2><a href="/UE/OfficialDocLearn/AI/BehaviorTree/" title="UE-BehaviorTree">UE BehaviorTree</a>

<h2 id="状态树"><a href="#状态树" class="headerlink" title="状态树"></a>状态树</h2><a href="/UE/OfficialDocLearn/AI/StateTree/" title="UE-StateTree">UE StateTree</a>

<h1 id="C-Coding"><a href="#C-Coding" class="headerlink" title="C++ Coding"></a>C++ Coding</h1><h2 id="Reflection-System"><a href="#Reflection-System" class="headerlink" title="Reflection System"></a>Reflection System</h2><a href="/UE/OfficialDocLearn/Coding/UECPlusPlusReflection/" title="UE-Reflection System">UE C++ ReflectionSystem</a>

<h2 id="UObject"><a href="#UObject" class="headerlink" title="UObject"></a>UObject</h2><h3 id="UObject总体概述"><a href="#UObject总体概述" class="headerlink" title="UObject总体概述"></a>UObject总体概述</h3><a href="/UE/OfficialDocLearn/Coding/UObject/" title="UE-UObject">UObject</a>

<h3 id="UObject创建"><a href="#UObject创建" class="headerlink" title="UObject创建"></a>UObject创建</h3><a href="/UE/OfficialDocLearn/Coding/UObjectCreation/" title="UE-UObjectCreation">UObjectCreation</a>

<h3 id="Package与Outer"><a href="#Package与Outer" class="headerlink" title="Package与Outer"></a>Package与Outer</h3><a href="/UE/OfficialDocLearn/Coding/Package/" title="UE-Package">Package与Outer</a>

<h2 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h2><a href="/UE/OfficialDocLearn/Coding/UProperty/" title="UE-Property">Property</a>

<h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><a href="/UE/OfficialDocLearn/Coding/UInterface/" title="UE-UInterface">UInterface</a>

<h2 id="SmartPointers"><a href="#SmartPointers" class="headerlink" title="SmartPointers"></a>SmartPointers</h2><a href="/UE/OfficialDocLearn/Coding/SmartPointers/" title="UE-SmartPointers">SmartPointers</a>

<h2 id="CodingStandard-代码规范"><a href="#CodingStandard-代码规范" class="headerlink" title="CodingStandard 代码规范"></a>CodingStandard 代码规范</h2><a href="/UE/OfficialDocLearn/Coding/CodingStandard/" title="UE-Coding Standard">CodingStandard 代码规范</a>

<h2 id="Asserts-断言"><a href="#Asserts-断言" class="headerlink" title="Asserts 断言"></a>Asserts 断言</h2><a href="/UE/OfficialDocLearn/Coding/Asserts/" title="UE-Asserts">Asserts 断言</a>

<h2 id="GameplayTag"><a href="#GameplayTag" class="headerlink" title="GameplayTag"></a>GameplayTag</h2><a href="/UE/OfficialDocLearn/Coding/GameplayTag/" title="UE-GameplayTag">GameplayTag</a>

<h2 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h2><a href="/UE/OfficialDocLearn/Coding/Log/" title="UE-Log">Log</a>

<h2 id="Delegates"><a href="#Delegates" class="headerlink" title="Delegates"></a>Delegates</h2><a href="/UE/OfficialDocLearn/Coding/Delegates/" title="UE-Delegates">Delegates</a>

<h2 id="Tick"><a href="#Tick" class="headerlink" title="Tick"></a>Tick</h2><a href="/UE/OfficialDocLearn/Coding/Tick/" title="UE-Tick">Tick</a>

<h2 id="ActorLifeTime"><a href="#ActorLifeTime" class="headerlink" title="ActorLifeTime"></a>ActorLifeTime</h2><a href="/UE/OfficialDocLearn/Coding/ActorLifeTime/" title="UE-ActorLifeTime">ActorLifeTime</a>

<h1 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h1><p>非常推荐大钊的这篇文章，在学习过程中能帮到很多。<br><a href="https://zhuanlan.zhihu.com/p/717920216">UE5标识符详解 | 史上最全</a></p>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
      </tags>
  </entry>
  <entry>
    <title>UE-BehaviorTree</title>
    <url>/UE/OfficialDocLearn/AI/BehaviorTree/</url>
    <content><![CDATA[<h1 id="UE-BehaviorTree"><a href="#UE-BehaviorTree" class="headerlink" title="UE BehaviorTree"></a>UE BehaviorTree</h1><p>虚幻的行为树</p>
<p>Character,AIController,BehaviorTree(BT),BlackBoard(BB) 组合在一起实现对应的逻辑。</p>
<p>行为树这块之前有所了解 就不再一点一点赘述了。</p>
<h2 id="BlackBoard"><a href="#BlackBoard" class="headerlink" title="BlackBoard"></a>BlackBoard</h2><p>BB - 存储行为树相关的数据 -&gt; 决定行为树的Key</p>
<img src="/UE/OfficialDocLearn/AI/BehaviorTree/image.png" class="" title="alt text">

<h2 id="Composites"><a href="#Composites" class="headerlink" title="Composites"></a>Composites</h2><p>合成器Composites</p>
<img src="/UE/OfficialDocLearn/AI/BehaviorTree/image-1.png" class="" title="alt text">

<ul>
<li>Selector 优先选择</li>
<li>Sequence 顺序</li>
<li>Simple Parallel 平行执行 【逻辑异步 但是具体执行还是同步的。】<br>注意Finish Mode。如果是Immediate，并且主任务立即完成，那么对应的次要任务实际上不会执行。<br>可以附加对应的Decorator和Service。</li>
</ul>
<h2 id="Decorator-Service"><a href="#Decorator-Service" class="headerlink" title="Decorator &amp;&amp; Service"></a>Decorator &amp;&amp; Service</h2><img src="/UE/OfficialDocLearn/AI/BehaviorTree/image-2.png" class="" title="alt text">

<h3 id="Decorator"><a href="#Decorator" class="headerlink" title="Decorator"></a>Decorator</h3><p>条件判定 Decorator<br>可以附加到Composite与Task上。虚幻本身有实现了一些对应的装饰器，可以看到这里：<br><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/unreal-engine-behavior-tree-node-reference-decorators">Behavior Tree Node Reference: Decorators</a></p>
<p>自定义的时候，可以通过重写PerformConditionCheck&#x2F;PerformConditionCheckAI函数。</p>
<p>没看到的话在Window-&gt;My Blueprint可以打开对应的窗口并override。</p>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>并行节点 Parallel -&gt; Service</p>
<img src="/UE/OfficialDocLearn/AI/BehaviorTree/image-3.png" class="" title="alt text">

<h2 id="重要特性"><a href="#重要特性" class="headerlink" title="重要特性"></a>重要特性</h2><h3 id="Event-Driven"><a href="#Event-Driven" class="headerlink" title="Event Driven"></a>Event Driven</h3><img src="/UE/OfficialDocLearn/AI/BehaviorTree/image-4.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/AI/BehaviorTree/image-5.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/AI/BehaviorTree/image-6.png" class="" title="alt text">

<h3 id="Conditionals-Decorators"><a href="#Conditionals-Decorators" class="headerlink" title="Conditionals - Decorators"></a>Conditionals - Decorators</h3><img src="/UE/OfficialDocLearn/AI/BehaviorTree/image-7.png" class="" title="alt text">
<p>这块到没有太多需要注意的，</p>
<h3 id="Concurrent-Behaviors"><a href="#Concurrent-Behaviors" class="headerlink" title="Concurrent Behaviors"></a>Concurrent Behaviors</h3><p>并发行为</p>
<img src="/UE/OfficialDocLearn/AI/BehaviorTree/image-8.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/AI/BehaviorTree/image-9.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/AI/BehaviorTree/image-10.png" class="" title="alt text">
<p>这里需要注意Server的执行时序问题。可以看看下面的知乎参考文章。或者自己写测试用例测测。<br>比如一个有装饰器和服务的任务节点：</p>
<img src="/UE/OfficialDocLearn/AI/BehaviorTree/image-11.png" class="" title="alt text">

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>关于特性这部分可以看看这篇文章<br><a href="https://zhuanlan.zhihu.com/p/139514376">浅析UE4-BehaviorTree的特性</a><br>重点还是Event Driven。<br>虚幻引擎的行为树，在任务节点需要有着Finish Execute的逻辑。这也意味着可以在某些节点执行异步任务，待异步任务完成后，再完成。而这个时候，在节点完成之前，整棵树其实就“停留”在对应的节点了。<br>而这个时候，打断对应的Running状态就比较重要了。而对应的事件注册，可以在一定条件触发并执行打断逻辑。从而由事件驱动。</p>
<h2 id="节点应用"><a href="#节点应用" class="headerlink" title="节点应用"></a>节点应用</h2><p>注意逻辑和数据分离。一般行为树只有单个实例并共用，用BB来进行数据分离。虚幻也支持行为树的节点单独实例化。可以看到官方文档:<br><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/behavior-tree-node-reference-in-unreal-engine">Behavior Tree Node Reference</a></p>
<h1 id="其他思考"><a href="#其他思考" class="headerlink" title="其他思考"></a>其他思考</h1><p>实际项目往往还要考虑后端的运行情况。<br>后端不跑虚幻的DS的话 估计还是得抽一套脚本语言的实现方案，确保前后端一致。<br>不然就得前后端单独实现一套了。这样的话开发和维护成本还是比较大的。<br>相关的工具可以去看看Brainiac Designer。</p>
<p>之前项目有用过由Brainiac Designer作为行为树的预览和编辑工具，最终生成对应的TS代码来执行。当然，对应的行为树运行时观察工具，就得自己手搓了。</p>
<h2 id="源码部分"><a href="#源码部分" class="headerlink" title="源码部分:"></a>源码部分:</h2><p>AIController</p>
<p>BehaviorTreeManager</p>
<p>BrainComponent</p>
<p>BehaviorTree<br>Root节点，以及UBTCompositeNode的相关逻辑</p>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>UE</tag>
        <tag>BehaviorTree</tag>
      </tags>
  </entry>
  <entry>
    <title>UE5.5-GameplayPrediction</title>
    <url>/UE/GAS/UE55GamplayPrediction/</url>
    <content><![CDATA[<h1 id="SourceCode源码"><a href="#SourceCode源码" class="headerlink" title="SourceCode源码"></a><a href="https://github.com/MikeMing126/UESourceCode/blob/main/UE55_GAS_GameplayPrediction.h">SourceCode源码</a></h1><h1 id="Overview-of-Gameplay-Ability-Prediction"><a href="#Overview-of-Gameplay-Ability-Prediction" class="headerlink" title="Overview of Gameplay Ability Prediction"></a>Overview of Gameplay Ability Prediction</h1><h2 id="High-Level-Goals"><a href="#High-Level-Goals" class="headerlink" title="High Level Goals"></a>High Level Goals</h2><ul>
<li>At the GameplayAbility level (implementing an ability) prediction is transparent. An ability says “Do X-&gt;Y-&gt;Z”, and we will automatically predict the parts of that that we can.</li>
<li>We wish to avoid having logic such as “If Authority: Do X. Else: Do predictive version of X” in the ability itself.</li>
</ul>
<p>At this point, not all cases are solved, but we have a very solid framework for working with client side prediction.</p>
<p>When we say “client side prediction” we really mean client predicting game simulation state. Things can still be ‘completely client side’ without having to work within a prediction system.<br>For example, footsteps are completely client side and never interact with this system. But clients predicting their mana going from 100 to 90 when they cast a spell is ‘client side prediction’.</p>
<h2 id="What-do-we-currently-predict"><a href="#What-do-we-currently-predict" class="headerlink" title="What do we currently predict?"></a>What do we currently predict?</h2><ul>
<li>Initial GameplayAbility activation (and chained activation with caveats)</li>
<li>Triggered Events</li>
<li>GameplayEffect application:<ul>
<li>Attribute modification (EXCEPTIONS: Executions do not currently predict, only attribute modifiers)</li>
<li>GameplayTag modification</li>
</ul>
</li>
<li>Gameplay Cue events (both from within predictive gameplay effect and on their own)</li>
<li>Montages</li>
<li>Movement (built into UE UCharacterMovement)</li>
</ul>
<h2 id="Some-things-we-don’t-predict-most-of-these-we-potentially-could-but-currently-dont"><a href="#Some-things-we-don’t-predict-most-of-these-we-potentially-could-but-currently-dont" class="headerlink" title="Some things we don’t predict (most of these we potentially could, but currently dont):"></a>Some things we don’t predict (most of these we potentially could, but currently dont):</h2><ul>
<li>GameplayEffect removal</li>
<li>GameplayEffect periodic effects (dots ticking)</li>
</ul>
<h2 id="Problems-we-attempt-to-solve"><a href="#Problems-we-attempt-to-solve" class="headerlink" title="Problems we attempt to solve"></a>Problems we attempt to solve</h2><ol>
<li>“Can I do this?” Basic protocol for prediction.</li>
<li>“Undo” How to undo side effects when a prediction fails.</li>
<li>“Redo” How to avoid replaying side effects that we predicted locally but that also get replicated from the server.</li>
<li>“Completeness” How to be sure we &#x2F;really&#x2F; predicted all side effects.</li>
<li>“Dependencies” How to manage dependent prediction and chains of predicted events.</li>
<li>“Override” How to override state predictively that is otherwise replicated&#x2F;owned by the server.</li>
</ol>
<hr>
<h2 id="Implementation-Details"><a href="#Implementation-Details" class="headerlink" title="Implementation Details"></a>Implementation Details</h2><h3 id="​​-PredictionKey-​"><a href="#​​-PredictionKey-​" class="headerlink" title="​​ PredictionKey ​"></a>​<em><strong>​ PredictionKey ​</strong></em></h3><p>A fundamental concept in this system is the <code>FPredictionKey</code>. A prediction key on its own is simply a unique ID that is generated in a central place on the client. The client will send its prediction key to the server,<br>and associate predictive actions and side effects with this key. The server may respond with an accept&#x2F;reject for the prediction key, and will also associate the server-side created side effects with this prediction key.</p>
<p>(IMPORTANT) <code>FPredictionKey</code> always replicates client -&gt; server, but when replicating server -&gt; clients they <em>only</em> replicate to the client that sent the prediction key to the server in the first place.<br>This happens in <code>FPredictionKey::NetSerialize</code>. All other clients will receive an invalid (0) prediction key when a prediction key sent from a client is replicated back down through a replicated property.</p>
<hr>
<h3 id="​​-Ability-Activation-​"><a href="#​​-Ability-Activation-​" class="headerlink" title="​​ Ability Activation ​"></a>​<em><strong>​ Ability Activation ​</strong></em></h3><p>Ability Activation is a first class predictive action – it generates an initial prediction key. Whenever a client predictively activates an ability, it explicitly asks the server and the server explicitly responds. Once an ability has been<br>predictively activated (but the request has not yet been sent), the client has a valid ‘prediction window’ where predictive side effects can happen which are not explicitly ‘asked about’. (E.g., we do not explicitly ask ‘Can I decrement mana, Can I put this ability on cooldown. Those actions are considered logically atomic with activating an ability). You can think of this prediction window as being the initial callstack of <code>ActivateAbility</code>. Once <code>ActivateAbility</code> ends, your<br>prediction window (and therefore your prediction key) is no longer valid. This is important, because many things can invalidate your prediction window such as any timers or latent nodes in your Blueprint; we do not predict over multiple frames.</p>
<p><strong>AbilitySystemComponent</strong>​ provides a set of functions for communicating ability activation between clients and server: <code>TryActivateAbility</code> -&gt; <code>ServerTryActivateAbility</code> -&gt; <code>ClientActivateAbility(Failed/Succeed)</code>.</p>
<ol>
<li>Client calls <code>TryActivateAbility</code> which generates a new <code>FPredictionKey</code> and calls <code>ServerTryActivateAbility</code>.</li>
<li>Client continues (before hearing back from server) and calls <code>ActivateAbility</code> with the generated <code>PredictionKey</code> associated with the Ability’s <code>ActivationInfo</code>.</li>
<li>Any side effects that happen &#x2F;before the call to <code>ActivateAbility</code> finish&#x2F; have the generated <code>FPredictionKey</code> associated with them.</li>
<li>Server decides if the ability really happened in <code>ServerTryActivateAbility</code>, calls <code>ClientActivateAbility(Failed/Succeed)</code> and sets <code>UAbilitySystemComponent::ReplicatedPredictionKey</code> to the generated key that was sent with the request by the client.</li>
<li>If client receives <code>ClientAbilityFailed</code>, it immediately kills the ability and rolls back side effects that were associated with the prediction key.<ul>
<li>‘Rolling back’ logic is registered via <code>FPredictionKeyDelegates</code> and <code>FPredictionKey::NewRejectedDelegate/NewCaughtUpDelegate/NewRejectOrCaughtUpDelegate</code>.</li>
<li><code>ClientAbilityFailed</code> is really the only case where we ‘reject’ prediction keys and thus all of our current predictions rely on if an ability activates or not.</li>
</ul>
</li>
<li>If <code>ServerTryActivateAbility</code> succeeds, client must wait until property replication catches up (the Succeed RPC will be sent immediately, property replication will happen on its own). Once the <code>ReplicatedPredictionKey</code> catches up to the<br>key used previous steps, the client can undo its predictive side effects.<ul>
<li>See <code>FReplicatedPredictionKeyItem::OnRep</code> for the CatchUpTo logic. See <code>UAbilitySystemComponent::ReplicatedPredictionKeyMap</code> for how the keys actually get replicated. See ~&#96;FScopedPredictionWindow&#96; where the server acknowledges keys.</li>
</ul>
</li>
</ol>
<hr>
<h3 id="​​-GameplayEffect-Prediction-​"><a href="#​​-GameplayEffect-Prediction-​" class="headerlink" title="​​ GameplayEffect Prediction ​"></a>​<em><strong>​ GameplayEffect Prediction ​</strong></em></h3><p>GameplayEffects are considered side effects of ability activation and are not separately accepted&#x2F;rejected.</p>
<ol>
<li>GameplayEffects are only applied on clients if there is a valid prediction key. (If no prediction key, it simply skips the application on client).</li>
<li>Attributes, GameplayCues, and GameplayTags are all predicted if the GameplayEffect is predicted.</li>
<li>When the <code>FActiveGameplayEffect</code> is created, it stores the prediction key (<code>FActiveGameplayEffect::PredictionKey</code>)<ul>
<li>Instant effects are explained below in “Attribute Prediction”.</li>
</ul>
</li>
<li>On the server, the same prediction key is also set on the server’s <code>FActiveGameplayEffect</code> that will be replicated down.</li>
<li>As a client, if you get a replicated <code>FActiveGameplayEffect</code> with a valid prediction key on it, you check to see if you have an <code>ActiveGameplayEffect</code> with that same key, if there is match, we do not apply<br>the ‘on applied’ type of logic, e.g., GameplayCues. The solves the “Redo” problem. However we will have 2 of the ‘same’ GameplayEffects in our ActiveGameplayEffects container, temporarily:</li>
<li>At the same time, <code>FReplicatedPredictionKeyItem::OnRep</code> will catch up and the predictive effects will be removed. When they are removed in this case, we again check <code>PredictionKey</code> and decide<br>if we should not do the ‘On Remove’ logic &#x2F; GameplayCue.</li>
</ol>
<p>See <code>FActiveGameplayEffectsContainer::ApplyGameplayEffectSpec</code> where it registers what to do when caught-up (RemoveActiveGameplayEffect_NoReturn).<br>See <code>FActiveGameplayEffect::PostReplicatedAdd</code>, <code>FActiveGameplayEffect::PreReplicatedRemove</code>, and <code>FActiveGameplayCue::PostReplicatedAdd</code> for examples of how <code>FPredictionKey</code> is associated with the GE’s and GC’s.</p>
<hr>
<h3 id="​​-Attribute-Prediction-​"><a href="#​​-Attribute-Prediction-​" class="headerlink" title="​​ Attribute Prediction ​"></a>​<em><strong>​ Attribute Prediction ​</strong></em></h3><p>Since attributes are replicated as standard uproperties, predicting modification to them can be tricky (“Override” problem). Instantaneous modification can be even harder since these are non stateful by nature.<br>(E.g., rolling back an attribute mod is difficult if there is no book keeping past the modification). This makes the “Undo” and “Redo” problem also hard in this case.</p>
<p>The basic plan of attack is to treat attribute prediction as delta prediction rather than absolute value prediction. We do not predict that we have 90 mana, we predict that we have -10 mana from the server value, until<br>the server confirms our prediction key. Basically, treat instant modifications as &#x2F;infinite duration modifications&#x2F; to attributes while they are done predictively. The solves “Undo” and “Redo”.</p>
<p>For the “override” problem, we can handle this in the properties <code>OnRep</code> by treating the replicated (server) value as the ‘base value’ instead of ‘final value’ of the attribute, and to<br>reaggregate our ‘final value’ after a replication happens.</p>
<h4 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMyHealthSet::GetLifetimeReplicatedProps</span><span class="params">(TArray&lt; FLifetimeProperty &gt; &amp; OutLifetimeProps)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">DOREPLIFETIME_CONDITION_NOTIFY</span>(UMyHealthSet, Health, COND_None, REPNOTIFY_Always);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Gameplay-Cue-Events"><a href="#Gameplay-Cue-Events" class="headerlink" title="Gameplay Cue Events"></a>Gameplay Cue Events</h1><p>Outside of GameplayEffects which are already explained, Gameplay Cues can be activated on their own. These functions (<code>UAbilitySystemComponent::ExecuteGameplayCue</code> etc) take network role and prediction keys into account.</p>
<p>In <code>UAbilitySystemComponent::ExecuteGameplayCue</code>, if authority then do the multicast event (with replication key). If non authority but w&#x2F; a valid prediction key, predict the GameplayCue.<br>On the receiving end (<code>NetMulticast_InvokeGameplayCueExecuted</code> etc), if there is a replication key, then don’t do the event (assume you predicted it).<br>Remember that <code>FPredictionKeys</code> only replicate to the originating owner. This is an intrinsic property of <code>FReplicationKey</code>.</p>
<hr>
<h1 id="Triggered-Data-Prediction"><a href="#Triggered-Data-Prediction" class="headerlink" title="Triggered Data Prediction"></a>Triggered Data Prediction</h1><p>Triggered Data is currently used to activate abilities. Essentially this all goes through the same code path as ActivateAbility. Rather than the ability being activated from input press, it is activated from<br>another game code driven event. Clients are able to predictively execute these events which predictively activate abilities.</p>
<p>There are some nuances to how, since the server will also run the code that triggers events. The server won’t just wait to hear from the client. The server will keep a list of triggered abilities that have been<br>activated from a predictive ability. When receiving a <code>TryActivate</code> from a triggered ability, the server will look to see if &#x2F;it&#x2F; has already run this ability, and respond with that information.</p>
<p>The issue is we do not properly rollback these operations. There is work left to do on Triggered Events and replication. (explained at the end).</p>
<hr>
<h2 id="Advanced-topic-Dependencies"><a href="#Advanced-topic-Dependencies" class="headerlink" title="Advanced topic! Dependencies"></a>Advanced topic! Dependencies</h2><p>We can have situations such as “Ability X activates and immediately triggers an event which activates Ability Y which triggers another Ability Z”. The dependency chain is X-&gt;Y-&gt;Z.<br>Each of those abilities could be rejected by the server. If Y is rejected, then Z also never happened, but the server does not explicitly decide ‘no Z can’t run’.<br>To handle this, we have a concept of a Base PredictionKey, which is a member of <code>FPredictionKey</code>. When calling <code>TryActivateAbility</code>, we pass in the current PredictionKey (if applicable). That prediction key<br>is used as the base for any new prediction keys generated. We build a chain of keys this way, and can then invalidate Z if Y is rejected.</p>
<p>This is slightly more nuanced though. In the X-&gt;Y-&gt;Z case, the server will only receive the PredictionKey for X before trying to run the chain itself. E.g., it will TryActivate Y and Z with the original prediction key<br>sent to it from the client, whereas the client will generate a new PredictionKey each time it calls <code>TryActivateAbility</code>. The client has to generate a new PredictionKey for each ability activate, since each activate<br>is not logically atomic. Each side effect produced in the chain of events has to have a unique PredictionKey. We cannot have GameplayEffects produced in X have the same PredictionKey produced in Z.</p>
<p>To get around this, The prediction key of X is considered the Base key for Y and Z. The dependency from Y to Z is kept completely client side, which is done in by <code>FPredictionKeyDelegates::AddDependency</code>. We add delegates<br>to reject&#x2F;catchup Z if Y rejected&#x2F;confirmed.</p>
<p>This dependency system allows us to have multiple predictive actions that are not logically atomic within a single prediction window&#x2F;scope.</p>
<p>There is a problem though: because the dependencies are kept client side, the server does not actually know if it had previously rejected a dependent action. You can design around this issue by using activation tags<br>in your gameplay abilities. For instance, when predicting dependents GA_Combo1 -&gt; GA_Combo2, you could make GA_Combo2 only activate if it has a GameplayTag given by GA_Combo1. Thus a rejection of GA_Combo1 would also<br>cause the server to reject the activation of GA_Combo2.</p>
<hr>
<h1 id="Additional-Prediction-Windows-within-an-Ability"><a href="#Additional-Prediction-Windows-within-an-Ability" class="headerlink" title="Additional Prediction Windows (within an Ability)"></a>Additional Prediction Windows (within an Ability)</h1><p>As stated, A prediction key is only usable during a single logical scope. Once <code>ActivateAbility</code> returns, we are essentially done with that key. If the ability is waiting on an external event or timer, it’s possible<br>we will have already received a confirm&#x2F;reject from the server by the time we’re ready to continue execution. Thus any additional side effects produced after the initial activation can no longer be tied to the lifespan of the original key.</p>
<p>This isn’t that bad, except that abilities will sometimes want to react to player input. For example, ‘a hold down and charge’ ability wants to instantly predict some stuff when the button is released. It is possible<br>to create a new prediction window within an ability with <code>FScopedPredictionWindow</code>.</p>
<p><strong>FScopedPredictionWindows</strong>​ provides a way to send the server a new prediction key and have the server pick up and use that key within the same logical scope.</p>
<p><code>UAbilityTask_WaitInputRelease::OnReleaseCallback</code> is a good example. The flow of events is as followed:</p>
<ol>
<li>Client enters <code>UAbilityTask_WaitInputRelease::OnReleaseCallback</code> and starts a new <code>FScopedPredictionWindow</code>. This creates a new prediction key for this scope (<code>FScopedPredictionWindow::ScopedPredictionKey</code>).</li>
<li>Client calls <code>AbilitySystemComponent-&gt;ServerInputRelease</code> which passes <code>ScopedPrediction.ScopedPredictionKey</code> as a parameter.</li>
<li>Server runs <code>ServerInputRelease_Implementation</code> which takes the passed in PredictionKey and sets it as <code>UAbilitySystemComponent::ScopedPredictionKey</code> with an <code>FScopedPredictionWindow</code>.</li>
<li>Server runs <code>UAbilityTask_WaitInputRelease::OnReleaseCallback</code> &#x2F;within the same scope&#x2F;</li>
<li>When the server hits the <code>FScopedPredictionWindow</code> in ::OnReleaseCallback, it gets the prediction key from <code>UAbilitySystemComponent::ScopedPredictionKey</code>. That is now used for all side effects within this logical scope.</li>
<li>Once the server ends this scoped prediction window, the prediction key used is finished and set to <code>ReplicatedPredictionKey</code>.</li>
<li>All side effects created in this scope now share a key between client and server.</li>
</ol>
<p>The key to this working is that ::OnReleaseCallback calls ::ServerInputRelease which calls ::OnReleaseCallback on the server. There is no room for anything else to happen and use the given prediction key.</p>
<p>While there is no “Try&#x2F;Failed&#x2F;Succeed” calls in this example, all side effects are procedurally grouped&#x2F;atomic. This solves the “Undo” and “Redo” problems for any arbitrary function calls that run on the server and client.</p>
<hr>
<h1 id="Unsupported-Issues-Todo"><a href="#Unsupported-Issues-Todo" class="headerlink" title="Unsupported &#x2F; Issues&#x2F; Todo"></a>Unsupported &#x2F; Issues&#x2F; Todo</h1><h3 id="Triggered-events-do-not-explicitly-replicate"><a href="#Triggered-events-do-not-explicitly-replicate" class="headerlink" title="Triggered events do not explicitly replicate"></a>Triggered events do not explicitly replicate</h3><ul>
<li>E.g., if a triggered event only runs on the server, the client will never hear about it. This also prevents us from doing cross player&#x2F;AI etc events. Support<br>for this should eventually be added and it should follow the same pattern that GameplayEffect and GameplayCues follow (predict triggered event with a prediction key, ignore the RPC event if it has a prediction key).</li>
</ul>
<p>Big caveat with this whole system: Rollback of any chained activations (including triggered events) is currently not possible out of the box. The reason for this is because each ServerTryActivateAbility is going to be responded to in order.<br>Let’s chain dependent GA’s as an example: GA_Mispredict -&gt; GA_Predict1. In this example, when GA_Mispredict is activated and predicted locally it will immediately also activate GA_Predict1. The client sends ServerTryActivateAbility for GA_Mispredict,<br>and the server rejects it (sending back a ClientActivateAbilityFailed). As it stands, we don’t have any delegates that reject dependent abilities on the client (and the server isn’t even aware there are dependencies). On the server, it also<br>receives a ServerTryActivateAbility for GA_Predict1. Assuming that succeeds, the Client and Server are now both executing GA_Predict1 even though GA_Mispredict never happened. You can design around this by using the tag system to ensure GA_Mispredict succeeded.</p>
<hr>
<h3 id="Predicting-“Meta”-Attributes-such-as-Damage-Healing-vs-“real”-attributes-such-as-Health"><a href="#Predicting-“Meta”-Attributes-such-as-Damage-Healing-vs-“real”-attributes-such-as-Health" class="headerlink" title="Predicting “Meta” Attributes such as Damage&#x2F;Healing vs “real” attributes such as Health"></a>Predicting “Meta” Attributes such as Damage&#x2F;Healing vs “real” attributes such as Health</h3><p>We are unable to apply meta attributes predictively. Meta attributes only work on instant effects, in the back end of GameplayEffect (Pre&#x2F;Post Modify Attribute on the UAttributeSet). These events are not called when<br>applying duration-based gameplay effects. E.g., a GameplayEffect that modifies damage for 5 seconds doesn’t make sense.</p>
<p>In order to support this, we would probably add some limited support for duration based meta attributes, and move the transform of the instant gameplay effect from the front end (<code>UAbilitySystemComponent::ApplyGameplayEffectSpecToSelf</code>)<br>to the backend (<code>UAttributeSet::PostModifyAttribute</code>).</p>
<hr>
<h3 id="Predicting-ongoing-multiplicative-GameplayEffects"><a href="#Predicting-ongoing-multiplicative-GameplayEffects" class="headerlink" title="Predicting ongoing multiplicative GameplayEffects"></a>Predicting ongoing multiplicative GameplayEffects</h3><p>There are also limitations when predicting % based gameplay effects. Since the server replicates down the ‘final value’ of an attribute, but not the entire aggregator chain of what is modifying it, we may run into cases where<br>the client cannot accurately predict new gameplay effects.</p>
<p>For example:</p>
<ul>
<li>Client has a perm +10% movement speed buff with base movement speed of 500 -&gt; 550 is the final movement speed for this client.</li>
<li>Client has an ability which grants an additional 10% movement speed buff. It is expected to <em>sum</em> the % based multipliers for a final 20% bonus to 500 -&gt; 600 movement speed.</li>
<li>However on the client, we just apply a 10% buff to 550 -&gt; 605.</li>
</ul>
<p>This will need to be fixed by replicating down the aggregator chain for attributes. We already replicate some of this data, but not the full modifier list. We will need to look into supporting this eventually.</p>
<hr>
<h3 id="“Weak-Prediction”"><a href="#“Weak-Prediction”" class="headerlink" title="“Weak Prediction”"></a>“Weak Prediction”</h3><p>We will probably still have cases that do not fit well into this system. Some situations will exist where a prediction key exchange is not feasible. For example, an ability where any one that player collides with&#x2F;touches<br>receives a GameplayEffect that slows them and their material blue. Since we can’t send Server RPCs every time this happens (and the server couldn’t necessarily handle the message at its point in the simulation), there is no<br>way to correlate the gameplay effect side effects between client and server.</p>
<p>One approach here may be to think about a weaker form of prediction. One where there is not a fresh prediction key used and instead the server assumes the client will predict all side effects from an entire ability. This would<br>at least solve the “redo” problem but would not solve the “completeness” problem. If the client side prediction could be made as minimal as possible - for example only predicting an initial particle effect rather than<br>predicting the state and attribute change - then the problems get less severe.</p>
<hr>
<h1 id="FPredictionKey-Implementation-Notes"><a href="#FPredictionKey-Implementation-Notes" class="headerlink" title="FPredictionKey Implementation Notes"></a>FPredictionKey Implementation Notes</h1><p><code>FPredictionKey</code> is a generic way of supporting Clientside Prediction in the GameplayAbility system.<br>A <code>FPredictionKey</code> is essentially an ID for identifying predictive actions and side effects that are<br>done on a client. <code>UAbilitySystemComponent</code> supports synchronization of the prediction key and its side effects<br>between client and server.</p>
<p>Essentially, anything can be associated with a <code>PredictionKey</code>, for example activating an Ability.<br>The client can generate a fresh <code>PredictionKey</code> and sends it to the server in its <code>ServerTryActivateAbility</code> call.<br>The server can confirm or reject this call (<code>ClientActivateAbilitySucceed/Failed</code>).</p>
<p>While the client is predicting its ability, it is creating side effects (GameplayEffects, TriggeredEvents, Animations, etc).<br>As the client predicts these side effects, it associates each one with the prediction key generated at the start of the ability<br>activation.</p>
<p>If the ability activation is rejected, the client can immediately revert these side effects.<br>If the ability activation is accepted, the client must wait until the replicated side effects are sent to the server.<br>(The <code>ClientActivatbleAbilitySucceed</code> RPC will be immediately sent. Property replication may happen a few frames later).<br>Once replication of the server created side effects is finished, the client can undo its locally predictive side effects.</p>
<p>The main things <code>FPredictionKey</code> itself provides are:</p>
<ul>
<li>Unique ID and a system for having dependant chains of <code>Prediction Keys</code> (“Current” and “Base” integers)</li>
<li>A special implementation of <code>::NetSerialize</code> which only serializes the prediction key to the predicting client<ul>
<li>This is important as it allows us to serialize prediction keys in replicated state, knowing that only clients that gave the server the prediction key will actually see them!</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>UE Source</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>GAS</tag>
        <tag>UE Source</tag>
      </tags>
  </entry>
  <entry>
    <title>UE-ActorLifeTime</title>
    <url>/UE/OfficialDocLearn/Coding/ActorLifeTime/</url>
    <content><![CDATA[<h1 id="ActorLifeTime"><a href="#ActorLifeTime" class="headerlink" title="ActorLifeTime"></a>ActorLifeTime</h1><p>官方有一张LifeTime的流程图<br><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/unreal-engine-actor-lifecycle">官方文档</a></p>
<img src="/UE/OfficialDocLearn/Coding/ActorLifeTime/actorlifecycle1.png" class="" title="alt text">

<img src="/UE/OfficialDocLearn/Coding/ActorLifeTime/image.png" class="" title="alt text">
<p>-&gt; AISystemBase的纯虚函数 InitializeActorsForPlay<br>实际上这里也是由World调用下来的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UEngine::LoadMap</span><br><span class="line">  UWorld::InitializeActorsForPlay</span><br><span class="line">    Level-&gt;RouteActorInitialize</span><br><span class="line">      对Level的Actors(Array of all actors in this level.)进行处理</span><br><span class="line">    AISystem-&gt;InitializeActorsForPlay 默认情况下这里没有任何处理</span><br><span class="line"></span><br><span class="line">  UWorld::AddToWorld 添加Level到World</span><br><span class="line">      Level-&gt;RouteActorInitialize</span><br></pre></td></tr></table></figure>
<img src="/UE/OfficialDocLearn/Coding/ActorLifeTime/image-1.png" class="" title="alt text">
<p>在Actor内部存在一个bActorInitialized标志位 可以避免重复初始化。 Level那边也会判定这个标志位。<br>该标志位，在Actor的PostInitializeComponents会进行设置。</p>
<img src="/UE/OfficialDocLearn/Coding/ActorLifeTime/image-2.png" class="" title="alt text">
<p>Actor的创建,看到LevelActor.cpp中的SpawnActor,还是要结合UObject的来。C++层面是进行拷贝复制。其初始化更早。而蓝图方面的初始化就延后到OnConstruction了。</p>
<img src="/UE/OfficialDocLearn/Coding/ActorLifeTime/image-3.png" class="" title="alt text">
<p>Actor生成，蓝图构造代码执行之前。</p>
<img src="/UE/OfficialDocLearn/Coding/ActorLifeTime/image-4.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/Coding/ActorLifeTime/image-5.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/Coding/ActorLifeTime/image-6.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/Coding/ActorLifeTime/image-7.png" class="" title="alt text">
<p>垃圾回收这部分还是可以看到UObject。</p>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>C++ Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>UE-StateTree</title>
    <url>/UE/OfficialDocLearn/AI/StateTree/</url>
    <content><![CDATA[<h1 id="UE-State-Tree"><a href="#UE-State-Tree" class="headerlink" title="UE State Tree"></a>UE State Tree</h1><p>虚幻的状态树</p>
<p><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/overview-of-state-tree-in-unreal-engine">官方文档</a></p>
<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><img src="/UE/OfficialDocLearn/AI/StateTree/image.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/AI/StateTree/image-1.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/AI/StateTree/image-2.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/AI/StateTree/image-3.png" class="" title="alt text">

<h3 id="Selection-Flow"><a href="#Selection-Flow" class="headerlink" title="Selection Flow"></a>Selection Flow</h3><img src="/UE/OfficialDocLearn/AI/StateTree/image-4.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/AI/StateTree/image-5.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/AI/StateTree/image-6.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/AI/StateTree/image-7.png" class="" title="alt text">

<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>预定义的上下文数据<br>执行器 Custom Code<br>GlobalTask - 开始时执行的全局任务 持久性数据</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>1 Grouping Similar Tasks 任务分组管理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxx对象</span><br><span class="line"> - 子任务1</span><br><span class="line"> - 子任务2</span><br></pre></td></tr></table></figure>
<p>2 Sequences 顺序执行多个任务<br>在状态成功完成后，转移至下一个状态</p>
<p>3 Failure Handling 失败逻辑处理<br>在状态失败后 转移至下一个状态</p>
<p>4 Hierarchical Data 层次数据<br>子任务可以使用父任务产生的Data。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tasks can share data between each other. The data exposed by a Task will be available to any other Task that belongs to an active State.</span><br></pre></td></tr></table></figure>
<p>5 Refining Behavior 优化行为<br>用于组织对应的任务</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>状态树还是基于蓝图的层次状态机。<br>相较于一般的状态机，可视化以及树状算是其特点吧。状态有分为父状态和子状态，而非同一优先级。</p>
<img src="/UE/OfficialDocLearn/AI/StateTree/image-8.png" class="" title="alt text">
<p>在执行逻辑的过程中 同时执行跳转。</p>
<p>和行为树相比较，注意虚幻引擎行为树的事件驱动。</p>
<blockquote>
<p>事件驱动 一般情况下行为树是在同一个地方处理逻辑 Find a suitable leaf node。<br>行为树任务节点的Finish Execute这点。可以从MoveTo作为样例来参考。 在完成时才 Finish</p>
</blockquote>
<p>归根到底，行为树和状态树时两种手段，都是完成相应的逻辑</p>
<p>从经验论上来说，状态机的性能是好于行为树的。<br>这里有一篇参考文章<br><a href="https://zhuanlan.zhihu.com/p/1918237969791288178">虚幻的行为树 Behavior Tree (BT)与状态树 State Tree (ST)对比分析</a></p>
<p>但是无论如何 如果后端不使用DS 都需要考虑迁移和适配工作。<br>这部分还是看情况去考虑？</p>
<p>需要实际去编写对应的逻辑来进行性能测试。<br>状态树这部分，可以结合虚幻的MassEntity和SmartObject去进一步学习。特别是针对大量对象的场景。</p>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>UE</tag>
        <tag>StateTree</tag>
      </tags>
  </entry>
  <entry>
    <title>UE-Asserts</title>
    <url>/UE/OfficialDocLearn/Coding/Asserts/</url>
    <content><![CDATA[<h1 id="断言-Asserts"><a href="#断言-Asserts" class="headerlink" title="断言 Asserts"></a>断言 Asserts</h1><p><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/asserts-in-unreal-engine">官方文档 Asserts</a><br>detect and diagnose unexpected or invalid runtime conditions during development.</p>
<p>C++的断言,assert 与静态断言,static_assert。</p>
<img src="/UE/OfficialDocLearn/Coding/Asserts/image.png" class="" title="alt text">

<p>虚幻引擎的Assert:</p>
<ol>
<li>check<br>  -&gt; 运行时终止程序</li>
<li>verify<br>  -&gt; 类似check，但发布版本中，仍然执行表达式(忽略返回结果) “保留side effect”<br>  例如:verify((Mesh &#x3D; GetRenderMesh()) !&#x3D; nullptr); 这里内部有Mesh的赋值效果。</li>
<li>ensure<br>  -&gt; 不终止程序，记录错误并继续运行。</li>
</ol>
<p>详细可以看到：Engine&#x2F;Source&#x2F;Runtime&#x2F;Core&#x2F;Public&#x2F;Misc&#x2F;AssertionMacros.h</p>
<p>static_assert 静态断言还是可以继续应用的。<br>静态断言 static_assert -&gt; 直接在编译时做检测。</p>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>C++ Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>UE-Delegates</title>
    <url>/UE/OfficialDocLearn/Coding/Delegates/</url>
    <content><![CDATA[<h1 id="Delegates"><a href="#Delegates" class="headerlink" title="Delegates"></a>Delegates</h1><p>参考源码文件:<br>DelegateCombinations.h</p>
<img src="/UE/OfficialDocLearn/Coding/Delegates/image.png" class="" title="alt text">
<p>UE的”事件系统”。<br>其实很多项目，在脚本代码层，如lua或ts，会有着自己的事件管理器，用于定义事件，并注册对应的函数。事件触发时，已注册的函数都会被调用。当然，需要注意处理相应的回收逻辑。<br>虚幻的委托在逻辑上感觉是起到同样的功能。</p>
<img src="/UE/OfficialDocLearn/Coding/Delegates/image-1.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/Coding/Delegates/image-2.png" class="" title="alt text">

<h2 id="Binding-Delegate"><a href="#Binding-Delegate" class="headerlink" title="Binding Delegate"></a>Binding Delegate</h2><img src="/UE/OfficialDocLearn/Coding/Delegates/image-3.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/Coding/Delegates/image-4.png" class="" title="alt text">

<h2 id="负载变量（Payload-Variables）"><a href="#负载变量（Payload-Variables）" class="headerlink" title="负载变量（Payload Variables）"></a>负载变量（Payload Variables）</h2><img src="/UE/OfficialDocLearn/Coding/Delegates/image-5.png" class="" title="alt text">
<p>定义：负载变量是委托绑定（Bind）时附加的额外数据，这些数据会在委托执行时自动传递，无需在调用时显式传入。它们通常用于传递上下文信息（如对象实例、状态变量等）。<br>这部分可以看到DS。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 绑定一个成员函数，并附加一个负载变量（额外参数）</span><br><span class="line">MyDelegate.BindUObject(MyObject, &amp;UMyClass::MyFunction, 100); // 100 是负载变量</span><br><span class="line"></span><br><span class="line">// 调用时只需传递函数参数，负载变量会自动填充</span><br><span class="line">MyDelegate.Broadcast(10, 20);</span><br><span class="line"></span><br><span class="line">这里，MyFunction 的实际签名可能是：</span><br><span class="line">void UMyClass::MyFunction(int32 Param1, int32 Param2, int32 Payload);</span><br></pre></td></tr></table></figure>

<p>当然，单播和多播是不一样的。对于RetVal有返回值的单播委托，可以在判断IsBound后调用执行，并获取返回值，进行逻辑处理。</p>
<h2 id="Dynamic-Delegate"><a href="#Dynamic-Delegate" class="headerlink" title="Dynamic Delegate"></a>Dynamic Delegate</h2><img src="/UE/OfficialDocLearn/Coding/Delegates/image-6.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/Coding/Delegates/image-7.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/Coding/Delegates/image-8.png" class="" title="alt text">

<h2 id="Multi-cast-Delegates"><a href="#Multi-cast-Delegates" class="headerlink" title="Multi-cast Delegates"></a>Multi-cast Delegates</h2><p>多播委托<br>Delegates that can be bound to multiple functions and execute them all at once.</p>
<img src="/UE/OfficialDocLearn/Coding/Delegates/image-9.png" class="" title="alt text">
<p>执行用Broadcast。<br>RemoveAll会传入一个参数用来移除，相关可以看到MulticastDelegateBase.h<br>此外，相关的绑定信息也可以看到Delegate.h</p>
<h2 id="UDELEGATE"><a href="#UDELEGATE" class="headerlink" title="UDELEGATE"></a>UDELEGATE</h2><p>关于委托的宏与说明符:<br>Delegate functions support the same Specifiers as UFunctions, but use the UDELEGATE macro instead of UFUNCTION. For example, the following code adds the BlueprintAuthorityOnly specifier to the FInstigatedAnyDamageSignature delegate:<br>UDELEGATE(BlueprintAuthorityOnly)<br>DECLARE_DYNAMIC_MULTICAST_DELEGATE_FourParams(FInstigatedAnyDamageSignature, float, Damage, const UDamageType*, DamageType, AActor*, DamagedActor, AActor*, DamageCauser);<br>默认情况下不用加上UDELEGATE的宏。<br>即便使用UDELEGATE宏，声明为BlueprintCallable，其也无法从蓝图进行调用。需要理解委托的概念。</p>
<p>动态委托才能像UFUNCTION一样使用UDELEGATE。动态委托支持序列化和元信息也是很重要的一点。</p>
<h2 id="蓝图应用"><a href="#蓝图应用" class="headerlink" title="蓝图应用"></a>蓝图应用</h2><p>对于C++声明的Dynamic Delegates，要在蓝图中绑定函数到委托，需要通过EventDispatchers来创建Event并进行设置。</p>
<p>对于单播委托，将对应的委托变量，使用UPROPERTY(BlueprintReadWrite)暴露给蓝图后，可以通过蓝图进行对委托变量进行设置(绑定)。</p>
<p>对于多播委托，将对应的委托变量，使用UPROPERTY(BlueprintAssignable)暴露给蓝图后，可以通过蓝图进行对对应的委托添加侦听事件。</p>
<p>但是，无论是单播还是多播，C++定义的委托的触发(Execute或者是Broadcast)都需要通过C++来进行。</p>
<p>这里也可以补充一下EventDispatcher。<a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/event-dispatchers-in-unreal-engine">官方文档</a><br>其本质上就是蓝图系统中对动态多播委托的封装和应用。通过蓝图的定义的EventDispatchers和C++不同，可以直接在蓝图进行Call调用。(Call方法)。</p>
<h2 id="其他学习资料"><a href="#其他学习资料" class="headerlink" title="其他学习资料"></a>其他学习资料</h2><p>这里也有一篇深入学习原理的参考文章，可以结合源码阅读:<a href="https://zhuanlan.zhihu.com/p/460092901">一文理解透UE委托Delegate</a></p>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>C++ Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>UE-Coding Standard</title>
    <url>/UE/OfficialDocLearn/Coding/CodingStandard/</url>
    <content><![CDATA[<h1 id="Coding-Standard-代码规范"><a href="#Coding-Standard-代码规范" class="headerlink" title="Coding Standard 代码规范"></a>Coding Standard 代码规范</h1><p>不同的项目组一般会有自己的代码规范。<br>比如驼峰语法，小写开头的变量命名、大写函数等。<br>在使用虚幻引擎的时候，还是有必要了解官方的代码规范，特别时各个类的命名。<br>遵守一定的规则，让后续的代码维护和阅读起来更简单。</p>
<p>本篇主要列出一些相对需要注意的点。<br><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/epic-cplusplus-coding-standard-for-unreal-engine#classorganization">官方文档</a></p>
<h2 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h2><p>大写开头<br>布尔变量必须以b为前缀</p>
<h2 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h2><p>类名需要加额外的大写字符。<br>以下是一些默认的规则:</p>
<h3 id="模板类-T"><a href="#模板类-T" class="headerlink" title="模板类 - T"></a>模板类 - T</h3><h3 id="继承自UObject-U"><a href="#继承自UObject-U" class="headerlink" title="继承自UObject - U"></a>继承自UObject - U</h3><h3 id="继承自AActor-A"><a href="#继承自AActor-A" class="headerlink" title="继承自AActor  - A"></a>继承自AActor  - A</h3><h3 id="继承自SWidget-S"><a href="#继承自SWidget-S" class="headerlink" title="继承自SWidget - S"></a>继承自SWidget - S</h3><p>这部分可以进一步去了解虚幻引擎的Slate UI Framework</p>
<h3 id="抽象接口Interface-I"><a href="#抽象接口Interface-I" class="headerlink" title="抽象接口Interface - I"></a>抽象接口Interface - I</h3><h3 id="枚举Enum-E-enum-class-xxx"><a href="#枚举Enum-E-enum-class-xxx" class="headerlink" title="枚举Enum - E   (enum class xxx{})"></a>枚举Enum - E   (enum class xxx{})</h3><h3 id="其他多数类均以F为前缀，部分子系统以其他字符为前缀"><a href="#其他多数类均以F为前缀，部分子系统以其他字符为前缀" class="headerlink" title="其他多数类均以F为前缀，部分子系统以其他字符为前缀"></a>其他多数类均以F为前缀，部分子系统以其他字符为前缀</h3><ul>
<li>如FField</li>
</ul>
<h3 id="宏的名称应该全部大写，用下划线隔开，并以-UE-作为前缀"><a href="#宏的名称应该全部大写，用下划线隔开，并以-UE-作为前缀" class="headerlink" title="宏的名称应该全部大写，用下划线隔开，并以 UE_ 作为前缀"></a>宏的名称应该全部大写，用下划线隔开，并以 UE_ 作为前缀</h3><p>使用类型的时候最好加上对应的大小(特别是int与unit对应占用的bytes数)</p>
<h2 id="常量正确性"><a href="#常量正确性" class="headerlink" title="常量正确性"></a>常量正确性</h2><p>编写函数的时候，可以考虑使用常量const声明。</p>
<ul>
<li>Pass function arguments by const pointer or reference if those arguments are not intended to be modified by the function.</li>
<li>Flag methods as const if they do not modify the object.</li>
<li>Use const iteration over containers if the loop isn’t intended to modify the container.</li>
</ul>
<h2 id="使用nullptr-而不是-NULL宏"><a href="#使用nullptr-而不是-NULL宏" class="headerlink" title="使用nullptr 而不是 NULL宏"></a>使用nullptr 而不是 NULL宏</h2><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>一般情况下不要用auto。以下为几个例外</p>
<ul>
<li>Bind a lambda to a variable.</li>
<li>For iterator variables, but only where the iterator’s type is verbose and would impair readability.</li>
<li>In template code, where the type of an expression cannot easily be discerned. This is an advanced case.</li>
</ul>
<h2 id="Range-Based-For"><a href="#Range-Based-For" class="headerlink" title="Range-Based For"></a>Range-Based For</h2><p>使用TPair来进行TMap的遍历，取代CreateIterator的方式</p>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>Lambdas and Anonymous Functions<br>-&gt; 长度限制 最好不要超过2行<br>-&gt; 捕获时不要使用自动捕获([&amp;]与[&#x3D;])<br>-&gt; 延迟执行的Lambdas表达式不要使用引用捕获或者指针的值捕获<br>-&gt; 注意值捕获的性能问题<br>-&gt; CreateWeakLambda &#x2F; CreateSPLambda 用于延迟执行。捕获对象使用TWeakObjectPtr与TWeakPtr<br>-&gt; Accidentally captured UObject pointers are invisible to the garbage collector.</p>
<h2 id="枚举类声明"><a href="#枚举类声明" class="headerlink" title="枚举类声明"></a>枚举类声明</h2><p>使用 Strongly-Typed Enums<br>enum class EnumClassName<br>{<br>}<br>Enums exposed to Blueprints must continue to be based on uint8.<br>-&gt; enum class EnumClassName:uint8</p>
<h2 id="移动操作"><a href="#移动操作" class="headerlink" title="移动操作"></a>移动操作</h2><p>Move Semantices:<br>MoveTemp操作</p>
<h2 id="类中默认的成员变量初始化"><a href="#类中默认的成员变量初始化" class="headerlink" title="类中默认的成员变量初始化"></a>类中默认的成员变量初始化</h2><p>这里主要关注直接使用默认成员初始化，而不是在构造函数中赋值的问题。</p>
<p>Default Member Initializers 相比较构造函数处理,存在一些downsides:</p>
<p>Any change to the defaults requires a rebuild of all dependent files.</p>
<p>Headers can’t change in patch releases of the engine【引擎补丁无法修改头文件】, so this style can limit the kinds of fixes that are possible.</p>
<p>Some things can’t be initialized in this way, such as base classes, UObject subobjects, pointers to forward-declared types, values deduced from constructor arguments, and members initialized over multiple steps. </p>
<p>Putting some initializers in the header and the rest in constructors in the .cpp file, can reduce readability and maintainability.</p>
<p>Use your best judgment when deciding whether to use default member initializers. As a rule of thumb, default member initializers make more sense with in-game code than engine code. Consider using config files for default values.</p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>Namespaces<br>-&gt; Not supported by UnrealHeaderTool</p>
<h2 id="API设计："><a href="#API设计：" class="headerlink" title="API设计："></a>API设计：</h2><h3 id="bool参数优化"><a href="#bool参数优化" class="headerlink" title="bool参数优化"></a>bool参数优化</h3><p>函数上 对于多bool参数函数的优化 - 使用枚举。</p>
<p>函数参数过多时，声明并使用专用的结构体。</p>
<p>避免同时重载bool和FString的参数。若重载，在使用TEXT(“String”)时，可能会调用到bool版本。</p>
<h2 id="接口类注意事项"><a href="#接口类注意事项" class="headerlink" title="接口类注意事项"></a>接口类注意事项</h2><p>接口类都应该为抽象类，不包含成员变量。<br>这里还有一点需要注意：</p>
<ol>
<li>允许包含非纯虚函数的普通虚函数。</li>
<li>允许包含非虚函数或者是静态函数，但必须内联实现。”Implemented inline”</li>
</ol>
<ul>
<li>在头文件中直接加上函数的实现。在头文件中实现方法即隐式内联，无需显示添加inline关键字。<br>声明和重写方法时加上virtual与override关键字。(子类重写父类虚函数的时候两个都加上)</li>
</ul>
<h2 id="UObject参数"><a href="#UObject参数" class="headerlink" title="UObject参数"></a>UObject参数</h2><p>函数在使用UObjects作为参数传递时 应当使用指针进行参数传递而非引用</p>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>C++ Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>UE-Log</title>
    <url>/UE/OfficialDocLearn/Coding/Log/</url>
    <content><![CDATA[<h1 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h1><p>日志保存位置:<br>Saved&#x2F;Logs</p>
<h2 id="常用日志宏-UE-LOG"><a href="#常用日志宏-UE-LOG" class="headerlink" title="常用日志宏 UE_LOG"></a>常用日志宏 UE_LOG</h2><p>UE_LOG(LogTemp, Warning, TEXT(“Hello World”));</p>
<img src="/UE/OfficialDocLearn/Coding/Log/image.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/Coding/Log/image-1.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/Coding/Log/image-2.png" class="" title="alt text">

<h3 id="宏处理"><a href="#宏处理" class="headerlink" title="宏处理"></a>宏处理</h3><p>在UE_LOG内可以使用格式化</p>
<ul>
<li>字符串:”%s”</li>
<li>整数:”%d”</li>
<li>浮点数:”%f”</li>
<li>向量Vector的话，调用Vector的ToString进行转换再用字符串。</li>
</ul>
<p>Vector示例：*TestVec.ToString()</p>
<blockquote>
<p>int32 TestInt &#x3D; 100;<br>float TestFloat &#x3D; 6.66;<br>UE_LOG(LogTemp,Warning,TEXT(“Here is a mix text. %s | %d | %f”),TEXT(“str”),TestInt,TestFloat);<br>在OutputLog的输出：LogTemp: Warning: Here is a mix text. str | 100 | 6.660000</p>
</blockquote>
<h2 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h2><img src="/UE/OfficialDocLearn/Coding/Log/image-3.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/Coding/Log/image-4.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/Coding/Log/image-5.png" class="" title="alt text">
<p>在源码中可以看到很多示例。比如CoreGlobals.h与CoreGlobals.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Temporary log category, generally you should not check things in that use this</span><br><span class="line">CORE_API DECLARE_LOG_CATEGORY_EXTERN(LogTemp, Log, All);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DEFINE_LOG_CATEGORY(LogTemp);</span><br></pre></td></tr></table></figure>

<p>在头文件进行DECLARE_LOG_CATEGORY_EXTERN()声明。<br>在对应的cpp文件中使用DEFINE_LOG_CATEGORY()进行定义。<br>注意，对应的DECLARE和DEFINE只能声明定义一次。<br>测试Demo，定义 Actor1 Actor2 以及辅助头文件tool.h<br>在Actor1.h declare,在Actor1.cpp define:<br>Actor1.cpp正常使用。Actor2.cpp只需要include Actor1.h，不需要重新define，便可以使用。<br>或者直接在tool.h进行declare与define。<br>Actor1与Actor2引入头文件后可以正常使用。</p>
<p>Log的Category，主要是在打印前面加多一个所属的Category信息。日志仍然是在Saved里</p>
<h2 id="UE-LOGFMT"><a href="#UE-LOGFMT" class="headerlink" title="UE_LOGFMT"></a>UE_LOGFMT</h2><p>UE5.2版本新引入的UE_LOGFMT宏<br>使用位置或者名称来设置参数。</p>
<h3 id="Positional"><a href="#Positional" class="headerlink" title="Positional"></a>Positional</h3><p>When using positional parameters, the field values must exactly match the field referenced by format.<br>示例1</p>
<blockquote>
<p>UE_LOGFMT(LogCore, Warning, “Loading {Name} failed with error {Error}”, Package-&gt;GetName(),  ErrorCode);<br>示例2<br>UE_LOGFMT(LogTemp,Warning,”This is a test LOGFMT With Pos. {0}, {1}”,TEXT(“str1”),0.5f);</p>
</blockquote>
<h3 id="Named"><a href="#Named" class="headerlink" title="Named"></a>Named</h3><p>When using Named parameters, the field values must contain every field reference by format. The order is irrelevant and extra fields are permitted.<br>示例1</p>
<blockquote>
<p>UE_LOGFMT(LogCore, Warning, “Loading {Name} failed with error {Error}”,(“Name”, Package-&gt;GetName()), (“Error”, ErrorCode),(“Flags”, LoadFlags));<br>示例2<br>UE_LOGFMT(LogTemp,Warning,”This is a test LOGFMT With Name. {Name1}, {Name2}”,(“Name1”,TEXT(“str1”)),(“Name2”,0.5f),(“ExtraNoUsedInfo”,”no use”));</p>
</blockquote>
<img src="/UE/OfficialDocLearn/Coding/Log/image-6.png" class="" title="alt text">

<h2 id="常用屏幕日志打印-AddOnScreenDebugMessage"><a href="#常用屏幕日志打印-AddOnScreenDebugMessage" class="headerlink" title="常用屏幕日志打印 AddOnScreenDebugMessage"></a>常用屏幕日志打印 AddOnScreenDebugMessage</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (GEngine)</span><br><span class="line">  GEngine-&gt;AddOnScreenDebugMessage(-1, 5.f, FColor::White, TEXT(&quot;This is an Example on-screen debug message.&quot;));</span><br></pre></td></tr></table></figure>
<img src="/UE/OfficialDocLearn/Coding/Log/image-7.png" class="" title="alt text">]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>C++ Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>UE-GameplayTag</title>
    <url>/UE/OfficialDocLearn/Coding/GameplayTag/</url>
    <content><![CDATA[<h1 id="GameplayTag"><a href="#GameplayTag" class="headerlink" title="GameplayTag"></a>GameplayTag</h1><p>最初接触GameplayTag主要还是在GAS,当然GameplayTag是一个更广的内容。</p>
<img src="/UE/OfficialDocLearn/Coding/GameplayTag/image.png" class="" title="alt text">
<p>其功能正如”Tag”所代表。<br>相关源码，可以看到GameplayTagContainer.h中。</p>
<p>相关比较和匹配函数:<br>常用运算符:&#x3D;&#x3D;与!&#x3D;<br>其他：MatchesTag MatchesTagExact。<br>而在属性这块，FGameplayTag内部的TagName是一个FName。<br>关于FName，可以看到UE-Property文章中字符串的相关内容或者官方文档。</p>
<h2 id="GameplayTag的设置"><a href="#GameplayTag的设置" class="headerlink" title="GameplayTag的设置"></a>GameplayTag的设置</h2><h3 id="项目设置"><a href="#项目设置" class="headerlink" title="项目设置"></a>项目设置</h3><p>Project -&gt; ProjectSettings -&gt; GameplayTag<br>添加方式</p>
<ul>
<li>Directly adding or removing them in Project Settings<ul>
<li>启用Import Tags From Config,从.ini文件导入:including Config&#x2F;DefaultGameplayTags.ini and any in Config&#x2F;Tags</li>
</ul>
</li>
<li>Importing them from Data Table assets</li>
<li>Defining them with C++</li>
</ul>
<h3 id="数据文件设置"><a href="#数据文件设置" class="headerlink" title="数据文件设置"></a>数据文件设置</h3><img src="/UE/OfficialDocLearn/Coding/GameplayTag/image-1.png" class="" title="alt text">

<h3 id="代码设置"><a href="#代码设置" class="headerlink" title="代码设置"></a>代码设置</h3><img src="/UE/OfficialDocLearn/Coding/GameplayTag/image-2.png" class="" title="alt text">
<p>一个参考样例: LyraHealthSet.h与配套的cpp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Gameplay_Damage);</span><br><span class="line">UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Gameplay_DamageImmunity);</span><br><span class="line">UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Gameplay_DamageSelfDestruct);</span><br><span class="line">UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Gameplay_FellOutOfWorld);</span><br><span class="line">UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Lyra_Damage_Message);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">UE_DEFINE_GAMEPLAY_TAG(TAG_Gameplay_Damage, &quot;Gameplay.Damage&quot;);</span><br><span class="line">UE_DEFINE_GAMEPLAY_TAG(TAG_Gameplay_DamageImmunity, &quot;Gameplay.DamageImmunity&quot;);</span><br><span class="line">UE_DEFINE_GAMEPLAY_TAG(TAG_Gameplay_DamageSelfDestruct, &quot;Gameplay.Damage.SelfDestruct&quot;);</span><br><span class="line">UE_DEFINE_GAMEPLAY_TAG(TAG_Gameplay_FellOutOfWorld, &quot;Gameplay.Damage.FellOutOfWorld&quot;);</span><br><span class="line">UE_DEFINE_GAMEPLAY_TAG(TAG_Lyra_Damage_Message, &quot;Lyra.Damage.Message&quot;);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">//应用</span><br><span class="line">bool ULyraHealthSet::PreGameplayEffectExecute(FGameplayEffectModCallbackData &amp;Data)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  if (Data.Target.HasMatchingGameplayTag(TAG_Gameplay_DamageImmunity) &amp;&amp; !bIsDamageFromSelfDestruct)</span><br><span class="line">  &#123;</span><br><span class="line">    // Do not take away any health.</span><br><span class="line">    Data.EvaluatedData.Magnitude = 0.0f;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="GameplayTag应用"><a href="#GameplayTag应用" class="headerlink" title="GameplayTag应用"></a>GameplayTag应用</h2><img src="/UE/OfficialDocLearn/Coding/GameplayTag/image-3.png" class="" title="alt text">
<p>FGameplayTagContainer：<br>关键变量:<br>TArray<FGameplayTag> GameplayTags<br>TArray<FGameplayTag> ParentTags<br>在调用AddTag时,除了操作GameplayTags数组外，还会用GameplayTagsManager的ExtractParentTags对ParentTags处理。而下面的比较大部分也会用到ParentTags。<br>函数 HasTag、HasAny、HasAll<br>相关的描述在源码写的比较清楚。<br>当然，这里由引出了一个新的类: FGameplayTagNode。</p>
<img src="/UE/OfficialDocLearn/Coding/GameplayTag/image-4.png" class="" title="alt text">
<p>这部分也可以看到源码。官方在源码中有比较好的示例。</p>
<h2 id="拓展话题-FGameplayTagNode与Mgr管理的节点树"><a href="#拓展话题-FGameplayTagNode与Mgr管理的节点树" class="headerlink" title="拓展话题 FGameplayTagNode与Mgr管理的节点树"></a>拓展话题 FGameplayTagNode与Mgr管理的节点树</h2><p>本身Manager也维护一颗GameplayTagNode节点树。<br>在Mgr的ConstructGameplayTagTree中会进行节点树的构建。<br>Node中，会维护自身和其所有父节点 - CompleteTagWithParents，有需要可以再看。<br>总之，通过Mgr和节点树，对于单个Tag的判断开销就很低了。算是一种空间换时间。不过，考虑到FName本身不是每个字符串存一份，所以内存开销和时间开销都很好。</p>
<p>这一块其实和红点树是有些类似的。</p>
<h2 id="限制编辑与接口"><a href="#限制编辑与接口" class="headerlink" title="限制编辑与接口"></a>限制编辑与接口</h2><h3 id="GameplayTags-编辑限制"><a href="#GameplayTags-编辑限制" class="headerlink" title="GameplayTags 编辑限制"></a>GameplayTags 编辑限制</h3><img src="/UE/OfficialDocLearn/Coding/GameplayTag/image-5.png" class="" title="alt text">

<h3 id="使用Interface统一获取接口"><a href="#使用Interface统一获取接口" class="headerlink" title="使用Interface统一获取接口"></a>使用Interface统一获取接口</h3><img src="/UE/OfficialDocLearn/Coding/GameplayTag/image-6.png" class="" title="alt text">]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>C++ Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>UE-Tick</title>
    <url>/UE/OfficialDocLearn/Coding/Tick/</url>
    <content><![CDATA[<p>在业务的实际开发中，Update的顺序是比较重要的。在引擎中嵌入脚本语言，也需要有着对应的驱动模块。</p>
<h1 id="Tick"><a href="#Tick" class="headerlink" title="Tick"></a>Tick</h1><h2 id="Update链条"><a href="#Update链条" class="headerlink" title="Update链条"></a>Update链条</h2><p>Update链条：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Launch的GuardedMain -&gt; EngineTick</span><br><span class="line">↓</span><br><span class="line">LaunchEngineLoop -&gt; Tick</span><br><span class="line">  GEngine -&gt;Tick</span><br><span class="line">    UWorldTick</span><br><span class="line">      RunTickGroup</span><br><span class="line">        PrePhysics - Actor默认 - FActorTickFunction</span><br><span class="line">        StartPhyscis</span><br><span class="line">        DuringPhysics - ActorComp默认 - FActorComponentTickFunction</span><br><span class="line">        EndPhysics</span><br><span class="line">        PostPhysics</span><br><span class="line">        [这里暴露给蓝图的就Pre\During\Post]</span><br><span class="line">      LatentActionManager - 蓝图中的Delay</span><br><span class="line">      TimerManager - SetTimer</span><br><span class="line">      FTickableGameObject::TickObjects(UWorld)  -FTickableGameObject. 可以关注UTickableWorldSubsystem.</span><br><span class="line">      PlayerController - UpdateCameraManager</span><br><span class="line">      RunTickGroup</span><br><span class="line">        PostUpdateWork</span><br><span class="line">        LastDemotable</span><br><span class="line">    FTickableGameObject::TickObjects(nullptr)</span><br><span class="line">  FSlateApplication()::Get().Tick() [两次 两个类型 ESlateTickType]  - UI的Tick</span><br><span class="line">  FTSTicker::GetCoreTicker().Tick(FApp::GetDeltaTime()) - Ticker的Tick</span><br></pre></td></tr></table></figure>
<p>由此我们可以看到整个Tick的调用流程。</p>
<h2 id="Actor-Tick"><a href="#Actor-Tick" class="headerlink" title="Actor Tick"></a>Actor Tick</h2><p><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/actor-ticking-in-unreal-engine">官方文档</a></p>
<img src="/UE/OfficialDocLearn/Coding/Tick/image.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/Coding/Tick/image-1.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/Coding/Tick/image-2.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/Coding/Tick/image-3.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/Coding/Tick/image-4.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/Coding/Tick/image-5.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/Coding/Tick/image-6.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/Coding/Tick/image-7.png" class="" title="alt text">

<p>ActorTick的初始化<br>见构造函数 和 InitializedDefaults</p>
<img src="/UE/OfficialDocLearn/Coding/Tick/image-8.png" class="" title="alt text">

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://zhuanlan.zhihu.com/p/477018560">UE4中的三种Tick方式</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/661853225">【浅谈UE】Tick！Tick！Tick！Tick时序分析</a></p>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>C++ Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>UE-Package</title>
    <url>/UE/OfficialDocLearn/Coding/Package/</url>
    <content><![CDATA[<p>Package与Outer</p>
<h1 id="Package"><a href="#Package" class="headerlink" title="Package"></a>Package</h1><p>了解UPackage的概念。</p>
<p><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/working-with-assets-in-unreal-engine">官方文档 - Working with Assets</a></p>
<p>在虚幻引擎资源浏览器中看到的，其实都是Package。Package是一个抽象的概念，一个Package是一个文件（.uasset或者.umap），它包含一些可以UE进行操作和访问的二进制数据文件。一般一个Asset对应一个Package。两个例外：蓝图与HLOD。由多个Assets组成。</p>
<h1 id="Outer-与-Outermost"><a href="#Outer-与-Outermost" class="headerlink" title="Outer 与 Outermost"></a>Outer 与 Outermost</h1><p>沿着一个 UObject 对象的 Outer 链向上最终能找到一个 UPackage 对象，它决定了此 UObject 对象会被序列化在哪里。</p>
<h2 id="Outer"><a href="#Outer" class="headerlink" title="Outer"></a>Outer</h2><blockquote>
<p>UObjectBase.h<br>&#x2F;** Object this object resides in. *&#x2F;</p>
</blockquote>
<p>UObject的Outer对象，可以认为是“父对象”。<br>Outer定义了对象的归属。<br>-&gt; 构建层级<br>-&gt; 资源管理与序列化</p>
<h2 id="Outermost"><a href="#Outermost" class="headerlink" title="Outermost"></a>Outermost</h2><blockquote>
<p>UObjectBaseUtility.h<br>GetOutermost():Legacy function, has the same behavior as GetPackage.<br>GetPackage():Walks up the list of outers until it finds a package directly associated with the object.<br>GetOutermostObject() : Walks up the list of outers until it finds the top-level one that isn’t a package.</p>
</blockquote>
<p>UPackage的直接子对象称为顶层对象(OutermostObject)，因为它才是我们要使用的层级最高的对象，而UPackage仅是保存它们的地方。</p>
<p>OutmostObject即Package下的顶层对象</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><p>自定义类MyActor，并创建蓝图BP_MyActor继承自MyActor。<br><img src="/Package%5Cimage.png" alt="alt text"><br><img src="/Package%5Cimage-1.png" alt="alt text"><br>同样，我们可以测试场景中的蓝图实例：<br><img src="/Package%5Cimage2.png" alt="alt text"><br><img src="/Package%5Cimage3.png" alt="alt text"></p>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>C++ Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>UE-Reflection System</title>
    <url>/UE/OfficialDocLearn/Coding/UECPlusPlusReflection/</url>
    <content><![CDATA[<h1 id="反射系统-Reflection-System"><a href="#反射系统-Reflection-System" class="headerlink" title="反射系统 Reflection System"></a>反射系统 Reflection System</h1><p>参考文章：<br><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/reflection-system-in-unreal-engine">Reflection System in Unreal Engine</a><br><a href="https://zhuanlan.zhihu.com/p/717920216">UE5标识符详解 | 史上最全 - 知乎</a></p>
<p>总结：<br>反射指程序在运行时动态检查、修改自身状态或行为的能力。C++本身并不支持反射。<br>之前在用typescript和lua的时候，有很多写法其实就用到了反射的功能，只是没有去意识到。<br>要实现反射功能，需要收集对应的数据，并有相应的逻辑系统进行处理。<br>虚幻的反射便是基于宏来实现的。</p>
<p>关于虚幻引擎的宏 可以去看看大钊知乎的那篇符号说明的文章。<br>部分宏：<br>UCLASS、UFUNCTION、UPROPERTY、USTRUCT、UINTERFACE、UENUM。<br>通过宏，虚幻的反射系统才能收集到对应的信息并进行处理。</p>
<blockquote>
<p>-&gt; make UE aware of new classes,functions and varibales.<br>-&gt; These macros are garbage collected by the engine. 【指对对应的变量进行垃圾回收】。</p>
</blockquote>
<p>垃圾回收这块针对的还是变量。UFUNCTION宏主要是将函数暴露给反射系统。</p>
<p>一个简单的例子我想便是编辑器中对应字段的显示。<br>编辑器和运行时的Game一样，本身也是一个World。我们要在编辑器窗口去显示各种字段，不可能为每一个C++类单独去编写对应的显示逻辑。</p>
<p>在总览，官方文档还提到了常用的 TSubclassOf 用来获取UClass type的模板类（这里其实就是运行时类型检查了），以及元数据说明符和虚幻自己实现的智能指针。</p>
<p>关于元数据说明符：Metadata Specifiers，同样可以看大钊的那篇参考文章。meta部分主要是在编辑器下生效，从而可以编写自己的编辑器工具和功能。</p>
<p>关于智能指针部分：Unreal Smart Pointer Library 智能指针库：</p>
<ol>
<li>共享指针：引用计数</li>
<li>弱指针：引用不计数</li>
<li>共享引用Shared References(non - nullable Shared Pointers)：同不可为空的共享指针。</li>
<li>唯一指针Unique Pointers：同一时间仅一个唯一指针指向对象。额外需要注意的一点是，当唯一指针超出作用域时，其会自动删除引用的对象。[这也意味着，对唯一指针引用的对象使用共享指针&#x2F;共享引用是很危险的(也不应当为共享指针&#x2F;引用对象创建唯一指针)]<br>智能指针部分，和反射系统功能存在较为紧密的关系，如GC部分。</li>
</ol>
<p>那么，虚幻引擎基于反射又有哪些应用场景呢：</p>
<ol>
<li>编辑器集成。 这个刚刚也提到了。</li>
<li>垃圾回收(GC)。我们要去处理UObject派送类的引用关系，自动管理生命周期。</li>
<li>蓝图交互</li>
<li>序列化和反序列化、网络复制。如网络属性同步。<br>等等。</li>
</ol>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>C++ Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>UE-SmartPointers</title>
    <url>/UE/OfficialDocLearn/Coding/SmartPointers/</url>
    <content><![CDATA[<h1 id="智能指针-SmartPointers"><a href="#智能指针-SmartPointers" class="headerlink" title="智能指针 SmartPointers"></a>智能指针 SmartPointers</h1><p>写在最前面：<br>UObject及其子类的GC管理和智能指针管理是两套系统。不要混用了。<br>UObject有对应的TWeakObjectPtr与StrongObjectPtr。<br>非UObject类的才使用智能指针。</p>
<p>智能指针的基础部分在反射系统那边有介绍。</p>
<img src="/UE/OfficialDocLearn/Coding/SmartPointers/image.png" class="" title="alt text">
<p>-&gt; 在使用智能指针时 可以轻松区分拥有者和观察者。<br>-&gt; 注意内存开销会比普通指针大。这点和C++内部的智能指针其实是一样的。</p>
<img src="/UE/OfficialDocLearn/Coding/SmartPointers/image-1.png" class="" title="alt text">
<p>这部分可以看到SharePointer.h文件</p>
<img src="/UE/OfficialDocLearn/Coding/SmartPointers/image-2.png" class="" title="alt text">
<p>主要是在上层业务使用。<br>使用的时候注意尽量用MakeShared来创建新的对象，或者类继承自TSharedFromThis.</p>
<img src="/UE/OfficialDocLearn/Coding/SmartPointers/image-3.png" class="" title="alt text">
<p>侵入性访问器<br>非侵入性 - 对象不知道是否被智能指针所持有。<br>想要以TSharedPtr或TSharedRef访问对象，需要继承自TSharedFromThis。<br>然后提供两个接口，一个是 AsShared，一个是SharedThis</p>
<p>ClassA: public TSharedFromThis<ClassA><br>ClassB: public ClassA</p>
<p>则在ClassB的对象上：<br>调用AsShared()返回的是ClassA的TSharedRef[ClassA直接继承自TSharedFromThis]<br>调用SharedThis(this)返回的就是ClassB的TSharedRef了.<br>然后可以由Ref转为指针。</p>
<p>有一点是需要注意的：</p>
<blockquote>
<p>Do not call AsShared or SharedThis from constructors, since the shared reference is not initialized at that time and will cause a crash or assert.</p>
</blockquote>
<img src="/UE/OfficialDocLearn/Coding/SmartPointers/image-4.png" class="" title="alt text">
<p>Static Cast  -&gt; 编译时 - 依赖开发者确保类型兼容性<br>Dynamic Cast -&gt; 运行时 - 需要动态进行类型检查，而智能指针这块没有RTTI</p>
<img src="/UE/OfficialDocLearn/Coding/SmartPointers/image-5.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/Coding/SmartPointers/image-6.png" class="" title="alt text">
<p>关于这块的转换可以看到SharedPointerTesting.inl文件。<br>比如TSharedRef到const&amp;的转换:<br>const float &amp; MyFloat &#x3D; <em>FloatRef; [看到SharedPointer中对于</em>符号的重写]<br>const float &amp; MyFloat2 &#x3D; FloatRef.Get();</p>
<h2 id="TSharedPtr与TSharedRef"><a href="#TSharedPtr与TSharedRef" class="headerlink" title="TSharedPtr与TSharedRef"></a>TSharedPtr与TSharedRef</h2><p>TSharedRef与TSharedPtr的转换:<br>Ref -&gt; Ptr的隐式转换: 直接Ptr &#x3D; Ref<br>Ptr -&gt; Ref 做多一个判定:  if(Ptr.IsValid()){Ref &#x3D; Ptr.ToSharedRef()}</p>
<p>Ptr判定:</p>
<ol>
<li>if(Ptr.IsValid())       &#x2F;&#x2F;IsValid</li>
<li>if(Ptr)                 &#x2F;&#x2F;bool</li>
<li>if(Ptr.Get()!&#x3D;nullptr)  &#x2F;&#x2F;Ptr</li>
</ol>
<img src="/UE/OfficialDocLearn/Coding/SmartPointers/image-7.png" class="" title="alt text">

<h2 id="TWeakPtr"><a href="#TWeakPtr" class="headerlink" title="TWeakPtr"></a>TWeakPtr</h2><img src="/UE/OfficialDocLearn/Coding/SmartPointers/image-8.png" class="" title="alt text">
<p>创建弱指针 也是看到SharedPointer.h<br>可以直接使用TSharedRef创建，或者直接用TSharedPtr赋值</p>
<p>使用Pin函数将弱指针转为TSharedPtr</p>
<p>TSharedPtr与TWeakPtr置空<br>调用Reset()或者直接设置为nullptr来清除。</p>
<img src="/UE/OfficialDocLearn/Coding/SmartPointers/image-9.png" class="" title="alt text">
<ol>
<li>WeakPtr可以用作值而不要用作键</li>
<li>在访问其指向对象时，用Pin确保对象的有效性</li>
</ol>
<h1 id="UE-SharedPtr实现和源码分析"><a href="#UE-SharedPtr实现和源码分析" class="headerlink" title="UE SharedPtr实现和源码分析"></a>UE SharedPtr实现和源码分析</h1><p><a href="https://blog.csdn.net/Vjunjun/article/details/140621117">UE TSharedPtr 实现，及内部原理</a><br><a href="https://zhuanlan.zhihu.com/p/369974105">UE4的智能指针 TSharedPtr</a></p>
<blockquote>
<p>碎碎念：在复习C++的智能指针时，未免要接触到RAII，想想看UE的SharedPtr能帮助理解和学习。</p>
</blockquote>
<p>源码文件见 SharedPointer.h</p>
<p>关于引用要看到 SharedPointerInternals.h<br>其FSharedReferencer与TReferenceControllerBase管控了相关的计数。</p>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>C++ Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>UE-UInterface</title>
    <url>/UE/OfficialDocLearn/Coding/UInterface/</url>
    <content><![CDATA[<h1 id="Unreal-Interfaces"><a href="#Unreal-Interfaces" class="headerlink" title="Unreal Interfaces"></a>Unreal Interfaces</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于接口的概念，在其他很多语言都有类似的定义。比如Typescript。而C++本身没有接口的语法。</p>
<p>在UE的框架下，几乎万物皆UObject。那么在使用接口这样的概念时，难以避免的一个问题便是类的菱形继承。哦吼，这个时候怎么办？</p>
<p>在相同功能的情况下，使用组件不失为一种解决方案。但是，面对不同对象要求不同实现的情况呢？</p>
<blockquote>
<p>题外话:<br>在游戏开发过程中，面向对象和面向组件是两种思路，也有组合优于继承的说法，之前项目也会有继承链过程而较难维护的问题，这块自己在实践时多留一下即可。</p>
</blockquote>
<p>回到正题，这并不影响去设计一个方式来抽出共有的函数接口，来实现“接口”的概念。而用于继承的接口，就不能再来自UObject了。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>-&gt; 接口保证类实现一组共用函数。<br>-&gt; 不同类的函数执行不同的行为。<br>-&gt; 解决UObject菱形继承的问题。</p>
<p>C++声明:<br>1.用于引擎反射的接口部分 UInterface<br>使用UINTERFACE()宏与继承自UInterface。<br>2.实际用于实现功能的接口部分 IInterface</p>
<p>这里需要注意，两个对应的接口类都需要GENERATED_BODY()宏。<br>虚幻这里的处理比较巧妙，在有了UInterface对应的反射后，IInterface在不继承自UObject的同时，可以使用UFUNCTION等标记，并能被引擎识别。</p>
<p>这样，我们实现了接口功能，也能避免菱形继承的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">This class does not need to be modified.</span><br><span class="line">Empty class for reflection system visibility.</span><br><span class="line">Uses the UINTERFACE macro.</span><br><span class="line">Inherits from UInterface.</span><br><span class="line">*/</span><br><span class="line">UINTERFACE()</span><br><span class="line">class UReactToTriggerInterface : public UInterface</span><br><span class="line">&#123;</span><br><span class="line">  GENERATED_BODY()</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* Actual Interface declaration. */</span><br><span class="line">class IReactToTriggerInterface</span><br><span class="line">&#123;</span><br><span class="line">  GENERATED_BODY()</span><br><span class="line"> </span><br><span class="line">  // Add interface functions to this class. This is the class that will be inherited to implement this interface.</span><br><span class="line">public:</span><br><span class="line">  // Add interface function declarations here</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关于UINTERFACE宏相关的说明符，可以参考官方文档或者是大钊那篇标识符的文章。<br><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/interfaces-in-unreal-engine">Unreal Interface</a></p>
<h2 id="接口实现与接口函数"><a href="#接口实现与接口函数" class="headerlink" title="接口实现与接口函数"></a>接口实现与接口函数</h2><p>Include对应的接口头文件，并继承自IInterface即可。</p>
<p>纯C++部分可以直接用普通的函数。无需UFUNCTION说明符。<br>接口声明的虚函数，在仅C++调用时，对应的实现类正常重载即可。</p>
<p>支持蓝图调用的函数就需要UFUNCTION了。</p>
<ol>
<li>BlueprintCallable</li>
<li>BlueprintImplementableEvent[仅蓝图] 或 BlueprintNativeEvent[支持C++与蓝图,默认C++，蓝图重写。C++部分需要在实现对应的_Implementation版本。]</li>
<li>非虚函数。</li>
</ol>
<p>C++调用BlueprintImplementableEvent或BlueprintNativeEvent:需要加上Execute_前缀</p>
<blockquote>
<p>&#x2F;&#x2F; OriginalObject is an object that implements the IReactToTriggerInterface<br>bool bReacted &#x3D; IReactToTriggerInterface::Execute_ReactToTrigger(OriginalObject);</p>
</blockquote>
<img src="/UE/OfficialDocLearn/Coding/UInterface/image.png" class="" title="alt text">

<h2 id="接口实现判定"><a href="#接口实现判定" class="headerlink" title="接口实现判定"></a>接口实现判定</h2><p>之前所述，大部分情况下都是直接用的IInterface，但在接口判定的时候需要用的可能是UInterface。毕竟，是通过UInterface来实现反射的。（除了指针转换，毕竟继承的还是IInterface）</p>
<img src="/UE/OfficialDocLearn/Coding/UInterface/image-1.png" class="" title="alt text">
<p>此外，除了Cast,也可以用TScriptInterface&lt;&gt;来进行类型转换。</p>
<h2 id="指定接口实现类的指针"><a href="#指定接口实现类的指针" class="headerlink" title="指定接口实现类的指针"></a>指定接口实现类的指针</h2><p>-&gt; TScriptInterface&lt;&gt;<br>有点类似于TSubclassOf&lt;&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UMyObject* MyObjectPtr;</span><br><span class="line">TScriptInterface&lt;IMyInterface&gt; MyScriptInterface;</span><br><span class="line"> </span><br><span class="line">if (MyObjectPtr-&gt;Implements&lt;UMyInterface&gt;())</span><br><span class="line">&#123;</span><br><span class="line">  MyScriptInterface = TScriptInterface&lt;IMyInterface&gt;(MyObjectPtr);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// MyScriptInterface holds a reference to MyObjectPtr and MyInterfacePtr</span><br></pre></td></tr></table></figure>
<img src="/UE/OfficialDocLearn/Coding/UInterface/image-2.png" class="" title="alt text">

<h2 id="可用于蓝图继承的C-层接口"><a href="#可用于蓝图继承的C-层接口" class="headerlink" title="可用于蓝图继承的C++层接口"></a>可用于蓝图继承的C++层接口</h2><img src="/UE/OfficialDocLearn/Coding/UInterface/image-3.png" class="" title="alt text">

<h2 id="关于UE内部接口实现和UInterface与IInterface问题"><a href="#关于UE内部接口实现和UInterface与IInterface问题" class="headerlink" title="关于UE内部接口实现和UInterface与IInterface问题"></a>关于UE内部接口实现和UInterface与IInterface问题</h2><p>可先看下知乎的这篇文章做一个大致了解:<br><a href="https://zhuanlan.zhihu.com/p/60851912">UE4 Interface原理与使用</a></p>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>C++ Coding</tag>
        <tag>UInterface</tag>
      </tags>
  </entry>
  <entry>
    <title>UE-UObject</title>
    <url>/UE/OfficialDocLearn/Coding/UObject/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>个人梳理和总结</p>
<p>本篇主要是对UObject的逻辑上进行梳理和总结。</p>
<p>虚幻的UObject可以说是其万物之根基。<br>虽然UObject上面还有UObjectBaseUtility，以及UObjectBase，但正如源码所诉说，上面的都不应当直接使用。</p>
<p>虽然UObject是虚幻中的“一”，但虚幻中也有非继承自UObject的类。理解UObject的关键点还是很重要的。</p>
<p>本篇梳理基于虚幻引擎5.6源码、虚幻官方文档、以及大钊的《InsideUE4》UObject相关知乎文章进行。</p>
<h1 id="统一的基类-Object"><a href="#统一的基类-Object" class="headerlink" title="统一的基类 Object"></a>统一的基类 Object</h1><p>引用一句话，”Understand the trade-off”。<br>C++本身效率很高，其有很高的自由度。而这也意味着，内存管理等功能需要用户自己去实现。<br>统一的基类，可以帮我们处理底层逻辑，上层业务不需要再操心处理。同时提供较为强大的功能。</p>
<h2 id="UObject所提供的功能-Functionality"><a href="#UObject所提供的功能-Functionality" class="headerlink" title="UObject所提供的功能 Functionality"></a>UObject所提供的功能 Functionality</h2><ol>
<li>垃圾回收</li>
<li>引用更新</li>
<li>反射</li>
<li>序列化</li>
<li>默认属性变化自动更新</li>
<li>自动属性初始化</li>
<li>自动编辑器整合</li>
<li>运行时类型信息可用</li>
<li>网络复制</li>
</ol>
<img src="/UE/OfficialDocLearn/Coding/UObject/image-3.png" class="" title="alt text">

<h3 id="UObject反射分析"><a href="#UObject反射分析" class="headerlink" title="UObject反射分析"></a>UObject反射分析</h3><p>反射：指的是在运行时动态地获取对象的状态信息并对其进行操作的能力。通常用于在程序运行时动态地创建对象、调用方法和修改属性等操作。</p>
<p>C++本身也有RTTI的支持。适用于包含虚函数的类的dynamic_cast与typeid。<br>typeid对于含虚函数的类是动态类型，否则是静态类型。而其本身也只是用来做一个区别。</p>
<p>虚幻为了实现反射，采用的是UHT(Unreal Header Tool)来分析代码并生成对应的文件，从而实现反射。</p>
<h4 id="反射相关结构"><a href="#反射相关结构" class="headerlink" title="反射相关结构"></a>反射相关结构</h4><p>四个源码文件</p>
<blockquote>
<p>Class.h: UClass definition.<br>UnrealType.h: Unreal engine base type definitions.<br>UInterface.h<br>MetaData.h</p>
</blockquote>
<p>处理反射数据</p>
<ul>
<li>UField<br>Base class of reflection data objects.</li>
<li>UMetaData<br>An object that holds a map of key&#x2F;value pairs. </li>
<li>UStruct<br>Base class for all UObject types that contain fields.</li>
<li>UEnum<br>Reflection data for an enumeration.</li>
<li>UFunction<br>Reflection data for a replicated or Kismet callable function.</li>
<li>UClass<br>An object class.</li>
<li>UScriptStruct<br>Reflection data for a standalone structure declared in a header or as a user defined struct</li>
<li>UInterface<br>Base class for all interfaces</li>
</ul>
<p>按4.25版本后，做了优化，属性方面不再是UProperty，新加入了FField和FPropery。使用FProperty。<br>FField和UField是类似的，只是其并不继承自UObject。<br>FProperty: An UnrealScript variable.</p>
<h4 id="UProperty-To-FProperty"><a href="#UProperty-To-FProperty" class="headerlink" title="UProperty To FProperty"></a>UProperty To FProperty</h4><p>在虚幻4.25,UPropery有一个比较大的修改。想要看到过去的ReleaseNote需要借助网页快照工具。在之后，使用FProperty而非UProperty来进行存储。</p>
<p>主要目的还是减少不必要的开销，优化性能和内存。</p>
<p><a href="https://web.archive.org/web/20201224022923/https://docs.unrealengine.com/en-US/WhatsNew/Builds/ReleaseNotes/4_25/index.html">UE4.25ReleaseNote</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Core</span><br><span class="line">UProperty</span><br><span class="line">This is an API breaking change.</span><br><span class="line"></span><br><span class="line">Converted UProperties to FProperties. This means that internal Engine objects that represent member variables of UClasses will no longer be UObjects themselves. This results in memory overhead reduction (123 bytes per property on average) and improved performance when constructing, destroying property objects, when collecting garbage and iterating over all objects. Property casts and property iteration is now faster too.</span><br><span class="line"></span><br><span class="line">U*Property classes have been renamed to F*Property classes so all references to UProperties in your project code should be updated</span><br><span class="line"></span><br><span class="line">FProperties use different Cast functions (CastField / CastFieldChecked) so all property casts should be updated in your project game code.</span><br><span class="line"></span><br><span class="line">UPROPERTY() UProperty* MemberVariable; declarations should be replaced with UPROPERTY() TFieldPath&lt;FProperty&gt; MemberVariable;. It still is a Garbage Collector exposed hard reference with PendingKill support (becomes null if the owner UStruct is PendingKill) and automatically serialized with SerializeTaggedProperties with automatic conversion on load for all existing saved references to UProperties in packages.</span><br><span class="line"></span><br><span class="line">TFieldIterator&lt;UField&gt; no longer iterates properties, use TFieldIterator&lt;FProperty&gt; instead</span><br><span class="line"></span><br><span class="line">FindField has been split into two functions: FindUField and FindFProperty. The former should be used to find member Functions or Enums, the latter should be used to find member variables.</span><br><span class="line"></span><br><span class="line">FProperties are no longer constructed with NewObject, use C++ new instead</span><br><span class="line"></span><br><span class="line">UStruct::Children linked list no longer contains properties. Use UStruct::ChildProperties instead.</span><br><span class="line"></span><br><span class="line">FArchive derived classes that collect UObject references now need to override virtual FArchive&amp;amp; operator &amp;lt;&amp;lt; (FField*&amp;amp;) to catch FProperty references. All existing cases that needed it should already support it.</span><br><span class="line"></span><br><span class="line">There&#x27;s no FProperty::GetOuter(). Use FProperty::GetOwner() instead. The reason is that Outers are an UObject thing. FProperties are now owned by their parents in a more explicit way.</span><br><span class="line"></span><br><span class="line">There&#x27;s a helper structure called FFieldVariant that acts as a container that can be either UObject or FProperty. It&#x27;s used in a few places across the codebase to ease the conversion to FProperties where otherwise a separate, almost identical version of the existing function would have to be created. However, the goal is to remove it eventually as the affected system owners will be upgrading their code.</span><br><span class="line"></span><br><span class="line">In editor builds, there&#x27;s a helper UPropertyWrapper class that&#x27;s used by Details Panels to pass FProperty references around. Again, this was to prevent doing very extensive changes to systems that only actually deal with FProperties as editable objects in a handful of places.</span><br></pre></td></tr></table></figure>

<p>其他参考文章:<br><a href="https://zhuanlan.zhihu.com/p/380610877">UE4 FProperty</a></p>
<h4 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h4><p>UHT在进行分析后遍进行对应结构的构建。<br>概念阶段：生成、收集、注册、链接</p>
<p>收集 - 收集到数据结构里保存。利用自动注册模式来进行。<br>自动注册 - C++Static自动注册模式。通过模板、构造函数、静态变量进行自动注册</p>
<p>整个流程需要结合UHT的相关代码以及生成代码进行学习。<br>如果需要深入了解，可以结合大钊相关InsideUE4文章和源码再看。</p>
<h4 id="UClass对象"><a href="#UClass对象" class="headerlink" title="UClass对象"></a>UClass对象</h4><p>大钊在原文中描述UClass对象的构造比较关键。</p>
<p>一个UClass*要经历这么几个阶段：</p>
<ol>
<li>内存构造。刚创建出来一块白纸一般的内存，简单的调用了UClass的构造函数。UE里一个对象的构造，构造函数的调用只是个起点而已。</li>
<li>注册。给自己一个名字，把自己登记在对象系统中。这步是通过DeferredRegister而不是Register完成的。</li>
<li>对象构造。往对象里填充属性、函数、接口和元数据的信息。这步我们应该记得是在gen.cpp里的那些函数完成的。</li>
<li>绑定链接。属性函数都有了，把它们整理整理，尽量优化一下存储结构，为以后的使用提供更高性能和便利。</li>
<li>CDO创建。既然类型已经有了，那就万事俱备只差国家包分配一个类默认对象了。每个UClass都有一个CDO（Class Default Object），有了CDO，相当于有了一个存档备份和参照，其他对象就心不慌。</li>
<li>引用记号流构建。一个Class是怎么样有可能引用其他别的对象的，这棵引用树怎么样构建的高效，也是GC中一个非常重要的话题。有了引用记号流，就可以对一个对象高效的分析它引用了其他多少对象。</li>
</ol>
<p>了解了UClass*的处理后，可以更好的理解UObject的创建流程、GC的流程。这部分结合之前的文章再看就好。</p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><img src="/UE/OfficialDocLearn/Coding/UObject/G1.png" class="" title="alt text">
<p>这部分可以结合Level的源码来看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Level.h</span><br><span class="line">/** Array of all actors in this level, </span><br><span class="line">used by FActorIteratorBase and derived classes */</span><br><span class="line">TArray&lt;TObjectPtr&lt;AActor&gt;&gt; Actors;</span><br><span class="line"></span><br><span class="line">/** Array of actors to be exposed to GC in this level. </span><br><span class="line">All other actors will be referenced through ULevelActorContainer */</span><br><span class="line">TArray&lt;TObjectPtr&lt;AActor&gt;&gt; ActorsForGC;</span><br><span class="line"></span><br><span class="line">UPROPERTY(Transient, DuplicateTransient, NonTransactional)</span><br><span class="line">TObjectPtr&lt;ULevelActorContainer&gt; ActorCluster;</span><br><span class="line"></span><br><span class="line">LevelActorContainer.h</span><br><span class="line">/**</span><br><span class="line"> * Root object for all level actors</span><br><span class="line"> */</span><br><span class="line">UCLASS(MinimalAPI, DefaultToInstanced)</span><br><span class="line">class ULevelActorContainer : public UObject</span><br><span class="line">&#123;</span><br><span class="line">  friend class ULevel;</span><br><span class="line"></span><br><span class="line">  GENERATED_BODY()</span><br><span class="line">public:</span><br><span class="line">  /** Array of actors in a level */</span><br><span class="line">  UPROPERTY(transient)</span><br><span class="line">  TArray&lt;TObjectPtr&lt;AActor&gt;&gt; Actors;</span><br><span class="line"></span><br><span class="line">  virtual void CreateCluster() override;</span><br><span class="line">  virtual void OnClusterMarkedAsPendingKill() override;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>算是对UE GC的结构有一个初步的了解。<br>关于RootSet可以看到UObjectBaseUtility的AddToRoot<br>非UObject的GC可以看到GCObject.h -&gt; FGCObject</p>
<h4 id="增量垃圾回收"><a href="#增量垃圾回收" class="headerlink" title="增量垃圾回收"></a>增量垃圾回收</h4><p>见官方文档 <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/incremental-garbage-collection-in-unreal-engine">Incremental Garbage Collection</a></p>
<p>UE的垃圾回收基于标记<br>而对应的垃圾回收处理本身也是有开销的，可能会造成帧卡顿。<br>UObject对象池算是一个解决方法。</p>
<p>基于自己的开发经验，可以复用，反复处理的对象常常都应当在逻辑侧做池化减少创建开销和GC开销。粒子特效、模型、调用频繁的临时对象等等……</p>
<p>增量垃圾回收主要就是避免单帧卡顿的问题。可以认为将其逻辑开销分摊到多帧上去进行了。不过目前还是Experimental功能。</p>
<h4 id="垃圾回收内部机制"><a href="#垃圾回收内部机制" class="headerlink" title="垃圾回收内部机制"></a>垃圾回收内部机制</h4><p>其实还是Mark - Sweep的原理。这点和Unity、Lua的GC机制算是一致的。<br>参考文章<br><a href="https://dev.epicgames.com/community/learning/knowledge-base/ePKR/unreal-engine-garbage-collector-internals">Garbage Collector Internals</a></p>
<h3 id="引用更新"><a href="#引用更新" class="headerlink" title="引用更新"></a>引用更新</h3><p>在GC后，相关指针的置空逻辑。可以见下面的Destroy。</p>
<p>When an <strong>AActor</strong> or <strong>UActorComponent</strong> is destroyed or otherwise removed from play, all references to it that are visible to the reflection system (UProperty pointers and pointers stored in Unreal Engine container classes such as TArray) are automatically nulled.<br>重点：</p>
<blockquote>
<p>It applies only to UActorComponent or AActor <strong>references</strong> marked with <strong>UPROPERTY</strong> or stored in an UE container class.</p>
</blockquote>
<p>UObject指针用的是TObjectPtr。但是本身Destroy后不会立刻GC，可以的话还是用IsValid函数来判定更准确。</p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><img src="/UE/OfficialDocLearn/Coding/UObject/S1.png" class="" title="alt text">
<p>基于UPROPERTY的序列化。”Transient”或者是构造函数之后无变化的值无需进行序列化。<br>可能平时做游戏，在关卡中放置Actor，修改对应Instance属性，然后保存习惯了，并没有细想其是如何实现的。而UObject的序列化，就做到了仅需要UCLASS和UPROPERTY的宏声明，就默认处理了对应的序列化流程。<br>当然，也提供了对应的Serialize重写。</p>
<blockquote>
<p>Object.h<br>COREUOBJECT_API virtual void Serialize(FArchive&amp; Ar);<br>COREUOBJECT_API virtual void Serialize(FStructuredArchive::FRecord Record);</p>
</blockquote>
<h3 id="默认属性变化时-自动更新"><a href="#默认属性变化时-自动更新" class="headerlink" title="默认属性变化时 自动更新"></a>默认属性变化时 自动更新</h3><img src="/UE/OfficialDocLearn/Coding/UObject/P1.png" class="" title="alt text">
<p>改变类的默认属性时，(CDO变化)，会将新值更新到对应实例化且属性值未改动的实体上。</p>
<h3 id="属性初始化的自动化处理"><a href="#属性初始化的自动化处理" class="headerlink" title="属性初始化的自动化处理"></a>属性初始化的自动化处理</h3><p>  在调用构造函数之前，UObject所有属性自动归零，可以在构造函数中对对应的属性进行初始化。</p>
<h3 id="编辑器整合"><a href="#编辑器整合" class="headerlink" title="编辑器整合"></a>编辑器整合</h3><h3 id="运行时可处理类型信息"><a href="#运行时可处理类型信息" class="headerlink" title="运行时可处理类型信息"></a>运行时可处理类型信息</h3><p>Run-Time Type Information and Casting<br>运行时动态类型转换<br>-&gt; 调用父类 Super::FunctionName()<br>-&gt; IsA()函数类判定 （见UObjectBaseUtility）<br>-&gt; Cast 基类指针转为子类对象指针 Cast&lt;ChildClass&gt;(BaseClassPtr)</p>
<h3 id="网络复制"><a href="#网络复制" class="headerlink" title="网络复制"></a>网络复制</h3><p>UObject本身也做了网络复制的支持。<br>比如UPROPERT宏相关网络复制的设置，以及UFUNCTION对应的RPC</p>
<h1 id="UCLASS-宏"><a href="#UCLASS-宏" class="headerlink" title="UCLASS 宏"></a>UCLASS 宏</h1><img src="/UE/OfficialDocLearn/Coding/UObject/image.png" class="" title="alt text">
<p>使用UCLASS宏 -&gt; 给UObject提供一个UCLASS的引用。<br>UCLASS中包含着定义对应类的属性函数。并维护一个CDO。</p>
<p>使用对应的宏来让引擎识别对应的函数和属性。<br>UFUNCTION 与 UPROPERTY</p>
<h1 id="UObject-创建"><a href="#UObject-创建" class="headerlink" title="UObject 创建"></a>UObject 创建</h1><p>关于创建的部分，在这里详述:</p>
<a href="/UE/OfficialDocLearn/Coding/UObjectCreation/" title="UE-UObjectCreation">UObjectCreation</a>


<h1 id="UHT-Unreal-Header-Tool"><a href="#UHT-Unreal-Header-Tool" class="headerlink" title="UHT Unreal Header Tool"></a>UHT Unreal Header Tool</h1><img src="/UE/OfficialDocLearn/Coding/UObject/image-4.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/Coding/UObject/image-5.png" class="" title="alt text">
<p>模块API宏的部分可以看之前模块文章，做过具体叙述了。<br>UCLASS与USTRUCT需要加上GENERATED_BODY()宏<br>关于相关宏定义，可以看到源码的ObjectMacros.h</p>
<h1 id="Update-Tick"><a href="#Update-Tick" class="headerlink" title="Update - Tick"></a>Update - Tick</h1><img src="/UE/OfficialDocLearn/Coding/UObject/image-6.png" class="" title="alt text">
<p>UObject本来没有对应的Tick功能，一般是AActor才有。或者是UActorComponent<br>否则的话 需要继承FTickableGameObject。这部分可以看看Tickable.h</p>
<h1 id="Destroy"><a href="#Destroy" class="headerlink" title="Destroy"></a>Destroy</h1><img src="/UE/OfficialDocLearn/Coding/UObject/image-7.png" class="" title="alt text">
<img src="/UE/OfficialDocLearn/Coding/UObject/image-8.png" class="" title="alt text">
<p>标记回收的还是用MarkAsGarbage接口，这部分可以看到UObjectBaseUtility<br>也可以在UObjectBaseUtility中看到IsPendingKillEnabled接口。(5.4换为了IsGarbageEliminationEnabled接口)</p>
<p>考虑使用弱引用，并且多用IsValid来判断UObject是否有效（在UObject），否则<br>可能会存在已经垃圾回收了但是仍然有指针引用的问题。</p>
<p>当然，如果没有UPROPERTY宏的标记，就不会被引擎识别，也不会处理对应的GC，或者是自动置空.</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>在UObject这块，也可以看看大钊在知乎上发的InsideUE5专栏的UObject系列文章<br>当然,大钊的这系列的文章是基于UE4的较早版本编写的，在看和理解的时候，最好还是<br>结合最新的源码去理解并辨别。</p>
<p>这里也做一些类的额外补充:</p>
<p>UObjectBase(包含UClass) -&gt; UObjectBaseUtility -&gt; UObject</p>
<p>UObject -&gt; UField -&gt; UStruct -&gt; UClass</p>
<p>UObject -&gt; UInterface</p>
<p>UObject -&gt; AActor</p>
<p>实际上 后面单独有一个FField独立出来。<br>可以看到Field.h文件。<br>而类型FProperty则是继承自FField。可以看到UnrealType.h</p>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>C++ Coding</tag>
        <tag>UObject</tag>
      </tags>
  </entry>
  <entry>
    <title>UE-Property</title>
    <url>/UE/OfficialDocLearn/Coding/UProperty/</url>
    <content><![CDATA[<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="属性宏"><a href="#属性宏" class="headerlink" title="属性宏"></a>属性宏</h2><p>UPROPERTY()<br>变量说明符和元数据相关的内容还是看到大钊的那篇文章。这里不多赘述了。<br><a href="https://zhuanlan.zhihu.com/p/717920216">UE5标识符详解 | 史上最全</a></p>
<h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>int 8,16,32,64<br>uint 8,16,32,64<br>整形可以额外声明作为位掩码并在编辑器中显示。(meta &#x3D; (Bitmask))</p>
<h2 id="浮点"><a href="#浮点" class="headerlink" title="浮点"></a>浮点</h2><p>float,double,long double</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>FString 与 FName 与 FText.</p>
<h3 id="TEXT-宏"><a href="#TEXT-宏" class="headerlink" title="TEXT()宏"></a>TEXT()宏</h3><blockquote>
<p>For most uses, Unreal relies on the TCHAR type for characters. The TEXT() macro is available to denote TCHAR literals.<br>MyDogPtr-&gt;DogName &#x3D; FName(TEXT(“Samson Aloysius”));<br>TEXT宏的返回类型为TCHAR数组。为和平台无关的字符类型。</p>
</blockquote>
<p>在进行日志输出时，时常需要用到TEXT宏:</p>
<blockquote>
<p>FString TestString &#x3D; TEXT(“A TestStr”);<br>UE_LOG(LogTemp,Warning,TEXT(“%s”),*TestString);</p>
</blockquote>
<h3 id="FString"><a href="#FString" class="headerlink" title="FString"></a>FString</h3><p>动态字符数组。<br>与FName和FText不同，FString可以与搜索、修改并且与其他字符串比较。<br>其保存自己的字符数组，开销比不可变字符串类更大。</p>
<h3 id="FName"><a href="#FName" class="headerlink" title="FName"></a>FName</h3><p>虚幻引擎会在全局维护一个唯一的字符串表。<br>在进行 &#x3D;&#x3D; 比较时很高效，因为并不是真的进行字符串比较，而是Index比较。<br>全局字符串表中<strong>不可变</strong>且<strong>不区分大小写</strong>的字符串的引用，比FString更小更高效。其<strong>无法被操作</strong>。</p>
<p>可以用于表示对象名称、标识符和其他常用于比较的字符串。</p>
<p>FNames只能被转换为FStrings和FText，只能从FStrings进行转换。<br><strong>但转换需注意了，FName不区分大小写。</strong></p>
<h3 id="FText"><a href="#FText" class="headerlink" title="FText"></a>FText</h3><p>用于处理本地化的更可靠的字符串。<br>Text Localization：将游戏中文本适配到不同语言和地区。<br>面向用户的文本应当使用FText(UI部分)。</p>
<p>-&gt; 文本格式<br>-&gt; 依据数字、日期生成的文本<br>-&gt; 衍生文本(大小写)</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>简单需求的话，程序侧主要还是用FString与FName。需要注意FName的不区分大小写特性。<br>在UI方面用FText来展示文本内容。</p>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>C++ Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>UE-UObjectCreation</title>
    <url>/UE/OfficialDocLearn/Coding/UObjectCreation/</url>
    <content><![CDATA[<p>UObject的基础部分可以看到这里:</p>
<a href="/UE/OfficialDocLearn/Coding/UObject/" title="UE-UObject">UObject</a>

<h1 id="创建概述"><a href="#创建概述" class="headerlink" title="创建概述"></a>创建概述</h1><p>基础的类宏声明UCLASS，以及头文件”.generated.h”的引入，和GENERATE_BODY宏就不在这详述了。</p>
<img src="/UE/OfficialDocLearn/Coding/UObjectCreation/image-1.png" class="" title="alt text">
<p>UObject并不支持带有参数的构造函数。<br>所有C++侧UObject会在引擎StartUp时初始化。</p>
<p>创建UObject: [考虑UE本身的内存管理和GC系统]</p>
<ol>
<li>运行时创建NewObject</li>
<li>在构造函数中创建CreateDefaultSubobject 例如一个类中组件变量的<br>初始化流程</li>
</ol>
<p>初始化函数和逻辑处理 -&gt; 放在BeginPlay()去处理。</p>
<img src="/UE/OfficialDocLearn/Coding/UObjectCreation/image-2.png" class="" title="alt text">

<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><img src="/UE/OfficialDocLearn/Coding/UObjectCreation/img1.png" class="" title="alt text">
<p>在头文件中实现构造函数的，需要在UCLASS中加上CustomConstructor声明符。不过这个在UE5已经弃用了，应该不需要太关注。有需要的话，可以去看大钊的说明符文档。</p>
<p>在上边提到的： UObject的构造函数应该不接入自定义参数。实际上UObject也有多个构造函数版本。默认不传参数，或者传入FObjectInitializer.实际上默认的构造函数其实也会处理FObjectInitializer相关的逻辑。这部分的实现可以看到UObjectGlobals.cpp</p>
<p>由此就有两个常见的构造函数了:<br>UMyObject::UMyObject()<br>UMyObject::UMyObject(const FObjectInitializer&amp; ObjectInitializer): Super(ObjectInitializer)</p>
<p>构造函数的作用:This constructor initializes the Class Default Object (CDO), which is the master copy on which future instances of the class are based.</p>
<img src="/UE/OfficialDocLearn/Coding/UObjectCreation/img2.png" class="" title="alt text">

<p>NewObject函数与CreateDefaultSubobject 这部分可以看到UObjectGlobals.h<br>SpawnActor的声明见到World.h，实现见到LevelActor.cpp。</p>
<h2 id="FObjectInitializer"><a href="#FObjectInitializer" class="headerlink" title="FObjectInitializer"></a>FObjectInitializer</h2><p>那么不禁好奇，FObjectInitializer的作用是什么？<br>简言之，其负责类成员变量的初始化。</p>
<p>这里有一篇文章可以结合源码看看<a href="https://zhuanlan.zhihu.com/p/422510443">UE4 FObjectInitializer 对象初始化器</a></p>
<p>Archetype 原型<br>通过拷贝原型的方式进行实例化。<br>从UObjectGlobal.h的NewObject往下走。<br>所需要的处理:</p>
<ol>
<li>分配内存 见UObjectGlobals.cpp的StaticAllocateObject</li>
<li>执行对应的构造 见UObjectGlobals.cpp中StaticConstructObject_Internal的(*InClass-&gt;ClassConstructor)(FObjectInitializaer(Result,Params))</li>
</ol>
<p>冷处理 CreateDefaultSubObject - 只有注册的组件才去处理。</p>
<p>子类对象构造替换 - FObjectInitializer的 SetDefaultSubobjectClass。</p>
<h1 id="构造数据与Helper-Constructor-Statics-and-Helpers"><a href="#构造数据与Helper-Constructor-Statics-and-Helpers" class="headerlink" title="构造数据与Helper Constructor Statics and Helpers"></a>构造数据与Helper Constructor Statics and Helpers</h1><img src="/UE/OfficialDocLearn/Coding/UObjectCreation/img3.png" class="" title="alt text">
<p>关于ConstructorStatics可以在源码中找一些参考。主要是进行一些字符串的初始化。<br>不过引擎内部也主要是在编辑器环境去用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ATriggerCapsule::ATriggerCapsule(...)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">#if WITH_EDITORONLY_DATA</span><br><span class="line">  if (UBillboardComponent* TriggerSpriteComponent = GetSpriteComponent())</span><br><span class="line">  &#123;</span><br><span class="line">    TriggerSpriteComponent-&gt;SetupAttachment(CapsuleCollisionComponent);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (GetSpriteComponent())</span><br><span class="line">  &#123;</span><br><span class="line">    // Structure to hold one-time initialization</span><br><span class="line">    struct FConstructorStatics</span><br><span class="line">    &#123;</span><br><span class="line">      ConstructorHelpers::FObjectFinderOptional&lt;UTexture2D&gt; TriggerTextureObject;</span><br><span class="line">      FName ID_Triggers;</span><br><span class="line">      FText NAME_Triggers;</span><br><span class="line">      FConstructorStatics()</span><br><span class="line">        : TriggerTextureObject(TEXT(&quot;/Engine/EditorResources/S_TriggerCapsule&quot;))</span><br><span class="line">        , ID_Triggers(TEXT(&quot;Triggers&quot;))</span><br><span class="line">        , NAME_Triggers(NSLOCTEXT(&quot;SpriteCategory&quot;, &quot;Triggers&quot;, &quot;Triggers&quot;))</span><br><span class="line">      &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    static FConstructorStatics ConstructorStatics;</span><br><span class="line"></span><br><span class="line">    GetSpriteComponent()-&gt;Sprite = ConstructorStatics.TriggerTextureObject.Get();</span><br><span class="line">  &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而Helper部分可以看到ConstructorHelper.h<br>-&gt; 硬编码的资源引用<br>-&gt; 类引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UGroomComponent::UGroomComponent(...)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  static ConstructorHelpers::FObjectFinder&lt;UMaterialInterface&gt; Strands_DebugMaterialRef(TEXT(&quot;/HairStrands/Materials/HairDebugMaterial.HairDebugMaterial&quot;));</span><br><span class="line">  static ConstructorHelpers::FObjectFinder&lt;UMaterialInterface&gt; Strands_DefaultMaterialRef(TEXT(&quot;/HairStrands/Materials/HairDefaultMaterial.HairDefaultMaterial&quot;));</span><br><span class="line">  static ConstructorHelpers::FObjectFinder&lt;UMaterialInterface&gt; Cards_DefaultMaterialRef(TEXT(&quot;/HairStrands/Materials/HairCardsDefaultMaterial.HairCardsDefaultMaterial&quot;));</span><br><span class="line">  static ConstructorHelpers::FObjectFinder&lt;UMaterialInterface&gt; Meshes_DefaultMaterialRef(TEXT(&quot;/HairStrands/Materials/HairMeshesDefaultMaterial.HairMeshesDefaultMaterial&quot;));</span><br><span class="line"></span><br><span class="line">  Strands_DebugMaterial   = Strands_DebugMaterialRef.Object;</span><br><span class="line">  Strands_DefaultMaterial = Strands_DefaultMaterialRef.Object;</span><br><span class="line">  Cards_DefaultMaterial = Cards_DefaultMaterialRef.Object;</span><br><span class="line">  Meshes_DefaultMaterial = Meshes_DefaultMaterialRef.Object;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>C++ Coding</tag>
        <tag>UObject</tag>
      </tags>
  </entry>
  <entry>
    <title>UE5.5-Lyra-1-Attribute</title>
    <url>/UE/Project/Lyra/UE55Lyra1/</url>
    <content><![CDATA[<p>基于官方Lyra的GAS学习。</p>
<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>首先就是ASC的位置。<br>Lyra项目将ASC放置于了LyraPlayerState中。<br>将ASC与PlayerState绑定。</p>
<p>此外 可以看到LyraCharacter。其也有获取ASC的接口。</p>
<p>从LyraCharacter获取ASC组件，依赖于其PawnExtComponent。<br>这里可以看到ULyraPawnExtensionComponent这个类。<br>该类会存放一个ASC指针。在函数InitializeAbilitySystem中进行设置。</p>
<p>LyraHeroComponent是唯一调用该方法的组件。<br>见ULyraHeroComponent::HandleChangeInitState。<br>这里的逻辑也是从PlayerState中拿到ASC，然后赋值给PawnExtComponent。</p>
<p>总而言之，该项目的ASC位于PlayerState。<br>整体的链条大概如下：<br>PlayerState -&gt; LyraHeroComp -&gt; PawnExtComponent -&gt; LyraCharacter。</p>
<p>再整理一下：</p>
<p>LyraCharacter - 包含PawnExtComp<br> ↓ 子类<br>Character_Default<br> ↓ 子类<br>B_Hero_Default - 新增组件 LyraHeroComp</p>
<p>因此 只需要在子类去调用InitializeAbilitySystem来设置PawnExtComp中的ASC指针即可。</p>
<p>实际上，Pawn本身就有GetPlayerState的方法。<br>LyraHeroComp只是调用该方法（转为Lyra的PlayerState）并由LyraPlayerState获取ASC而已。</p>
<p>这部分的一些设置可以看到B_LyraGameMode。</p>
<h1 id="LyraPlayerState"><a href="#LyraPlayerState" class="headerlink" title="LyraPlayerState"></a>LyraPlayerState</h1><p>先看到 PlayerState部分<br>LyraPlayerState - 继承自AModularPlayerState IAbilitySystemInterface ILyraTeamAgentInterface</p>
<h1 id="关于ASC的初始化"><a href="#关于ASC的初始化" class="headerlink" title="关于ASC的初始化"></a>关于ASC的初始化</h1><p>LyraPlayerState，后续简称为 LPS<br>LPS继承自PlayerState，继承自AInfo。构造函数有:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AInfo(const FObjectInitializer&amp; ObjectInitializer = FObjectInitializer::Get());</span><br></pre></td></tr></table></figure>
<p>在LPS中，使用ObjectInitializer来创建ASC:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AbilitySystemComponent = ObjectInitializer.CreateDefaultSubobject&lt;ULyraAbilitySystemComponent&gt;(this, TEXT(&quot;AbilitySystemComponent&quot;));</span><br><span class="line"></span><br><span class="line">//另外一种创建ASC</span><br><span class="line">//直接调用[感兴趣也可以看看底层实现。其实还是拿了FObjectInitializer]</span><br><span class="line">AbilitySystemComponent = CreateDefaultSubobject&lt;ULyraAbilitySystemComponent&gt;(TEXT(&quot;AbilitySystemComponent2&quot;));</span><br></pre></td></tr></table></figure>
<p>之后 设置ASC的复制模式,并创建所需要的AttributeSet</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AbilitySystemComponent-&gt;SetIsReplicated(true);</span><br><span class="line">AbilitySystemComponent-&gt;SetReplicationMode(EGameplayEffectReplicationMode::Mixed);</span><br><span class="line"></span><br><span class="line">// These attribute sets will be detected by AbilitySystemComponent::InitializeComponent. Keeping a reference so that the sets don&#x27;t get garbage collected before that.</span><br><span class="line">HealthSet = CreateDefaultSubobject&lt;ULyraHealthSet&gt;(TEXT(&quot;HealthSet&quot;));</span><br><span class="line">CombatSet = CreateDefaultSubobject&lt;ULyraCombatSet&gt;(TEXT(&quot;CombatSet&quot;));</span><br></pre></td></tr></table></figure>

<h1 id="AttributeSet"><a href="#AttributeSet" class="headerlink" title="AttributeSet"></a>AttributeSet</h1><p>首先 从AttributeSet和ASC都位于LPS上可以看到设计的一致性。<br>接下来看看属性集的设计：</p>
<h2 id="ULyraHealthSet"><a href="#ULyraHealthSet" class="headerlink" title="ULyraHealthSet"></a>ULyraHealthSet</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private:</span><br><span class="line"></span><br><span class="line">	// The current health attribute.  The health will be capped by the max health attribute.  Health is hidden from modifiers so only executions can modify it.</span><br><span class="line">	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Health, Category = &quot;Lyra|Health&quot;, Meta = (HideFromModifiers, AllowPrivateAccess = true))</span><br><span class="line">	FGameplayAttributeData Health;</span><br><span class="line"></span><br><span class="line">	// The current max health attribute.  Max health is an attribute since gameplay effects can modify it.</span><br><span class="line">	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxHealth, Category = &quot;Lyra|Health&quot;, Meta = (AllowPrivateAccess = true))</span><br><span class="line">	FGameplayAttributeData MaxHealth;</span><br><span class="line"></span><br><span class="line">	// Used to track when the health reaches 0.</span><br><span class="line">	bool bOutOfHealth;</span><br><span class="line"></span><br><span class="line">	// Store the health before any changes </span><br><span class="line">	float MaxHealthBeforeAttributeChange;</span><br><span class="line">	float HealthBeforeAttributeChange;</span><br><span class="line"></span><br><span class="line">	// -------------------------------------------------------------------</span><br><span class="line">	//	Meta Attribute (please keep attributes that aren&#x27;t &#x27;stateful&#x27; below </span><br><span class="line">	// -------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">	// Incoming healing. This is mapped directly to +Health</span><br><span class="line">	UPROPERTY(BlueprintReadOnly, Category=&quot;Lyra|Health&quot;, Meta=(AllowPrivateAccess=true))</span><br><span class="line">	FGameplayAttributeData Healing;</span><br><span class="line"></span><br><span class="line">	// Incoming damage. This is mapped directly to -Health</span><br><span class="line">	UPROPERTY(BlueprintReadOnly, Category=&quot;Lyra|Health&quot;, Meta=(HideFromModifiers, AllowPrivateAccess=true))</span><br><span class="line">	FGameplayAttributeData Damage;</span><br></pre></td></tr></table></figure>

<p>可以看到简简单单的一个生命属性集 不但有普通的最大生命值，当前生命值，还有两个额外的数值。Healing与Damage。</p>
<p>在基类LyraAttributeSet中 定义了对应的属性宏用于获取&#x2F;设置属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * This macro defines a set of helper functions for accessing and initializing attributes.</span><br><span class="line"> *</span><br><span class="line"> * The following example of the macro:</span><br><span class="line"> *		ATTRIBUTE_ACCESSORS(ULyraHealthSet, Health)</span><br><span class="line"> * will create the following functions:</span><br><span class="line"> *		static FGameplayAttribute GetHealthAttribute();</span><br><span class="line"> *		float GetHealth() const;</span><br><span class="line"> *		void SetHealth(float NewVal);</span><br><span class="line"> *		void InitHealth(float NewVal);</span><br><span class="line"> */</span><br><span class="line">#define ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \</span><br><span class="line">	GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \</span><br><span class="line">	GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \</span><br><span class="line">	GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \</span><br><span class="line">	GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)</span><br></pre></td></tr></table></figure>
<p>Healing与Damage只是中间处理，并不参与复制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void ULyraHealthSet::GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) const</span><br><span class="line">&#123;</span><br><span class="line">	Super::GetLifetimeReplicatedProps(OutLifetimeProps);</span><br><span class="line"></span><br><span class="line">	DOREPLIFETIME_CONDITION_NOTIFY(ULyraHealthSet, Health, COND_None, REPNOTIFY_Always);</span><br><span class="line">	DOREPLIFETIME_CONDITION_NOTIFY(ULyraHealthSet, MaxHealth, COND_None, REPNOTIFY_Always);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后看到三个属性关键函数：</p>
<ul>
<li>PreAttributeBaseChange &#x2F;&#x2F;before any modification happens to an attribute’s base value</li>
<li>PreAttributeChange &#x2F;&#x2F;before any modification happens to an attribute</li>
<li>PostAttributeChange &#x2F;&#x2F;just after any modification happens to an attribute</li>
</ul>
<p>这三个函数：</p>
<ul>
<li>可以做值的范围限制（Clamp），如限制当前生命值大于0，小于最大生命值。最大生命值最小为1。</li>
<li>可以做值修正。比如最大生命值改变后，限制当前生命值为最大生命值。这里的修正要注意写法。用ApplyModToAttribute。&#x2F;&#x2F;Not invoke Pre&#x2F;PostGameplayEffectExecute calls on the attribute set</li>
</ul>
<p>然后是两个重要的GE函数：</p>
<ul>
<li>PreGameplayEffectExecute &#x2F;&#x2F;just before modifying the value of an attribute</li>
<li>PostGameplayEffectExecute &#x2F;&#x2F;just after a GameplayEffect is executed to modify the base value of an attribute</li>
</ul>
<p>PreGameplayEffectExecute</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool ULyraHealthSet::PreGameplayEffectExecute(FGameplayEffectModCallbackData &amp;Data)</span><br><span class="line">&#123;</span><br><span class="line">	if (!Super::PreGameplayEffectExecute(Data))</span><br><span class="line">	&#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//可以看到这里的是用“伤害”属性来做伤害的</span><br><span class="line">	// Handle modifying incoming normal damage</span><br><span class="line">	if (Data.EvaluatedData.Attribute == GetDamageAttribute())</span><br><span class="line">	&#123;</span><br><span class="line">		if (Data.EvaluatedData.Magnitude &gt; 0.0f)</span><br><span class="line">		&#123;</span><br><span class="line">			//自毁伤害</span><br><span class="line">			const bool bIsDamageFromSelfDestruct = Data.EffectSpec.GetDynamicAssetTags().HasTagExact(TAG_Gameplay_DamageSelfDestruct);</span><br><span class="line"></span><br><span class="line">			//免疫伤害的能力</span><br><span class="line">			if (Data.Target.HasMatchingGameplayTag(TAG_Gameplay_DamageImmunity) &amp;&amp; !bIsDamageFromSelfDestruct)</span><br><span class="line">			&#123;</span><br><span class="line">				// Do not take away any health.</span><br><span class="line">				Data.EvaluatedData.Magnitude = 0.0f;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">#if !UE_BUILD_SHIPPING</span><br><span class="line">			//GM模式 - 不扣血</span><br><span class="line">			// Check GodMode cheat, unlimited health is checked below</span><br><span class="line">			if (Data.Target.HasMatchingGameplayTag(LyraGameplayTags::Cheat_GodMode) &amp;&amp; !bIsDamageFromSelfDestruct)</span><br><span class="line">			&#123;</span><br><span class="line">				// Do not take away any health.</span><br><span class="line">				Data.EvaluatedData.Magnitude = 0.0f;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">#endif // #if !UE_BUILD_SHIPPING</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//改变前记录目前的属性</span><br><span class="line">	// Save the current health</span><br><span class="line">	HealthBeforeAttributeChange = GetHealth();</span><br><span class="line">	MaxHealthBeforeAttributeChange = GetMaxHealth();</span><br><span class="line"></span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PostGameplayEffectExecute</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void ULyraHealthSet::PostGameplayEffectExecute(const FGameplayEffectModCallbackData&amp; Data)</span><br><span class="line">&#123;</span><br><span class="line">	Super::PostGameplayEffectExecute(Data);</span><br><span class="line"></span><br><span class="line">	const bool bIsDamageFromSelfDestruct = Data.EffectSpec.GetDynamicAssetTags().HasTagExact(TAG_Gameplay_DamageSelfDestruct);</span><br><span class="line">	float MinimumHealth = 0.0f;</span><br><span class="line"></span><br><span class="line">#if !UE_BUILD_SHIPPING</span><br><span class="line">	// GM模式下不死</span><br><span class="line">	// Godmode and unlimited health stop death unless it&#x27;s a self destruct</span><br><span class="line">	if (!bIsDamageFromSelfDestruct &amp;&amp;</span><br><span class="line">		(Data.Target.HasMatchingGameplayTag(LyraGameplayTags::Cheat_GodMode) || Data.Target.HasMatchingGameplayTag(LyraGameplayTags::Cheat_UnlimitedHealth) ))</span><br><span class="line">	&#123;</span><br><span class="line">		MinimumHealth = 1.0f;</span><br><span class="line">	&#125;</span><br><span class="line">#endif // #if !UE_BUILD_SHIPPING</span><br><span class="line"></span><br><span class="line">	const FGameplayEffectContextHandle&amp; EffectContext = Data.EffectSpec.GetEffectContext();</span><br><span class="line"></span><br><span class="line">	// “发起人” 链条源 - &quot;return the original instigator that started the whole chain&quot;</span><br><span class="line">	AActor* Instigator = EffectContext.GetOriginalInstigator();</span><br><span class="line"></span><br><span class="line">	// “引起者” - &quot;the physical actor tied to the application of this effect&quot;</span><br><span class="line">	AActor* Causer = EffectContext.GetEffectCauser();</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	*  玩家[Instigator]→技能→子弹[Causer]→敌人伤害</span><br><span class="line">	*/</span><br><span class="line"></span><br><span class="line">	if (Data.EvaluatedData.Attribute == GetDamageAttribute())</span><br><span class="line">	&#123;</span><br><span class="line">		// Send a standardized verb message that other systems can observe</span><br><span class="line">		if (Data.EvaluatedData.Magnitude &gt; 0.0f)</span><br><span class="line">		&#123;</span><br><span class="line">			//伤害事件 </span><br><span class="line">			FLyraVerbMessage Message;</span><br><span class="line">			Message.Verb = TAG_Lyra_Damage_Message;</span><br><span class="line">			Message.Instigator = Data.EffectSpec.GetEffectContext().GetEffectCauser();</span><br><span class="line">			Message.InstigatorTags = *Data.EffectSpec.CapturedSourceTags.GetAggregatedTags();</span><br><span class="line">			Message.Target = GetOwningActor();</span><br><span class="line">			Message.TargetTags = *Data.EffectSpec.CapturedTargetTags.GetAggregatedTags();</span><br><span class="line">			//@TODO: Fill out context tags, and any non-ability-system source/instigator tags</span><br><span class="line">			//@TODO: Determine if it&#x27;s an opposing team kill, self-own, team kill, etc...</span><br><span class="line">			Message.Magnitude = Data.EvaluatedData.Magnitude;</span><br><span class="line"></span><br><span class="line">			UGameplayMessageSubsystem&amp; MessageSystem = UGameplayMessageSubsystem::Get(GetWorld());</span><br><span class="line">			MessageSystem.BroadcastMessage(Message.Verb, Message);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//通过元属性Damage 来造成生命值的减少。</span><br><span class="line"></span><br><span class="line">		// Convert into -Health and then clamp</span><br><span class="line">		SetHealth(FMath::Clamp(GetHealth() - GetDamage(), MinimumHealth, GetMaxHealth()));</span><br><span class="line">		SetDamage(0.0f);</span><br><span class="line">	&#125;</span><br><span class="line">	else if (Data.EvaluatedData.Attribute == GetHealingAttribute())</span><br><span class="line">	&#123;</span><br><span class="line">		//治疗</span><br><span class="line">		// Convert into +Health and then clamp</span><br><span class="line">		SetHealth(FMath::Clamp(GetHealth() + GetHealing(), MinimumHealth, GetMaxHealth()));</span><br><span class="line">		SetHealing(0.0f);</span><br><span class="line">	&#125;</span><br><span class="line">	else if (Data.EvaluatedData.Attribute == GetHealthAttribute())</span><br><span class="line">	&#123;</span><br><span class="line">		// Clamp and fall into out of health handling below</span><br><span class="line">		SetHealth(FMath::Clamp(GetHealth(), MinimumHealth, GetMaxHealth()));</span><br><span class="line">	&#125;</span><br><span class="line">	else if (Data.EvaluatedData.Attribute == GetMaxHealthAttribute())</span><br><span class="line">	&#123;</span><br><span class="line">		// TODO clamp current health?</span><br><span class="line"></span><br><span class="line">		//这里HealthSet里面新增的广播</span><br><span class="line">		// Notify on any requested max health changes</span><br><span class="line">		OnMaxHealthChanged.Broadcast(Instigator, Causer, &amp;Data.EffectSpec, Data.EvaluatedData.Magnitude, MaxHealthBeforeAttributeChange, GetMaxHealth());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// If health has actually changed activate callbacks</span><br><span class="line">	if (GetHealth() != HealthBeforeAttributeChange)</span><br><span class="line">	&#123;</span><br><span class="line">		//这里HealthSet里面新增的广播</span><br><span class="line">		OnHealthChanged.Broadcast(Instigator, Causer, &amp;Data.EffectSpec, Data.EvaluatedData.Magnitude, HealthBeforeAttributeChange, GetHealth());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if ((GetHealth() &lt;= 0.0f) &amp;&amp; !bOutOfHealth)</span><br><span class="line">	&#123;</span><br><span class="line">		//这里HealthSet里面新增的广播</span><br><span class="line">		OnOutOfHealth.Broadcast(Instigator, Causer, &amp;Data.EffectSpec, Data.EvaluatedData.Magnitude, HealthBeforeAttributeChange, GetHealth());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Check health again in case an event above changed it.</span><br><span class="line">	bOutOfHealth = (GetHealth() &lt;= 0.0f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但实际的应用，应该还是要追溯到GE。<br>这部分放到后续来看。</p>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>GAS</tag>
        <tag>Lyra</tag>
      </tags>
  </entry>
  <entry>
    <title>UE5.5-Lyra-2-GE</title>
    <url>/UE/Project/Lyra/UE55Lyra2/</url>
    <content><![CDATA[<h1 id="GE"><a href="#GE" class="headerlink" title="GE"></a>GE</h1><p>蓝图创建的GE。<br>基于 GameplayEffectParent_Damage_Basic 来看<br>GE:</p>
<ul>
<li>Gameplay效果<ul>
<li>组件 GEComponents<ul>
<li>包含很多个效果 可以在编辑器中细看</li>
</ul>
</li>
<li>修饰符 Modifiers</li>
<li>执行 Executions</li>
</ul>
</li>
<li>Gameplay Cue</li>
</ul>
<h2 id="GE的执行流程"><a href="#GE的执行流程" class="headerlink" title="GE的执行流程"></a>GE的执行流程</h2><p>以GA的ApplyCost为例子：</p>
<p>GA:ApplyGameplayEffectToOwner<br>↓<br>GA:ApplyGameplayEffectSpecToOwner<br>↓<br>ASC:ApplyGameplayEffectSpecToSelf</p>
<p>到这里可以分为两条路线了，一条是即刻执行的GE，Instant类型。第二种是有持续时间的GE（包括永久）。对于后者，会生成FActiveGameplayEffect。</p>
<p>在ASC:ApplyGameplayEffectSpecToSelf中就有两个关键函数了：</p>
<ul>
<li>持续类型的 由ASC的FActiveGameplayEffectContainer调用ApplyGameplayEffectSpec处理</li>
<li>Intant类型 ASC:ExecuteGameplayEffect</li>
</ul>
<p>ASC:ExecuteGameplayEffect<br>↓<br>由ASC的FActiveGameplayEffectContainer调用ExecuteActiveEffectsFrom。</p>
<p>虽然Instant类型，并不会生成FActiveGameplayEffect，可以认为是不会暴露给外部的，但执行接口可以一致。</p>
<p>ActiveGEContainer:ExecuteActiveEffectsFrom<br>↓<br>[一些关键函数]<br>GESpec:CalculateModifierMagnitudes</p>
<p>执行GE的Modifiers</p>
<ul>
<li>InternalExecuteMod</li>
</ul>
<p>执行各个Executions</p>
<ul>
<li>Execution:Execute(子类还是Execute_Implementation)</li>
<li>执行Execute内部生成的Modifiers<ul>
<li>InternalExecuteMod</li>
</ul>
</li>
</ul>
<p>↓<br>ActiveGEContainer:InternalExecuteMod<br>↓<br>ActiveGEContainer:ApplyModToAttribute<br>↓<br>ActiveGEContainer:SetAttributeBaseValue [更新BaseValue与CurrentValue]</p>
<h2 id="Execution"><a href="#Execution" class="headerlink" title="Execution"></a>Execution</h2><h3 id="Execution-LyraDamageExecution"><a href="#Execution-LyraDamageExecution" class="headerlink" title="Execution - LyraDamageExecution"></a>Execution - LyraDamageExecution</h3><p>继承链条：<br>UGameplayEffectCalculation<br>↓<br>UGameplayEffectExecutionCalculation<br>↓<br>ULyraDamageExecution</p>
<h4 id="GameplayEffectExecutionCalculation"><a href="#GameplayEffectExecutionCalculation" class="headerlink" title="GameplayEffectExecutionCalculation"></a>GameplayEffectExecutionCalculation</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关键函数</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Called whenever the owning gameplay effect is executed. Allowed to do essentially whatever is desired, including generating new</span></span><br><span class="line"><span class="comment">    * modifiers to instantly execute as well.</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * @note: Native subclasses should override the auto-generated Execute_Implementation function and NOT this one.</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * @param ExecutionParams		Parameters for the custom execution calculation</span></span><br><span class="line"><span class="comment">    * @param OutExecutionOutput	[OUT] Output data populated by the execution detailing further behavior or results of the execution</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintNativeEvent, Category=<span class="string">&quot;Calculation&quot;</span>)</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Execute</span><span class="params">(<span class="type">const</span> FGameplayEffectCustomExecutionParameters&amp; ExecutionParams, FGameplayEffectCustomExecutionOutput&amp; OutExecutionOutput)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>然后看到Lyra派生的伤害Execution:</p>
<h4 id="LyraDamageExecution"><a href="#LyraDamageExecution" class="headerlink" title="LyraDamageExecution"></a>LyraDamageExecution</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义Capture相关内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FDamageStatics</span></span><br><span class="line">&#123;</span><br><span class="line">    FGameplayEffectAttributeCaptureDefinition BaseDamageDef;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FDamageStatics</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//CaptureSource有两种： Source 与 Target</span></span><br><span class="line">        <span class="comment">//对应GE的Caster与Recipient</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定捕获属性集的Damage</span></span><br><span class="line">        BaseDamageDef = <span class="built_in">FGameplayEffectAttributeCaptureDefinition</span>(ULyraCombatSet::<span class="built_in">GetBaseDamageAttribute</span>(), EGameplayEffectAttributeCaptureSource::Source, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供单例模式访问</span></span><br><span class="line"><span class="function"><span class="type">static</span> FDamageStatics&amp; <span class="title">DamageStatics</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> FDamageStatics Statics;</span><br><span class="line">    <span class="keyword">return</span> Statics;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//属性Capture - &quot;Attributes to capture that are relevant to the calculation&quot;</span></span><br><span class="line"><span class="comment">//这里的Capture定义了Execution的Modifier支持数据有哪些。算比较重要的一点。</span></span><br><span class="line"><span class="comment">//如果没有添加对应的捕获属性，在编辑器视图看不到Execution的Modifiers。</span></span><br><span class="line">ULyraDamageExecution::<span class="built_in">ULyraDamageExecution</span>()</span><br><span class="line">&#123;</span><br><span class="line">    RelevantAttributesToCapture.<span class="built_in">Add</span>(<span class="built_in">DamageStatics</span>().BaseDamageDef);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ULyraDamageExecution::Execute_Implementation</span><span class="params">(<span class="type">const</span> FGameplayEffectCustomExecutionParameters&amp; ExecutionParams, FGameplayEffectCustomExecutionOutput&amp; OutExecutionOutput)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WITH_SERVER_CODE</span></span><br><span class="line">    <span class="type">const</span> FGameplayEffectSpec&amp; Spec = ExecutionParams.<span class="built_in">GetOwningSpec</span>();</span><br><span class="line">    FLyraGameplayEffectContext* TypedContext = FLyraGameplayEffectContext::<span class="built_in">ExtractEffectContext</span>(Spec.<span class="built_in">GetContext</span>());</span><br><span class="line">    <span class="built_in">check</span>(TypedContext);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> FGameplayTagContainer* SourceTags = Spec.CapturedSourceTags.<span class="built_in">GetAggregatedTags</span>();</span><br><span class="line">    <span class="type">const</span> FGameplayTagContainer* TargetTags = Spec.CapturedTargetTags.<span class="built_in">GetAggregatedTags</span>();</span><br><span class="line"></span><br><span class="line">    FAggregatorEvaluateParameters EvaluateParameters;</span><br><span class="line">    EvaluateParameters.SourceTags = SourceTags;</span><br><span class="line">    EvaluateParameters.TargetTags = TargetTags;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> BaseDamage = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="comment">//这里获取Execution定义的Modifier计算后的目标属性值</span></span><br><span class="line">    ExecutionParams.<span class="built_in">AttemptCalculateCapturedAttributeMagnitude</span>(<span class="built_in">DamageStatics</span>().BaseDamageDef, EvaluateParameters, BaseDamage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面主要处理伤害的额外计算</span></span><br><span class="line">    <span class="comment">//如距离 队伍 判定等</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> AActor* EffectCauser = TypedContext-&gt;<span class="built_in">GetEffectCauser</span>();</span><br><span class="line">    <span class="type">const</span> FHitResult* HitActorResult = TypedContext-&gt;<span class="built_in">GetHitResult</span>();</span><br><span class="line"></span><br><span class="line">    AActor* HitActor = <span class="literal">nullptr</span>;</span><br><span class="line">    FVector ImpactLocation = FVector::ZeroVector;</span><br><span class="line">    FVector ImpactNormal = FVector::ZeroVector;</span><br><span class="line">    FVector StartTrace = FVector::ZeroVector;</span><br><span class="line">    FVector EndTrace = FVector::ZeroVector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculation of hit actor, surface, zone, and distance all rely on whether the calculation has a hit result or not.</span></span><br><span class="line">    <span class="comment">// Effects just being added directly w/o having been targeted will always come in without a hit result, which must default</span></span><br><span class="line">    <span class="comment">// to some fallback information.</span></span><br><span class="line">    <span class="keyword">if</span> (HitActorResult)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> FHitResult&amp; CurHitResult = *HitActorResult;</span><br><span class="line">        HitActor = CurHitResult.HitObjectHandle.<span class="built_in">FetchActor</span>();</span><br><span class="line">        <span class="keyword">if</span> (HitActor)</span><br><span class="line">        &#123;</span><br><span class="line">            ImpactLocation = CurHitResult.ImpactPoint;</span><br><span class="line">            ImpactNormal = CurHitResult.ImpactNormal;</span><br><span class="line">            StartTrace = CurHitResult.TraceStart;</span><br><span class="line">            EndTrace = CurHitResult.TraceEnd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle case of no hit result or hit result not actually returning an actor</span></span><br><span class="line">    UAbilitySystemComponent* TargetAbilitySystemComponent = ExecutionParams.<span class="built_in">GetTargetAbilitySystemComponent</span>();</span><br><span class="line">    <span class="keyword">if</span> (!HitActor)</span><br><span class="line">    &#123;</span><br><span class="line">        HitActor = TargetAbilitySystemComponent ? TargetAbilitySystemComponent-&gt;<span class="built_in">GetAvatarActor_Direct</span>() : <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (HitActor)</span><br><span class="line">        &#123;</span><br><span class="line">            ImpactLocation = HitActor-&gt;<span class="built_in">GetActorLocation</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply rules for team damage/self damage/etc...</span></span><br><span class="line">    <span class="type">float</span> DamageInteractionAllowedMultiplier = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">if</span> (HitActor)</span><br><span class="line">    &#123;</span><br><span class="line">        ULyraTeamSubsystem* TeamSubsystem = HitActor-&gt;<span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetSubsystem</span>&lt;ULyraTeamSubsystem&gt;();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ensure</span>(TeamSubsystem))</span><br><span class="line">        &#123;</span><br><span class="line">            DamageInteractionAllowedMultiplier = TeamSubsystem-&gt;<span class="built_in">CanCauseDamage</span>(EffectCauser, HitActor) ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine distance</span></span><br><span class="line">    <span class="type">double</span> Distance = WORLD_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TypedContext-&gt;<span class="built_in">HasOrigin</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        Distance = FVector::<span class="built_in">Dist</span>(TypedContext-&gt;<span class="built_in">GetOrigin</span>(), ImpactLocation);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (EffectCauser)</span><br><span class="line">    &#123;</span><br><span class="line">        Distance = FVector::<span class="built_in">Dist</span>(EffectCauser-&gt;<span class="built_in">GetActorLocation</span>(), ImpactLocation);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">UE_LOG</span>(LogLyraAbilitySystem, Error, <span class="built_in">TEXT</span>(<span class="string">&quot;Damage Calculation cannot deduce a source location for damage coming from %s; Falling back to WORLD_MAX dist!&quot;</span>), *<span class="built_in">GetPathNameSafe</span>(Spec.Def));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply ability source modifiers</span></span><br><span class="line">    <span class="type">float</span> PhysicalMaterialAttenuation = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="type">float</span> DistanceAttenuation = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">const</span> ILyraAbilitySourceInterface* AbilitySource = TypedContext-&gt;<span class="built_in">GetAbilitySource</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">const</span> UPhysicalMaterial* PhysMat = TypedContext-&gt;<span class="built_in">GetPhysicalMaterial</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            PhysicalMaterialAttenuation = AbilitySource-&gt;<span class="built_in">GetPhysicalMaterialAttenuation</span>(PhysMat, SourceTags, TargetTags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DistanceAttenuation = AbilitySource-&gt;<span class="built_in">GetDistanceAttenuation</span>(Distance, SourceTags, TargetTags);</span><br><span class="line">    &#125;</span><br><span class="line">    DistanceAttenuation = FMath::<span class="built_in">Max</span>(DistanceAttenuation, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clamping is done when damage is converted to -health</span></span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> DamageDone = FMath::<span class="built_in">Max</span>(BaseDamage * DistanceAttenuation * PhysicalMaterialAttenuation * DamageInteractionAllowedMultiplier, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[关键逻辑]处理实际的伤害值 - 通过添加Modifier的方式实现伤害计算</span></span><br><span class="line">    <span class="keyword">if</span> (DamageDone &gt; <span class="number">0.0f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Apply a damage modifier, this gets turned into - health on the target</span></span><br><span class="line">        OutExecutionOutput.<span class="built_in">AddOutputModifier</span>(<span class="built_in">FGameplayModifierEvaluatedData</span>(ULyraHealthSet::<span class="built_in">GetDamageAttribute</span>(), EGameplayModOp::Additive, DamageDone));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// #if WITH_SERVER_CODE</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>实际上，伤害也可以直接通过GE的Modifiers来直接处理。<br>Execution提供了自定义的伤害计算方式，基于捕获的属性来计算伤害，以及自定义需求。如Lyra中的距离计算、爆头等等。<br>Lyra中的伤害： ULyraHealthSet - Damage,使用了宏来禁止直接在GE中使用Modifier修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Incoming damage. This is mapped directly to -Health</span><br><span class="line">UPROPERTY(BlueprintReadOnly, Category=&quot;Lyra|Health&quot;, Meta=(HideFromModifiers, AllowPrivateAccess=true))</span><br><span class="line">FGameplayAttributeData Damage;</span><br></pre></td></tr></table></figure>
<p>并自定义了伤害计算函数ULyraDamageExecution，捕获[Source]玩家的基础伤害值来做。</p>
<p>考虑到如果不需要做额外值处理，应该是可以直接从ASC拿属性去处理的。这里自己编写了不使用Capture方式来处理属性的计算：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前面代码略</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> BaseDamage = <span class="number">0.0f</span>;</span><br><span class="line"><span class="comment">//ExecutionParams.AttemptCalculateCapturedAttributeMagnitude(DamageStatics().BaseDamageDef, EvaluateParameters, BaseDamage);</span></span><br><span class="line">ULyraAbilitySystemComponent*sourceASC = <span class="built_in">Cast</span>&lt;ULyraAbilitySystemComponent&gt;(Spec.<span class="built_in">GetEffectContext</span>().<span class="built_in">GetOriginalInstigatorAbilitySystemComponent</span>());</span><br><span class="line"><span class="keyword">if</span> (sourceASC)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    BaseDamage = sourceASC-&gt;<span class="built_in">GetGameplayAttributeValue</span>(ULyraCombatSet::<span class="built_in">GetBaseDamageAttribute</span>(),found);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后面代码略</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>GAS</tag>
        <tag>Lyra</tag>
      </tags>
  </entry>
  <entry>
    <title>UE5.5-Lyra-3-GATask</title>
    <url>/UE/Project/Lyra/UE55Lyra3/</url>
    <content><![CDATA[<h1 id="GamplayAbilityTask"><a href="#GamplayAbilityTask" class="headerlink" title="GamplayAbilityTask"></a>GamplayAbilityTask</h1><h2 id="基础AbilityTask"><a href="#基础AbilityTask" class="headerlink" title="基础AbilityTask"></a>基础AbilityTask</h2><ul>
<li>异步任务</li>
<li>开始并等待结束&#x2F;打断</li>
<li>部分实现需要关注[K2Node_LatentAbilityCall]</li>
</ul>
<h3 id="基础逻辑"><a href="#基础逻辑" class="headerlink" title="基础逻辑"></a>基础逻辑</h3><ul>
<li>定义动态多播委托，并声明为BlueprintAssignable</li>
<li>声明静态工厂函数用于创建AbilityTask。由该函数定义输入参数。但是这个不意味着任务开始，不在其中调用广播</li>
<li>实现Activate函数。该函数代表着任务的激活</li>
</ul>
<p>  其他<br>    - OnDestroy记得取消事件的侦听和注册，并调用父类的OnDestroy。</p>
<p>  静态工厂函数的meta声明了meta &#x3D; (xxx前面忽略, BlueprintInternalUseOnly &#x3D; “TRUE”)<br>  实际蓝图的调用走过UK2Node_LatentGameplayTaskCall的ExpandNode.</p>
<h3 id="WaitOverlap"><a href="#WaitOverlap" class="headerlink" title="WaitOverlap"></a>WaitOverlap</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//定义委托</span><br><span class="line">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FWaitOverlapDelegate, const FGameplayAbilityTargetDataHandle&amp;, TargetData);</span><br><span class="line"></span><br><span class="line">class AActor;</span><br><span class="line">class UPrimitiveComponent;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *	Fixme: this is still incomplete and probablyh not what most games want for melee systems.</span><br><span class="line"> *		-Only actually activates on Blocking hits</span><br><span class="line"> *		-Uses first PrimitiveComponent instead of being able to specify arbitrary component.</span><br><span class="line"> */</span><br><span class="line">UCLASS()</span><br><span class="line">class GAMEPLAYABILITIES_API UAbilityTask_WaitOverlap : public UAbilityTask</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_UCLASS_BODY()</span><br><span class="line"></span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FWaitOverlapDelegate	OnOverlap;</span><br><span class="line"></span><br><span class="line">    UFUNCTION()</span><br><span class="line">    void OnHitCallback(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult&amp; Hit);</span><br><span class="line"></span><br><span class="line">    //重写Activate</span><br><span class="line">    virtual void Activate() override;</span><br><span class="line"></span><br><span class="line">    //定义静态工厂函数</span><br><span class="line">    /** Wait until an overlap occurs. This will need to be better fleshed out so we can specify game specific collision requirements */</span><br><span class="line">    UFUNCTION(BlueprintCallable, Category=&quot;Ability|Tasks&quot;, meta = (HidePin = &quot;OwningAbility&quot;, DefaultToSelf = &quot;OwningAbility&quot;, BlueprintInternalUseOnly = &quot;TRUE&quot;))</span><br><span class="line">    static UAbilityTask_WaitOverlap* WaitForOverlap(UGameplayAbility* OwningAbility);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    //重写OnDestory</span><br><span class="line">    virtual void OnDestroy(bool AbilityEnded) override;</span><br><span class="line"></span><br><span class="line">    UPrimitiveComponent* GetComponent();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看到实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line">* 将生成的文件(xxx.Generated.cpp)内联到模块CPP文件中，这样能减少需要解析的头文件数量，从而缩短编译时间。</span><br><span class="line">* #include UE_INLINE_GENERATED_CPP_BY_NAME(CPP纯文件名无后缀)</span><br><span class="line">* 在CPP中使用，一般添加在#include最后部分</span><br><span class="line">*/</span><br><span class="line">//特殊include</span><br><span class="line">#include UE_INLINE_GENERATED_CPP_BY_NAME(AbilityTask_WaitOverlap)</span><br><span class="line"></span><br><span class="line">UAbilityTask_WaitOverlap::UAbilityTask_WaitOverlap(const FObjectInitializer&amp; ObjectInitializer): Super(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//主要的逻辑函数 - 异步逻辑</span><br><span class="line">void UAbilityTask_WaitOverlap::OnHitCallback(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult&amp; Hit)</span><br><span class="line">&#123;</span><br><span class="line">    if(OtherActor)</span><br><span class="line">    &#123;</span><br><span class="line">        // Construct TargetData</span><br><span class="line">        FGameplayAbilityTargetData_SingleTargetHit * TargetData = new FGameplayAbilityTargetData_SingleTargetHit(Hit);</span><br><span class="line"></span><br><span class="line">        // Give it a handle and return</span><br><span class="line">        FGameplayAbilityTargetDataHandle	Handle;</span><br><span class="line">        Handle.Data.Add(TSharedPtr&lt;FGameplayAbilityTargetData&gt;(TargetData));</span><br><span class="line"></span><br><span class="line">        //广播之前需要进行一下有效性检测</span><br><span class="line">        if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">        &#123;</span><br><span class="line">            OnOverlap.Broadcast(Handle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // We are done. Kill us so we don&#x27;t keep getting broadcast messages</span><br><span class="line">        EndTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">*	Need:</span><br><span class="line">*	-Easy way to specify which primitive components should be used for this overlap test</span><br><span class="line">*	-Easy way to specify which types of actors/collision overlaps that we care about/want to block on</span><br><span class="line">*/</span><br><span class="line">//静态工厂函数</span><br><span class="line">UAbilityTask_WaitOverlap* UAbilityTask_WaitOverlap::WaitForOverlap(UGameplayAbility* OwningAbility)</span><br><span class="line">&#123;</span><br><span class="line">    //这里需要注意调用方法为NewAbilityTask</span><br><span class="line">    UAbilityTask_WaitOverlap* MyObj = NewAbilityTask&lt;UAbilityTask_WaitOverlap&gt;(OwningAbility);</span><br><span class="line">    return MyObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_WaitOverlap::Activate()</span><br><span class="line">&#123;</span><br><span class="line">    //这里会做有效性检测</span><br><span class="line">    SetWaitingOnAvatar();</span><br><span class="line"></span><br><span class="line">    UPrimitiveComponent* PrimComponent = GetComponent();</span><br><span class="line">    if (PrimComponent)</span><br><span class="line">    &#123;</span><br><span class="line">        //对动态多播委托添加侦听</span><br><span class="line">        PrimComponent-&gt;OnComponentHit.AddDynamic(this, &amp;UAbilityTask_WaitOverlap::OnHitCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_WaitOverlap::OnDestroy(bool AbilityEnded)</span><br><span class="line">&#123;</span><br><span class="line">    UPrimitiveComponent* PrimComponent = GetComponent();</span><br><span class="line">    if (PrimComponent)</span><br><span class="line">    &#123;</span><br><span class="line">        //移除侦听</span><br><span class="line">        PrimComponent-&gt;OnComponentHit.RemoveDynamic(this, &amp;UAbilityTask_WaitOverlap::OnHitCallback);</span><br><span class="line">    &#125;</span><br><span class="line">    //父类OnDestroy</span><br><span class="line">    Super::OnDestroy(AbilityEnded);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UPrimitiveComponent* UAbilityTask_WaitOverlap::GetComponent()</span><br><span class="line">&#123;</span><br><span class="line">    // TEMP - we are just using root component&#x27;s collision. A real system will need more data to specify which component to use</span><br><span class="line">    UPrimitiveComponent * PrimComponent = nullptr;</span><br><span class="line">    AActor* ActorOwner = GetAvatarActor();</span><br><span class="line">    if (ActorOwner)</span><br><span class="line">    &#123;</span><br><span class="line">        PrimComponent = Cast&lt;UPrimitiveComponent&gt;(ActorOwner-&gt;GetRootComponent());</span><br><span class="line">        if (!PrimComponent)</span><br><span class="line">        &#123;</span><br><span class="line">            PrimComponent = ActorOwner-&gt;FindComponentByClass&lt;UPrimitiveComponent&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return PrimComponent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SpawnActor类型的AbilityTask"><a href="#SpawnActor类型的AbilityTask" class="headerlink" title="SpawnActor类型的AbilityTask"></a>SpawnActor类型的AbilityTask</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">*	--------------------------------------</span><br><span class="line">*	</span><br><span class="line">*	We have additional support for AbilityTasks that want to spawn actors. Though this could be accomplished in an Activate() function, it would not be</span><br><span class="line">*	possible to pass in dynamic &quot;ExposeOnSpawn&quot; actor properties. This is a powerful feature of blueprints, in order to support this, you need to implement </span><br><span class="line">*	a different step 3:</span><br><span class="line">*	</span><br><span class="line">*	Instead of an Activate() function, you should implement a BeginSpawningActor() and FinishSpawningActor() function.</span><br><span class="line">*	</span><br><span class="line">*	BeginSpawningActor() must take in a TSubclassOf&lt;YourActorClassToSpawn&gt; parameters named &#x27;Class&#x27;. It must also have a out reference parameters of type </span><br><span class="line">*	YourActorClassToSpawn*&amp; named SpawnedActor. This function is allowed to decide whether it wants to spawn the actor or not (useful if wishing to</span><br><span class="line">*	predicate actor spawning on network authority).</span><br><span class="line">*	</span><br><span class="line">*	BeginSpawningActor() can instantiate an actor with SpawnActorDeferred. This is important, otherwise the UCS will run before spawn parameters are set.</span><br><span class="line">*	BeginSpawningActor() should also set the SpawnedActor parameter to the actor it spawned.</span><br><span class="line">*	</span><br><span class="line">*	[Next, the generated byte code will set the expose on spawn parameters to whatever the user has set]</span><br><span class="line">*	</span><br><span class="line">*	If you spawned something, FinishSpawningActor() will be called and pass in the same actor that was just spawned. You MUST call ExecuteConstruction + PostActorConstruction</span><br><span class="line">*	on this actor!</span><br><span class="line">*	</span><br><span class="line">*	This is a lot of steps but in general, AbilityTask_SpawnActor() gives a clear, minimal example.</span><br><span class="line">*	</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>相较于Activate,需要实现BeginSpawningActor与FinishSpawningActor两个函数。<br>具体的逻辑要往上追溯UK2Node_LatentGameplayTaskCall与UK2Node_LatentAbilityCall。</p>
<h3 id="SpawnActor"><a href="#SpawnActor" class="headerlink" title="SpawnActor"></a>SpawnActor</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//动态多播委托</span><br><span class="line">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FGameplayTaskSpawnActorDelegate, AActor*, SpawnedActor);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *	Convenience task for spawning actors (optionally limiting the spawning to the network authority). If not the net authority, we will not spawn </span><br><span class="line"> *	and Success will not be called. The nice thing this adds is the ability to modify expose on spawn properties while also implicitly checking </span><br><span class="line"> *	network role before spawning.</span><br><span class="line"> *</span><br><span class="line"> *	Though this task doesn&#x27;t do much - games can implement similar tasks that carry out game specific rules. For example a &#x27;SpawnProjectile&#x27;</span><br><span class="line"> *	task that limits the available classes to the games projectile class, and that does game specific stuff on spawn (for example, determining</span><br><span class="line"> *	firing position from a weapon attachment).</span><br><span class="line"> *	</span><br><span class="line"> *	Long term we can also use this task as a sync point. If the executing client could wait execution until the server creates and replicates the </span><br><span class="line"> *	actor down to it. We could potentially also use this to do predictive actor spawning / reconciliation.</span><br><span class="line"> --“作为网络同步锚点，等待服务器生成并复制Actor到客户端后才继续执行。未来还可以用于预测性Actor生成与协调”</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">UCLASS(MinimalAPI)</span><br><span class="line">class UGameplayTask_SpawnActor : public UGameplayTask</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line">public:</span><br><span class="line">    //声明委托</span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FGameplayTaskSpawnActorDelegate	Success;</span><br><span class="line"></span><br><span class="line">    /** Called when we can&#x27;t spawn: on clients or potentially on server if they fail to spawn (rare) */</span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FGameplayTaskSpawnActorDelegate	DidNotSpawn;</span><br><span class="line"></span><br><span class="line">    //静态工厂函数</span><br><span class="line">    /** Spawn new Actor on the network authority (server) */</span><br><span class="line">    UFUNCTION(BlueprintCallable, Category = &quot;GameplayTasks&quot;, meta = (DisplayName=&quot;Spawn Actor for Gameplay Task&quot;, AdvancedDisplay = &quot;TaskOwner, bSpawnOnlyOnAuthority&quot;, DefaultToSelf = &quot;TaskOwner&quot;, BlueprintInternalUseOnly = &quot;TRUE&quot;))</span><br><span class="line">    static UGameplayTask_SpawnActor* SpawnActor(TScriptInterface&lt;IGameplayTaskOwnerInterface&gt; TaskOwner, FVector SpawnLocation, FRotator SpawnRotation, TSubclassOf&lt;AActor&gt; Class, bool bSpawnOnlyOnAuthority = false);</span><br><span class="line"></span><br><span class="line">    //重要函数1</span><br><span class="line">    UFUNCTION(BlueprintCallable, meta = (WorldContext=&quot;WorldContextObject&quot;, BlueprintInternalUseOnly = &quot;true&quot;), Category = &quot;GameplayTasks&quot;)</span><br><span class="line">    virtual bool BeginSpawningActor(UObject* WorldContextObject, AActor*&amp; SpawnedActor);</span><br><span class="line"></span><br><span class="line">    //重要函数2</span><br><span class="line">    UFUNCTION(BlueprintCallable, meta = (WorldContext=&quot;WorldContextObject&quot;, BlueprintInternalUseOnly = &quot;true&quot;), Category = &quot;GameplayTasks&quot;)</span><br><span class="line">    virtual void FinishSpawningActor(UObject* WorldContextObject, AActor* SpawnedActor);</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    FVector CachedSpawnLocation;</span><br><span class="line">    FRotator CachedSpawnRotation;</span><br><span class="line">    UPROPERTY()</span><br><span class="line">    TSubclassOf&lt;AActor&gt; ClassToSpawn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>来看到实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include UE_INLINE_GENERATED_CPP_BY_NAME(AbilityTask_SpawnActor)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UAbilityTask_SpawnActor::UAbilityTask_SpawnActor(const FObjectInitializer&amp; ObjectInitializer)</span><br><span class="line">	: Super(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//静态工厂函数</span><br><span class="line">UAbilityTask_SpawnActor* UAbilityTask_SpawnActor::SpawnActor(UGameplayAbility* OwningAbility, FGameplayAbilityTargetDataHandle TargetData, TSubclassOf&lt;AActor&gt; InClass)</span><br><span class="line">&#123;</span><br><span class="line">    //定义了目标类 - InClass</span><br><span class="line">    //定义了目标参数 - TargetData</span><br><span class="line"></span><br><span class="line">    //使用NewAbilityTask创建对象</span><br><span class="line">    UAbilityTask_SpawnActor* MyObj = NewAbilityTask&lt;UAbilityTask_SpawnActor&gt;(OwningAbility);</span><br><span class="line">    //变量赋值 - 使用MoveTemp的方式</span><br><span class="line">    MyObj-&gt;CachedTargetDataHandle = MoveTemp(TargetData);</span><br><span class="line">    return MyObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ---------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">bool UAbilityTask_SpawnActor::BeginSpawningActor(UGameplayAbility* OwningAbility, FGameplayAbilityTargetDataHandle TargetData, TSubclassOf&lt;AActor&gt; InClass, AActor*&amp; SpawnedActor)</span><br><span class="line">&#123;</span><br><span class="line">    //ShouldBroadcastAbilityTaskDelegates 有效性检测</span><br><span class="line">    if (Ability &amp;&amp; Ability-&gt;GetCurrentActorInfo()-&gt;IsNetAuthority() &amp;&amp; ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">    &#123;</span><br><span class="line">        UWorld* const World = GEngine-&gt;GetWorldFromContextObject(OwningAbility, EGetWorldErrorMode::LogAndReturnNull);</span><br><span class="line">        if (World)</span><br><span class="line">        &#123;</span><br><span class="line">            //生成对象</span><br><span class="line">            //这里SpawnActorDeferred内部调用UWorld::SpawnActor</span><br><span class="line">            SpawnedActor = World-&gt;SpawnActorDeferred&lt;AActor&gt;(InClass, FTransform::Identity, NULL, NULL, ESpawnActorCollisionHandlingMethod::AlwaysSpawn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (SpawnedActor == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        //有效性检测</span><br><span class="line">        if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">        &#123;</span><br><span class="line">            DidNotSpawn.Broadcast(nullptr);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_SpawnActor::FinishSpawningActor(UGameplayAbility* OwningAbility, FGameplayAbilityTargetDataHandle TargetData, AActor* SpawnedActor)</span><br><span class="line">&#123;</span><br><span class="line">    if (SpawnedActor)</span><br><span class="line">    &#123;</span><br><span class="line">        //设置参数</span><br><span class="line">        bool bTransformSet = false;</span><br><span class="line">        FTransform SpawnTransform;</span><br><span class="line">        if (FGameplayAbilityTargetData* LocationData = CachedTargetDataHandle.Get(0))		//Hardcode to use data 0. It&#x27;s OK if data isn&#x27;t useful/valid.</span><br><span class="line">        &#123;</span><br><span class="line">            //Set location. Rotation is unaffected.</span><br><span class="line">            if (LocationData-&gt;HasHitResult())</span><br><span class="line">            &#123;</span><br><span class="line">                SpawnTransform.SetLocation(LocationData-&gt;GetHitResult()-&gt;Location);</span><br><span class="line">                bTransformSet = true;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (LocationData-&gt;HasEndPoint())</span><br><span class="line">            &#123;</span><br><span class="line">                SpawnTransform = LocationData-&gt;GetEndPointTransform();</span><br><span class="line">                bTransformSet = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!bTransformSet)</span><br><span class="line">        &#123;</span><br><span class="line">            if (UAbilitySystemComponent* ASC = AbilitySystemComponent.Get())</span><br><span class="line">            &#123;</span><br><span class="line">                SpawnTransform = ASC-&gt;GetOwner()-&gt;GetTransform();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //注意调用FinishSpawning！</span><br><span class="line">        //AActor::FinishSpawning内部处理ExecuteConstruction 与 PostActorConstruction</span><br><span class="line">        /** Called to finish the spawning process, generally in the case of deferred spawning */</span><br><span class="line">        SpawnedActor-&gt;FinishSpawning(SpawnTransform);</span><br><span class="line"></span><br><span class="line">        //有效性检测</span><br><span class="line">        if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">        &#123;</span><br><span class="line">            Success.Broadcast(SpawnedActor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EndTask();</span><br><span class="line">&#125;</span><br><span class="line">// ---------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">//没有对委托做单独注册，也不需要重写OnDestroy了</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="WaitTargetData"><a href="#WaitTargetData" class="headerlink" title="WaitTargetData"></a>WaitTargetData</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">//声明动态多播委托</span><br><span class="line">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FWaitTargetDataDelegate, const FGameplayAbilityTargetDataHandle&amp;, Data);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Wait for targeting actor (spawned from parameter) to provide data. Can be set not to end upon outputting data. Can be ended by task name.</span><br><span class="line"> *</span><br><span class="line"> * WARNING: These actors are spawned once per ability activation and in their default form are not very efficient</span><br><span class="line"> * For most games you will need to subclass and heavily modify this actor, or you will want to implement similar functions in a game-specific actor or blueprint to avoid actor spawn costs</span><br><span class="line"> * This task is not well tested by internal games, but it is a useful class to look at to learn how target replication occurs</span><br><span class="line"> */</span><br><span class="line">UCLASS()</span><br><span class="line">class GAMEPLAYABILITIES_API UAbilityTask_WaitTargetData: public UAbilityTask</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_UCLASS_BODY()</span><br><span class="line"></span><br><span class="line">    //声明委托变量</span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FWaitTargetDataDelegate	ValidData;</span><br><span class="line"></span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FWaitTargetDataDelegate	Cancelled;</span><br><span class="line"></span><br><span class="line">    //复制回调</span><br><span class="line">    UFUNCTION()</span><br><span class="line">    virtual void OnTargetDataReplicatedCallback(const FGameplayAbilityTargetDataHandle&amp; Data, FGameplayTag ActivationTag);</span><br><span class="line"></span><br><span class="line">    UFUNCTION()</span><br><span class="line">    virtual void OnTargetDataReplicatedCancelledCallback();</span><br><span class="line"></span><br><span class="line">    UFUNCTION()</span><br><span class="line">    virtual void OnTargetDataReadyCallback(const FGameplayAbilityTargetDataHandle&amp; Data);</span><br><span class="line"></span><br><span class="line">    UFUNCTION()</span><br><span class="line">    virtual void OnTargetDataCancelledCallback(const FGameplayAbilityTargetDataHandle&amp; Data);</span><br><span class="line"></span><br><span class="line">    //静态工厂函数</span><br><span class="line">    //这里有两个工厂函数。</span><br><span class="line">    //一个使用目标类，并由内部处理目标类的对象生成。并使用BeginSpawningActor与FinishSpawningActor。</span><br><span class="line">    //一个使用已有对象。并使用Activate。</span><br><span class="line">    /** Spawns target actor and waits for it to return valid data or to be canceled. */</span><br><span class="line">    UFUNCTION(BlueprintCallable, meta=(HidePin = &quot;OwningAbility&quot;, DefaultToSelf = &quot;OwningAbility&quot;, BlueprintInternalUseOnly = &quot;true&quot;, HideSpawnParms=&quot;Instigator&quot;), Category=&quot;Ability|Tasks&quot;)</span><br><span class="line">    static UAbilityTask_WaitTargetData* WaitTargetData(UGameplayAbility* OwningAbility, FName TaskInstanceName, TEnumAsByte&lt;EGameplayTargetingConfirmation::Type&gt; ConfirmationType, TSubclassOf&lt;AGameplayAbilityTargetActor&gt; Class);</span><br><span class="line"></span><br><span class="line">    /** Uses specified target actor and waits for it to return valid data or to be canceled. */</span><br><span class="line">    UFUNCTION(BlueprintCallable, meta = (HidePin = &quot;OwningAbility&quot;, DefaultToSelf = &quot;OwningAbility&quot;, BlueprintInternalUseOnly = &quot;true&quot;, HideSpawnParms = &quot;Instigator&quot;), Category = &quot;Ability|Tasks&quot;)</span><br><span class="line">    static UAbilityTask_WaitTargetData* WaitTargetDataUsingActor(UGameplayAbility* OwningAbility, FName TaskInstanceName, TEnumAsByte&lt;EGameplayTargetingConfirmation::Type&gt; ConfirmationType, AGameplayAbilityTargetActor* TargetActor);</span><br><span class="line"></span><br><span class="line">    //重写的Activate函数</span><br><span class="line">    virtual void Activate() override;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //由于要生成对象 声明BeginSpawningActor与FinishSpawningActor。</span><br><span class="line">    //这里和SpawnActor的参数还不太一样 可以再研究</span><br><span class="line">    UFUNCTION(BlueprintCallable, meta = (HidePin = &quot;OwningAbility&quot;, DefaultToSelf = &quot;OwningAbility&quot;, BlueprintInternalUseOnly = &quot;true&quot;), Category = &quot;Abilities&quot;)</span><br><span class="line">    virtual bool BeginSpawningActor(UGameplayAbility* OwningAbility, TSubclassOf&lt;AGameplayAbilityTargetActor&gt; Class, AGameplayAbilityTargetActor*&amp; SpawnedActor);</span><br><span class="line"></span><br><span class="line">    UFUNCTION(BlueprintCallable, meta = (HidePin = &quot;OwningAbility&quot;, DefaultToSelf = &quot;OwningAbility&quot;, BlueprintInternalUseOnly = &quot;true&quot;), Category = &quot;Abilities&quot;)</span><br><span class="line">    virtual void FinishSpawningActor(UGameplayAbility* OwningAbility, AGameplayAbilityTargetActor* SpawnedActor);</span><br><span class="line"></span><br><span class="line">    /** Called when the ability is asked to confirm from an outside node. What this means depends on the individual task. By default, this does nothing other than ending if bEndTask is true. */</span><br><span class="line">    virtual void ExternalConfirm(bool bEndTask) override;</span><br><span class="line"></span><br><span class="line">    /** Called when the ability is asked to cancel from an outside node. What this means depends on the individual task. By default, this does nothing other than ending the task. */</span><br><span class="line">    virtual void ExternalCancel() override;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line"></span><br><span class="line">    virtual bool ShouldSpawnTargetActor() const;</span><br><span class="line">    virtual void InitializeTargetActor(AGameplayAbilityTargetActor* SpawnedActor) const;</span><br><span class="line">    virtual void FinalizeTargetActor(AGameplayAbilityTargetActor* SpawnedActor) const;</span><br><span class="line"></span><br><span class="line">    virtual void RegisterTargetDataCallbacks();</span><br><span class="line"></span><br><span class="line">    virtual void OnDestroy(bool AbilityEnded) override;</span><br><span class="line"></span><br><span class="line">    virtual bool ShouldReplicateDataToServer() const;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line"></span><br><span class="line">    UPROPERTY()</span><br><span class="line">    TSubclassOf&lt;AGameplayAbilityTargetActor&gt; TargetClass;</span><br><span class="line"></span><br><span class="line">    /** The TargetActor that we spawned */</span><br><span class="line">    UPROPERTY()</span><br><span class="line">    TObjectPtr&lt;AGameplayAbilityTargetActor&gt; TargetActor;</span><br><span class="line"></span><br><span class="line">    TEnumAsByte&lt;EGameplayTargetingConfirmation::Type&gt; ConfirmationType;</span><br><span class="line"></span><br><span class="line">    FDelegateHandle OnTargetDataReplicatedCallbackDelegateHandle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">*	Requirements for using Begin/Finish SpawningActor functionality:</span><br><span class="line">*		-Have a parameters named &#x27;Class&#x27; in your Proxy factor function (E.g., WaitTargetdata)</span><br><span class="line">*		-Have a function named BeginSpawningActor w/ the same Class parameter</span><br><span class="line">*			-This function should spawn the actor with SpawnActorDeferred and return true/false if it spawned something.</span><br><span class="line">*		-Have a function named FinishSpawningActor w/ an AActor* of the class you spawned</span><br><span class="line">*			-This function *must* call ExecuteConstruction + PostActorConstruction</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>看到实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include UE_INLINE_GENERATED_CPP_BY_NAME(AbilityTask_WaitTargetData)</span><br><span class="line"></span><br><span class="line">UAbilityTask_WaitTargetData::UAbilityTask_WaitTargetData(const FObjectInitializer&amp; ObjectInitializer)</span><br><span class="line">	: Super(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//静态工厂函数</span><br><span class="line">UAbilityTask_WaitTargetData* UAbilityTask_WaitTargetData::WaitTargetData(UGameplayAbility* OwningAbility, FName TaskInstanceName, TEnumAsByte&lt;EGameplayTargetingConfirmation::Type&gt; ConfirmationType, TSubclassOf&lt;AGameplayAbilityTargetActor&gt; InTargetClass)</span><br><span class="line">&#123;</span><br><span class="line">    //NewAbilityTask创建对象</span><br><span class="line">    UAbilityTask_WaitTargetData* MyObj = NewAbilityTask&lt;UAbilityTask_WaitTargetData&gt;(OwningAbility, TaskInstanceName);		//Register for task list here, providing a given FName as a key</span><br><span class="line">    //设置对象的参数</span><br><span class="line">    MyObj-&gt;TargetClass = InTargetClass;</span><br><span class="line">    MyObj-&gt;TargetActor = nullptr;</span><br><span class="line">    MyObj-&gt;ConfirmationType = ConfirmationType;</span><br><span class="line">    return MyObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UAbilityTask_WaitTargetData* UAbilityTask_WaitTargetData::WaitTargetDataUsingActor(UGameplayAbility* OwningAbility, FName TaskInstanceName, TEnumAsByte&lt;EGameplayTargetingConfirmation::Type&gt; ConfirmationType, AGameplayAbilityTargetActor* InTargetActor)</span><br><span class="line">&#123;</span><br><span class="line">    //和上面的一样 不过是用Actor</span><br><span class="line">    UAbilityTask_WaitTargetData* MyObj = NewAbilityTask&lt;UAbilityTask_WaitTargetData&gt;(OwningAbility, TaskInstanceName);		//Register for task list here, providing a given FName as a key</span><br><span class="line">    MyObj-&gt;TargetClass = nullptr;</span><br><span class="line">    MyObj-&gt;TargetActor = InTargetActor;</span><br><span class="line">    MyObj-&gt;ConfirmationType = ConfirmationType;</span><br><span class="line">    return MyObj;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_WaitTargetData::Activate()</span><br><span class="line">&#123;</span><br><span class="line">    //这里是以传入TargetActor的方式来处理的</span><br><span class="line">    // Need to handle case where target actor was passed into task</span><br><span class="line">    if (Ability &amp;&amp; (TargetClass == nullptr))</span><br><span class="line">    &#123;</span><br><span class="line">        if (TargetActor)</span><br><span class="line">        &#123;</span><br><span class="line">            AGameplayAbilityTargetActor* SpawnedActor = TargetActor;</span><br><span class="line">            //获取类</span><br><span class="line">            TargetClass = SpawnedActor-&gt;GetClass();</span><br><span class="line">            //注册回调</span><br><span class="line">            RegisterTargetDataCallbacks();</span><br><span class="line"></span><br><span class="line">            if (!IsValid(this))</span><br><span class="line">            &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (ShouldSpawnTargetActor())</span><br><span class="line">            &#123;   </span><br><span class="line">                //设置PlayerController并注册回调</span><br><span class="line">                InitializeTargetActor(SpawnedActor);</span><br><span class="line">                //ASC设置信息</span><br><span class="line">                FinalizeTargetActor(SpawnedActor);</span><br><span class="line"></span><br><span class="line">                // Note that the call to FinalizeTargetActor, this task could finish and our owning ability may be ended.</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                TargetActor = nullptr;</span><br><span class="line"></span><br><span class="line">                // We may need a better solution here.  We don&#x27;t know the target actor isn&#x27;t needed till after it&#x27;s already been spawned.</span><br><span class="line">                SpawnedActor-&gt;Destroy();</span><br><span class="line">                SpawnedActor = nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            EndTask();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool UAbilityTask_WaitTargetData::BeginSpawningActor(UGameplayAbility* OwningAbility, TSubclassOf&lt;AGameplayAbilityTargetActor&gt; InTargetClass, AGameplayAbilityTargetActor*&amp; SpawnedActor)</span><br><span class="line">&#123;</span><br><span class="line">    SpawnedActor = nullptr;</span><br><span class="line"></span><br><span class="line">    if (Ability)</span><br><span class="line">    &#123;</span><br><span class="line">        if (ShouldSpawnTargetActor())</span><br><span class="line">        &#123;</span><br><span class="line">            UClass* Class = *InTargetClass;</span><br><span class="line">            if (Class != nullptr)</span><br><span class="line">            &#123;</span><br><span class="line">                if (UWorld* World = GEngine-&gt;GetWorldFromContextObject(OwningAbility, EGetWorldErrorMode::LogAndReturnNull))</span><br><span class="line">                &#123;</span><br><span class="line">                    //生成对应的对象</span><br><span class="line">                    SpawnedActor = World-&gt;SpawnActorDeferred&lt;AGameplayAbilityTargetActor&gt;(Class, FTransform::Identity, nullptr, nullptr, ESpawnActorCollisionHandlingMethod::AlwaysSpawn);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (SpawnedActor)</span><br><span class="line">            &#123;</span><br><span class="line">                TargetActor = SpawnedActor;</span><br><span class="line">                //注册回调</span><br><span class="line">                InitializeTargetActor(SpawnedActor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RegisterTargetDataCallbacks();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (SpawnedActor != nullptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_WaitTargetData::FinishSpawningActor(UGameplayAbility* OwningAbility, AGameplayAbilityTargetActor* SpawnedActor)</span><br><span class="line">&#123;</span><br><span class="line">    UAbilitySystemComponent* ASC = AbilitySystemComponent.Get();</span><br><span class="line">    if (ASC &amp;&amp; IsValid(SpawnedActor))</span><br><span class="line">    &#123;</span><br><span class="line">        check(TargetActor == SpawnedActor);</span><br><span class="line"></span><br><span class="line">        const FTransform SpawnTransform = ASC-&gt;GetOwner()-&gt;GetTransform();</span><br><span class="line"></span><br><span class="line">        SpawnedActor-&gt;FinishSpawning(SpawnTransform);</span><br><span class="line"></span><br><span class="line">        FinalizeTargetActor(SpawnedActor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool UAbilityTask_WaitTargetData::ShouldSpawnTargetActor() const</span><br><span class="line">&#123;</span><br><span class="line">    check(TargetClass);</span><br><span class="line">    check(Ability);</span><br><span class="line"></span><br><span class="line">    // Spawn the actor if this is a locally controlled ability (always) or if this is a replicating targeting mode.</span><br><span class="line">    // (E.g., server will spawn this target actor to replicate to all non owning clients)</span><br><span class="line"></span><br><span class="line">    const AGameplayAbilityTargetActor* CDO = CastChecked&lt;AGameplayAbilityTargetActor&gt;(TargetClass-&gt;GetDefaultObject());</span><br><span class="line"></span><br><span class="line">    const bool bReplicates = CDO-&gt;GetIsReplicated();</span><br><span class="line">    const bool bIsLocallyControlled = Ability-&gt;GetCurrentActorInfo()-&gt;IsLocallyControlled();</span><br><span class="line">    const bool bShouldProduceTargetDataOnServer = CDO-&gt;ShouldProduceTargetDataOnServer;</span><br><span class="line"></span><br><span class="line">    return (bReplicates || bIsLocallyControlled || bShouldProduceTargetDataOnServer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_WaitTargetData::InitializeTargetActor(AGameplayAbilityTargetActor* SpawnedActor) const</span><br><span class="line">&#123;</span><br><span class="line">    check(SpawnedActor);</span><br><span class="line">    check(Ability);</span><br><span class="line"></span><br><span class="line">    //设置生成Actor的PlayerController</span><br><span class="line">    SpawnedActor-&gt;PrimaryPC = Ability-&gt;GetCurrentActorInfo()-&gt;PlayerController.Get();</span><br><span class="line"></span><br><span class="line">    //这里见到GameplayAbilityTargetActor</span><br><span class="line">    // If we spawned the target actor, always register the callbacks for when the data is ready.</span><br><span class="line">    SpawnedActor-&gt;TargetDataReadyDelegate.AddUObject(const_cast&lt;UAbilityTask_WaitTargetData*&gt;(this), &amp;UAbilityTask_WaitTargetData::OnTargetDataReadyCallback);</span><br><span class="line">    SpawnedActor-&gt;CanceledDelegate.AddUObject(const_cast&lt;UAbilityTask_WaitTargetData*&gt;(this), &amp;UAbilityTask_WaitTargetData::OnTargetDataCancelledCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_WaitTargetData::FinalizeTargetActor(AGameplayAbilityTargetActor* SpawnedActor) const</span><br><span class="line">&#123;</span><br><span class="line">    check(SpawnedActor);</span><br><span class="line">    check(Ability);</span><br><span class="line"></span><br><span class="line">    if (UAbilitySystemComponent* ASC = AbilitySystemComponent.Get())</span><br><span class="line">    &#123;</span><br><span class="line">        // User ability activation is inhibited while this is active</span><br><span class="line">        ASC-&gt;SpawnedTargetActors.Push(SpawnedActor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SpawnedActor-&gt;StartTargeting(Ability);</span><br><span class="line"></span><br><span class="line">    if (SpawnedActor-&gt;ShouldProduceTargetData())</span><br><span class="line">    &#123;   </span><br><span class="line">        //不需要客户端提供信息的情况</span><br><span class="line">        </span><br><span class="line">        // If instant confirm, then stop targeting immediately.</span><br><span class="line">        // Note this is kind of bad: we should be able to just call a static func on the CDO to do this. </span><br><span class="line">        // But then we wouldn&#x27;t get to set ExposeOnSpawnParameters.</span><br><span class="line">        if (ConfirmationType == EGameplayTargetingConfirmation::Instant)</span><br><span class="line">        &#123;</span><br><span class="line">            SpawnedActor-&gt;ConfirmTargeting();</span><br><span class="line">        &#125;</span><br><span class="line">        else if (ConfirmationType == EGameplayTargetingConfirmation::UserConfirmed)</span><br><span class="line">        &#123;</span><br><span class="line">            // Bind to the Cancel/Confirm Delegates (called from local confirm or from repped confirm)</span><br><span class="line">            SpawnedActor-&gt;BindToConfirmCancelInputs();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_WaitTargetData::RegisterTargetDataCallbacks()</span><br><span class="line">&#123;</span><br><span class="line">    if (!ensure(IsValid(this)))</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UAbilitySystemComponent* ASC = AbilitySystemComponent.Get();</span><br><span class="line">    if (!ASC)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    check(TargetClass);</span><br><span class="line">    check(Ability);</span><br><span class="line"></span><br><span class="line">    const AGameplayAbilityTargetActor* CDO = CastChecked&lt;AGameplayAbilityTargetActor&gt;(TargetClass-&gt;GetDefaultObject());</span><br><span class="line"></span><br><span class="line">    const bool bIsLocallyControlled = Ability-&gt;GetCurrentActorInfo()-&gt;IsLocallyControlled();</span><br><span class="line">    const bool bShouldProduceTargetDataOnServer = CDO-&gt;ShouldProduceTargetDataOnServer;</span><br><span class="line"></span><br><span class="line">    // If not locally controlled (server for remote client), see if TargetData was already sent</span><br><span class="line">    // else register callback for when it does get here.</span><br><span class="line">    if (!bIsLocallyControlled)</span><br><span class="line">    &#123;</span><br><span class="line">        // Register with the TargetData callbacks if we are expecting client to send them</span><br><span class="line">        if (!bShouldProduceTargetDataOnServer)</span><br><span class="line">        &#123;</span><br><span class="line">            //服务器，且依赖于客户端传输TargetData</span><br><span class="line"></span><br><span class="line">            FGameplayAbilitySpecHandle	SpecHandle = GetAbilitySpecHandle();</span><br><span class="line">            FPredictionKey ActivationPredictionKey = GetActivationPredictionKey();</span><br><span class="line">            </span><br><span class="line">            //进行回调注册</span><br><span class="line">            //Since multifire is supported, we still need to hook up the callbacks</span><br><span class="line">            ASC-&gt;AbilityTargetDataSetDelegate(SpecHandle, ActivationPredictionKey ).AddUObject(this, &amp;UAbilityTask_WaitTargetData::OnTargetDataReplicatedCallback);</span><br><span class="line">            ASC-&gt;AbilityTargetDataCancelledDelegate(SpecHandle, ActivationPredictionKey ).AddUObject(this, &amp;UAbilityTask_WaitTargetData::OnTargetDataReplicatedCancelledCallback);</span><br><span class="line"></span><br><span class="line">            //调用一次 如果数据已经准备好，会直接触发</span><br><span class="line">            ASC-&gt;CallReplicatedTargetDataDelegatesIfSet(SpecHandle, ActivationPredictionKey );</span><br><span class="line"></span><br><span class="line">            SetWaitingOnRemotePlayerData();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** Valid TargetData was replicated to use (we are server, was sent from client) */</span><br><span class="line">void UAbilityTask_WaitTargetData::OnTargetDataReplicatedCallback(const FGameplayAbilityTargetDataHandle&amp; Data, FGameplayTag ActivationTag)</span><br><span class="line">&#123;</span><br><span class="line">    FGameplayAbilityTargetDataHandle MutableData = Data;</span><br><span class="line"></span><br><span class="line">    if (UAbilitySystemComponent* ASC = AbilitySystemComponent.Get())</span><br><span class="line">    &#123;</span><br><span class="line">        ASC-&gt;ConsumeClientReplicatedTargetData(GetAbilitySpecHandle(), GetActivationPredictionKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** </span><br><span class="line">    *  Call into the TargetActor to sanitize/verify the data. If this returns false, we are rejecting</span><br><span class="line">    *	the replicated target data and will treat this as a cancel.</span><br><span class="line">    *	</span><br><span class="line">    *	This can also be used for bandwidth optimizations. OnReplicatedTargetDataReceived could do an actual</span><br><span class="line">    *	trace/check/whatever server side and use that data. So rather than having the client send that data</span><br><span class="line">    *	explicitly, the client is basically just sending a &#x27;confirm&#x27; and the server is now going to do the work</span><br><span class="line">    *	in OnReplicatedTargetDataReceived.</span><br><span class="line">    */</span><br><span class="line">    //调用OnReplicatedTargetDataReceived</span><br><span class="line">    if (TargetActor &amp;&amp; !TargetActor-&gt;OnReplicatedTargetDataReceived(MutableData))</span><br><span class="line">    &#123;</span><br><span class="line">        if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">        &#123;</span><br><span class="line">            Cancelled.Broadcast(MutableData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">        &#123;</span><br><span class="line">            ValidData.Broadcast(MutableData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ConfirmationType != EGameplayTargetingConfirmation::CustomMulti)</span><br><span class="line">    &#123;</span><br><span class="line">        EndTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** Client canceled this Targeting Task (we are the server) */</span><br><span class="line">void UAbilityTask_WaitTargetData::OnTargetDataReplicatedCancelledCallback()</span><br><span class="line">&#123;</span><br><span class="line">    if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">    &#123;</span><br><span class="line">        Cancelled.Broadcast(FGameplayAbilityTargetDataHandle());</span><br><span class="line">    &#125;</span><br><span class="line">    EndTask();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** The TargetActor we spawned locally has called back with valid target data */</span><br><span class="line">void UAbilityTask_WaitTargetData::OnTargetDataReadyCallback(const FGameplayAbilityTargetDataHandle&amp; Data)</span><br><span class="line">&#123;</span><br><span class="line">    UAbilitySystemComponent* ASC = AbilitySystemComponent.Get();</span><br><span class="line">    if (!Ability || !ASC)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //预测窗口</span><br><span class="line">    FScopedPredictionWindow	ScopedPrediction(ASC, ShouldReplicateDataToServer());</span><br><span class="line"></span><br><span class="line">    const FGameplayAbilityActorInfo* Info = Ability-&gt;GetCurrentActorInfo();</span><br><span class="line">    if (IsPredictingClient())</span><br><span class="line">    &#123;</span><br><span class="line">        if (!TargetActor-&gt;ShouldProduceTargetDataOnServer)</span><br><span class="line">        &#123;</span><br><span class="line">            FGameplayTag ApplicationTag; // Fixme: where would this be useful?</span><br><span class="line">            //发送数据给服务器</span><br><span class="line">            ASC-&gt;CallServerSetReplicatedTargetData(GetAbilitySpecHandle(), GetActivationPredictionKey(), Data, ApplicationTag, ASC-&gt;ScopedPredictionKey);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (ConfirmationType == EGameplayTargetingConfirmation::UserConfirmed)</span><br><span class="line">        &#123;</span><br><span class="line">            // We aren&#x27;t going to send the target data, but we will send a generic confirmed message.</span><br><span class="line">            ASC-&gt;ServerSetReplicatedEvent(EAbilityGenericReplicatedEvent::GenericConfirm, GetAbilitySpecHandle(), GetActivationPredictionKey(), ASC-&gt;ScopedPredictionKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">    &#123;</span><br><span class="line">        ValidData.Broadcast(Data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ConfirmationType != EGameplayTargetingConfirmation::CustomMulti)</span><br><span class="line">    &#123;</span><br><span class="line">        EndTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** The TargetActor we spawned locally has called back with a cancel event (they still include the &#x27;last/best&#x27; targetdata but the consumer of this may want to discard it) */</span><br><span class="line">void UAbilityTask_WaitTargetData::OnTargetDataCancelledCallback(const FGameplayAbilityTargetDataHandle&amp; Data)</span><br><span class="line">&#123;</span><br><span class="line">    UAbilitySystemComponent* ASC = AbilitySystemComponent.Get();</span><br><span class="line">    if (!ASC)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FScopedPredictionWindow ScopedPrediction(ASC, IsPredictingClient());</span><br><span class="line"></span><br><span class="line">    if (IsPredictingClient())</span><br><span class="line">    &#123;</span><br><span class="line">        if (!TargetActor-&gt;ShouldProduceTargetDataOnServer)</span><br><span class="line">        &#123;</span><br><span class="line">            ASC-&gt;ServerSetReplicatedTargetDataCancelled(GetAbilitySpecHandle(), GetActivationPredictionKey(), ASC-&gt;ScopedPredictionKey );</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            // We aren&#x27;t going to send the target data, but we will send a generic confirmed message.</span><br><span class="line">            ASC-&gt;ServerSetReplicatedEvent(EAbilityGenericReplicatedEvent::GenericCancel, GetAbilitySpecHandle(), GetActivationPredictionKey(), ASC-&gt;ScopedPredictionKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Cancelled.Broadcast(Data);</span><br><span class="line">    EndTask();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** Called when the ability is asked to confirm from an outside node. What this means depends on the individual task. By default, this does nothing other than ending if bEndTask is true. */</span><br><span class="line">void UAbilityTask_WaitTargetData::ExternalConfirm(bool bEndTask)</span><br><span class="line">&#123;</span><br><span class="line">    if (TargetActor)</span><br><span class="line">    &#123;</span><br><span class="line">        if (TargetActor-&gt;ShouldProduceTargetData())</span><br><span class="line">        &#123;</span><br><span class="line">            TargetActor-&gt;ConfirmTargetingAndContinue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Super::ExternalConfirm(bEndTask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** Called when the ability is asked to confirm from an outside node. What this means depends on the individual task. By default, this does nothing other than ending if bEndTask is true. */</span><br><span class="line">void UAbilityTask_WaitTargetData::ExternalCancel()</span><br><span class="line">&#123;</span><br><span class="line">    if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">    &#123;</span><br><span class="line">        Cancelled.Broadcast(FGameplayAbilityTargetDataHandle());</span><br><span class="line">    &#125;</span><br><span class="line">    Super::ExternalCancel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_WaitTargetData::OnDestroy(bool AbilityEnded)</span><br><span class="line">&#123;</span><br><span class="line">    if (TargetActor)</span><br><span class="line">    &#123;</span><br><span class="line">        TargetActor-&gt;Destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Super::OnDestroy(AbilityEnded);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool UAbilityTask_WaitTargetData::ShouldReplicateDataToServer() const</span><br><span class="line">&#123;</span><br><span class="line">    if (!Ability || !TargetActor)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Send TargetData to the server IFF we are the client and this isn&#x27;t a GameplayTargetActor that can produce data on the server	</span><br><span class="line">    const FGameplayAbilityActorInfo* Info = Ability-&gt;GetCurrentActorInfo();</span><br><span class="line">    if (!Info-&gt;IsNetAuthority() &amp;&amp; !TargetActor-&gt;ShouldProduceTargetDataOnServer)</span><br><span class="line">    &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// --------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>GAS</tag>
        <tag>Lyra</tag>
      </tags>
  </entry>
  <entry>
    <title>UE5.5-Lyra-5-GATask-传输数据流程</title>
    <url>/UE/Project/Lyra/UE55Lyra5/</url>
    <content><![CDATA[<h1 id="GATask-WaitTargetData"><a href="#GATask-WaitTargetData" class="headerlink" title="GATask_WaitTargetData"></a>GATask_WaitTargetData</h1><p>以WaitTargetData为例子<br>理解TargetActor的使用流程和逻辑</p>
<h2 id="客户端传输数据情况"><a href="#客户端传输数据情况" class="headerlink" title="客户端传输数据情况"></a>客户端传输数据情况</h2><h3 id="Client侧"><a href="#Client侧" class="headerlink" title="Client侧"></a>Client侧</h3><p>p1</p>
<img src="/UE/Project/Lyra/UE55Lyra5/p1.png" class="">
<p>p2</p>
<img src="/UE/Project/Lyra/UE55Lyra5/p2.png" class="">
<p>p3</p>
<img src="/UE/Project/Lyra/UE55Lyra5/p3.png" class="">
<h3 id="Server侧"><a href="#Server侧" class="headerlink" title="Server侧"></a>Server侧</h3><p>p4</p>
<img src="/UE/Project/Lyra/UE55Lyra5/p4.png" class="">
<p>p5</p>
<img src="/UE/Project/Lyra/UE55Lyra5/p5.png" class="">

<h2 id="服务端自己产生数据情况"><a href="#服务端自己产生数据情况" class="headerlink" title="服务端自己产生数据情况"></a>服务端自己产生数据情况</h2><p>这里以对应AGameplayAbilityTargetActor_Radius作为例子<br>p6</p>
<img src="/UE/Project/Lyra/UE55Lyra5/p6.png" class="">]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>GAS</tag>
        <tag>Lyra</tag>
      </tags>
  </entry>
  <entry>
    <title>UE5.5-Lyra-4-GATask-AGameplayAbilityTargetActor</title>
    <url>/UE/Project/Lyra/UE55Lyra4/</url>
    <content><![CDATA[<h1 id="中间数据-GameplayAbilityTargetActor"><a href="#中间数据-GameplayAbilityTargetActor" class="headerlink" title="中间数据 GameplayAbilityTargetActor"></a>中间数据 GameplayAbilityTargetActor</h1><p>关于目标数据 以下是几个比较关键的类。<br>AGameplayAbilityTargetActor<br>委托：FAbilityTargetData<br>FGameplayAbilityTargetDataHandle<br>FGameplayAbilityTargetData<br>FGameplayEffectContextHandle<br>FGameplayEffectContext</p>
<p>总体上还是比较复杂的。从源码看起。</p>
<h2 id="AGameplayAbilityTargetActor"><a href="#AGameplayAbilityTargetActor" class="headerlink" title="AGameplayAbilityTargetActor"></a>AGameplayAbilityTargetActor</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * TargetActors are spawned to assist with ability targeting. They are spawned by ability tasks and create/determine the outgoing targeting data passed from one task to another</span><br><span class="line"> *</span><br><span class="line"> * WARNING: These actors are spawned once per ability activation and in their default form are not very efficient</span><br><span class="line"> * For most games you will need to subclass and heavily modify this actor, or you will want to implement similar functions in a game-specific actor or blueprint to avoid actor spawn costs</span><br><span class="line"> * This class is not well tested by internal games, but it is a useful class to look at to learn how target replication occurs</span><br><span class="line"> */</span><br><span class="line">UCLASS(Blueprintable, abstract, notplaceable)</span><br><span class="line">class GAMEPLAYABILITIES_API AGameplayAbilityTargetActor : public AActor</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_UCLASS_BODY()</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    void EndPlay(const EEndPlayReason::Type EndPlayReason) override;</span><br><span class="line"></span><br><span class="line">    //无需客户端数据 客户端只需要提供[confirm]的指令即可</span><br><span class="line">    /** The TargetData this class produces can be entirely generated on the server. We don&#x27;t require the client to send us full or partial TargetData (possibly just a &#x27;confirm&#x27;) */</span><br><span class="line">    UPROPERTY(EditAnywhere, Category=Advanced)</span><br><span class="line">    bool ShouldProduceTargetDataOnServer;</span><br><span class="line"></span><br><span class="line">    /** Describes where the targeting action starts, usually the player character or a socket on the player character. */</span><br><span class="line">    //UPROPERTY(BlueprintReadOnly, meta=(ExposeOnSpawn=true), Category=Targeting)</span><br><span class="line">    UPROPERTY(BlueprintReadOnly, meta = (ExposeOnSpawn = true), Replicated, Category = Targeting)</span><br><span class="line">    FGameplayAbilityTargetingLocationInfo StartLocation;</span><br><span class="line"></span><br><span class="line">    /** Initialize and begin targeting logic  */</span><br><span class="line">    virtual void StartTargeting(UGameplayAbility* Ability);</span><br><span class="line"></span><br><span class="line">    virtual bool IsConfirmTargetingAllowed();</span><br><span class="line"></span><br><span class="line">    /** Requesting targeting data, but not necessarily stopping/destroying the task. Useful for external target data requests. */</span><br><span class="line">    virtual void ConfirmTargetingAndContinue();</span><br><span class="line"></span><br><span class="line">    /** Outside code is saying &#x27;stop and just give me what you have.&#x27; Returns true if the ability accepts this and can be forgotten. */</span><br><span class="line">    UFUNCTION()</span><br><span class="line">    virtual void ConfirmTargeting();</span><br><span class="line"></span><br><span class="line">    /** Outside code is saying &#x27;stop everything and just forget about it&#x27; */</span><br><span class="line">    UFUNCTION()</span><br><span class="line">    virtual void CancelTargeting();</span><br><span class="line"></span><br><span class="line">    virtual void BindToConfirmCancelInputs();</span><br><span class="line"></span><br><span class="line">    virtual bool ShouldProduceTargetData() const;</span><br><span class="line"></span><br><span class="line">    /** Replicated target data was received from a client. Possibly sanitize/verify. return true if data is good and we should broadcast it as valid data. */</span><br><span class="line">    virtual bool OnReplicatedTargetDataReceived(FGameplayAbilityTargetDataHandle&amp; Data) const;</span><br><span class="line"></span><br><span class="line">    // ------------------------------</span><br><span class="line"></span><br><span class="line">    FAbilityTargetData	TargetDataReadyDelegate;</span><br><span class="line">    FAbilityTargetData	CanceledDelegate;</span><br><span class="line"></span><br><span class="line">    virtual bool IsNetRelevantFor(const AActor* RealViewer, const AActor* ViewTarget, const FVector&amp; SrcLocation) const override;</span><br><span class="line"></span><br><span class="line">#if WITH_EDITOR</span><br><span class="line">    UE_DEPRECATED(5.1, &quot;This property is deprecated. Please use PrimaryPC instead.&quot;)</span><br><span class="line">    APlayerController* MasterPC;</span><br><span class="line">#endif // WITH_EDITOR</span><br><span class="line"></span><br><span class="line">    UPROPERTY(BlueprintReadOnly, Category = &quot;Targeting&quot;)</span><br><span class="line">    TObjectPtr&lt;APlayerController&gt; PrimaryPC;</span><br><span class="line"></span><br><span class="line">    UPROPERTY()</span><br><span class="line">    TObjectPtr&lt;UGameplayAbility&gt; OwningAbility;</span><br><span class="line"></span><br><span class="line">    UPROPERTY(BlueprintReadOnly, Replicated, Category = Targeting)</span><br><span class="line">    bool bDestroyOnConfirmation;</span><br><span class="line"></span><br><span class="line">    UPROPERTY(BlueprintReadOnly, Replicated, Category = Targeting)</span><br><span class="line">    TObjectPtr&lt;AActor&gt; SourceActor;</span><br><span class="line"></span><br><span class="line">    /** Parameters for world reticle. Usage of these parameters is dependent on the reticle. */</span><br><span class="line">    UPROPERTY(BlueprintReadWrite, meta = (ExposeOnSpawn = true), Category = Targeting)</span><br><span class="line">    FWorldReticleParameters ReticleParams;</span><br><span class="line"></span><br><span class="line">    /** Reticle that will appear on top of acquired targets. Reticles will be spawned/despawned as targets are acquired/lost. */</span><br><span class="line">    UPROPERTY(BlueprintReadWrite, EditAnywhere, meta = (ExposeOnSpawn = true), Category = Targeting)</span><br><span class="line">    TSubclassOf&lt;AGameplayAbilityWorldReticle&gt; ReticleClass;		//Using a special class for replication purposes.</span><br><span class="line"></span><br><span class="line">    UPROPERTY(BlueprintReadWrite, Replicated, meta = (ExposeOnSpawn = true), Category = Targeting)</span><br><span class="line">    FGameplayTargetDataFilterHandle Filter;</span><br><span class="line"></span><br><span class="line">    /** Draw the debug information (if applicable) for this targeting actor. */</span><br><span class="line">    UPROPERTY(BlueprintReadWrite, EditAnywhere, Replicated, meta = (ExposeOnSpawn = true), Category = Targeting)</span><br><span class="line">    bool bDebug;</span><br><span class="line"></span><br><span class="line">    FDelegateHandle GenericConfirmHandle;</span><br><span class="line">    FDelegateHandle GenericCancelHandle;</span><br><span class="line"></span><br><span class="line">    UPROPERTY()</span><br><span class="line">    TObjectPtr&lt;UAbilitySystemComponent&gt; GenericDelegateBoundASC;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include UE_INLINE_GENERATED_CPP_BY_NAME(GameplayAbilityTargetActor)</span><br><span class="line"></span><br><span class="line">// --------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">//</span><br><span class="line">//	AGameplayAbilityTargetActor</span><br><span class="line">//</span><br><span class="line">// --------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">AGameplayAbilityTargetActor::AGameplayAbilityTargetActor(const FObjectInitializer&amp; ObjectInitializer)</span><br><span class="line">	: Super(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">    ShouldProduceTargetDataOnServer = false;</span><br><span class="line">    bDebug = false;</span><br><span class="line">    bDestroyOnConfirmation = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//AActor的EndPlay函数</span><br><span class="line">//Called whenever this actor is being removed from a level.</span><br><span class="line">void AGameplayAbilityTargetActor::EndPlay(const EEndPlayReason::Type EndPlayReason)</span><br><span class="line">&#123;</span><br><span class="line">    if (GenericDelegateBoundASC)</span><br><span class="line">    &#123;</span><br><span class="line">        // We must remove ourselves from GenericLocalConfirmCallbacks/GenericLocalCancelCallbacks, since while these are bound they will inhibit any *other* abilities</span><br><span class="line">        // that are bound to the same key.</span><br><span class="line"></span><br><span class="line">        UAbilitySystemComponent* UnboundASC = nullptr;</span><br><span class="line">        const FGameplayAbilityActorInfo* Info = (OwningAbility ? OwningAbility-&gt;GetCurrentActorInfo() : nullptr);</span><br><span class="line">        if (Info &amp;&amp; Info-&gt;IsLocallyControlled())</span><br><span class="line">        &#123;</span><br><span class="line">            UAbilitySystemComponent* ASC = Info-&gt;AbilitySystemComponent.Get();</span><br><span class="line">            if (ASC)</span><br><span class="line">            &#123;</span><br><span class="line">                //获取到对应的ASC（如果能获取到的话）</span><br><span class="line">                //移除对应的事件</span><br><span class="line">                ASC-&gt;GenericLocalConfirmCallbacks.RemoveDynamic(this, &amp;AGameplayAbilityTargetActor::ConfirmTargeting);</span><br><span class="line">                ASC-&gt;GenericLocalCancelCallbacks.RemoveDynamic(this, &amp;AGameplayAbilityTargetActor::CancelTargeting);</span><br><span class="line"></span><br><span class="line">                UnboundASC = ASC;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ensure(GenericDelegateBoundASC == UnboundASC); // Error checking that we have removed delegates from the same ASC we bound them to</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Super::EndPlay(EndPlayReason);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//声明需要复制的变量内容</span><br><span class="line">void AGameplayAbilityTargetActor::GetLifetimeReplicatedProps(TArray&lt; FLifetimeProperty &gt; &amp; OutLifetimeProps) const</span><br><span class="line">&#123;</span><br><span class="line">    Super::GetLifetimeReplicatedProps(OutLifetimeProps);</span><br><span class="line"></span><br><span class="line">    //复制变量</span><br><span class="line">    DOREPLIFETIME(AGameplayAbilityTargetActor, StartLocation);</span><br><span class="line">    DOREPLIFETIME(AGameplayAbilityTargetActor, SourceActor);</span><br><span class="line">    DOREPLIFETIME(AGameplayAbilityTargetActor, bDebug);</span><br><span class="line">    DOREPLIFETIME(AGameplayAbilityTargetActor, bDestroyOnConfirmation);</span><br><span class="line">    //非复制内容</span><br><span class="line">    DISABLE_REPLICATED_PROPERTY(AGameplayAbilityTargetActor, Filter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AGameplayAbilityTargetActor::StartTargeting(UGameplayAbility* Ability)</span><br><span class="line">&#123;</span><br><span class="line">    OwningAbility = Ability;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool AGameplayAbilityTargetActor::IsConfirmTargetingAllowed()</span><br><span class="line">&#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AGameplayAbilityTargetActor::ConfirmTargetingAndContinue()</span><br><span class="line">&#123;</span><br><span class="line">    check(ShouldProduceTargetData());</span><br><span class="line">    if (IsConfirmTargetingAllowed())</span><br><span class="line">    &#123;</span><br><span class="line">        //这里依据需求 创建对应的Handle并进行广播</span><br><span class="line">        //可以参考其他示例</span><br><span class="line">        TargetDataReadyDelegate.Broadcast(FGameplayAbilityTargetDataHandle());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AGameplayAbilityTargetActor::ConfirmTargeting()</span><br><span class="line">&#123;</span><br><span class="line">    const FGameplayAbilityActorInfo* ActorInfo = (OwningAbility ? OwningAbility-&gt;GetCurrentActorInfo() : nullptr);</span><br><span class="line">    UAbilitySystemComponent* ASC = (ActorInfo ? ActorInfo-&gt;AbilitySystemComponent.Get() : nullptr);</span><br><span class="line">    if (ASC)</span><br><span class="line">    &#123;</span><br><span class="line">        //移除侦听</span><br><span class="line">        ASC-&gt;AbilityReplicatedEventDelegate(EAbilityGenericReplicatedEvent::GenericConfirm, OwningAbility-&gt;GetCurrentAbilitySpecHandle(), OwningAbility-&gt;GetCurrentActivationInfo().GetActivationPredictionKey() ).Remove(GenericConfirmHandle);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        ABILITY_LOG(Warning, TEXT(&quot;AGameplayAbilityTargetActor::ConfirmTargeting called with null Ability/ASC! Actor %s&quot;), *GetName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (IsConfirmTargetingAllowed())</span><br><span class="line">    &#123;</span><br><span class="line">        //执行逻辑</span><br><span class="line">        ConfirmTargetingAndContinue();</span><br><span class="line">        if (bDestroyOnConfirmation)</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** Outside code is saying &#x27;stop everything and just forget about it&#x27; */</span><br><span class="line">void AGameplayAbilityTargetActor::CancelTargeting()</span><br><span class="line">&#123;</span><br><span class="line">    const FGameplayAbilityActorInfo* ActorInfo = (OwningAbility ? OwningAbility-&gt;GetCurrentActorInfo() : nullptr);</span><br><span class="line">    UAbilitySystemComponent* ASC = (ActorInfo ? ActorInfo-&gt;AbilitySystemComponent.Get() : nullptr);</span><br><span class="line">    if (ASC)</span><br><span class="line">    &#123;</span><br><span class="line">        //移除侦听</span><br><span class="line">        ASC-&gt;AbilityReplicatedEventDelegate(EAbilityGenericReplicatedEvent::GenericCancel, OwningAbility-&gt;GetCurrentAbilitySpecHandle(), OwningAbility-&gt;GetCurrentActivationInfo().GetActivationPredictionKey() ).Remove(GenericCancelHandle);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        ABILITY_LOG(Warning, TEXT(&quot;AGameplayAbilityTargetActor::CancelTargeting called with null ASC! Actor %s&quot;), *GetName());</span><br><span class="line">    &#125;</span><br><span class="line">    //广播</span><br><span class="line">    CanceledDelegate.Broadcast(FGameplayAbilityTargetDataHandle());</span><br><span class="line">    Destroy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这里可以看到AActor里面相关的介绍。</span><br><span class="line">//是否关联 并需要复制 - AOI/预测等</span><br><span class="line">bool AGameplayAbilityTargetActor::IsNetRelevantFor(const AActor* RealViewer, const AActor* ViewTarget, const FVector&amp; SrcLocation) const</span><br><span class="line">&#123;</span><br><span class="line">    //The player who created the ability doesn&#x27;t need to be updated about it - there should be local prediction in place.</span><br><span class="line">    if (RealViewer == PrimaryPC)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const FGameplayAbilityActorInfo* ActorInfo = (OwningAbility ? OwningAbility-&gt;GetCurrentActorInfo() : NULL);</span><br><span class="line">    AActor* Avatar = (ActorInfo ? ActorInfo-&gt;AvatarActor.Get() : NULL);</span><br><span class="line"></span><br><span class="line">    //使用Ability来定</span><br><span class="line">    if (Avatar)</span><br><span class="line">    &#123;</span><br><span class="line">        return Avatar-&gt;IsNetRelevantFor(RealViewer, ViewTarget, SrcLocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return Super::IsNetRelevantFor(RealViewer, ViewTarget, SrcLocation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//处理收到的数据</span><br><span class="line">//验证有效性，合理性等。结合GATask_WaitTargetData来看。</span><br><span class="line">bool AGameplayAbilityTargetActor::OnReplicatedTargetDataReceived(FGameplayAbilityTargetDataHandle&amp; Data) const</span><br><span class="line">&#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool AGameplayAbilityTargetActor::ShouldProduceTargetData() const</span><br><span class="line">&#123;</span><br><span class="line">    // return true if we are locally owned, or (we are the server and this is a gameplaytarget ability that can produce target data server side)</span><br><span class="line">    return (PrimaryPC &amp;&amp; PrimaryPC-&gt;IsLocalController()) || ShouldProduceTargetDataOnServer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AGameplayAbilityTargetActor::BindToConfirmCancelInputs()</span><br><span class="line">&#123;</span><br><span class="line">    check(OwningAbility);</span><br><span class="line"></span><br><span class="line">    const FGameplayAbilityActorInfo* const Info = OwningAbility-&gt;GetCurrentActorInfo();</span><br><span class="line">    UAbilitySystemComponent* const ASC = Info-&gt;AbilitySystemComponent.Get();</span><br><span class="line">    if (ASC)</span><br><span class="line">    &#123;</span><br><span class="line">        //本地情况</span><br><span class="line">        if (Info-&gt;IsLocallyControlled())</span><br><span class="line">        &#123;</span><br><span class="line">            //添加侦听</span><br><span class="line">            // We have to wait for the callback from the AbilitySystemComponent. Which will always be instigated locally</span><br><span class="line">            ASC-&gt;GenericLocalConfirmCallbacks.AddDynamic(this, &amp;AGameplayAbilityTargetActor::ConfirmTargeting);	// Tell me if the confirm input is pressed</span><br><span class="line">            ASC-&gt;GenericLocalCancelCallbacks.AddDynamic(this, &amp;AGameplayAbilityTargetActor::CancelTargeting);	// Tell me if the cancel input is pressed</span><br><span class="line"></span><br><span class="line">            // Save off which ASC we bound so that we can error check that we&#x27;re removing them later</span><br><span class="line">            GenericDelegateBoundASC = ASC;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;	</span><br><span class="line">            //服务端情况</span><br><span class="line">            FGameplayAbilitySpecHandle Handle = OwningAbility-&gt;GetCurrentAbilitySpecHandle();</span><br><span class="line">            FPredictionKey PredKey = OwningAbility-&gt;GetCurrentActivationInfo().GetActivationPredictionKey();</span><br><span class="line">            </span><br><span class="line">            //添加对应的侦听</span><br><span class="line">            GenericConfirmHandle = ASC-&gt;AbilityReplicatedEventDelegate(EAbilityGenericReplicatedEvent::GenericConfirm, Handle, PredKey ).AddUObject(this, &amp;AGameplayAbilityTargetActor::ConfirmTargeting);</span><br><span class="line">            GenericCancelHandle = ASC-&gt;AbilityReplicatedEventDelegate(EAbilityGenericReplicatedEvent::GenericCancel, Handle, PredKey ).AddUObject(this, &amp;AGameplayAbilityTargetActor::CancelTargeting);</span><br><span class="line">            </span><br><span class="line">            //尝试调用</span><br><span class="line">            if (ASC-&gt;CallReplicatedEventDelegateIfSet(EAbilityGenericReplicatedEvent::GenericConfirm, Handle, PredKey))</span><br><span class="line">            &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (ASC-&gt;CallReplicatedEventDelegateIfSet(EAbilityGenericReplicatedEvent::GenericCancel, Handle, PredKey))</span><br><span class="line">            &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FAbilityTargetData与FGameplayAbilityTargetDataHandle"><a href="#FAbilityTargetData与FGameplayAbilityTargetDataHandle" class="headerlink" title="FAbilityTargetData与FGameplayAbilityTargetDataHandle"></a>FAbilityTargetData与FGameplayAbilityTargetDataHandle</h2><p>&#x2F;&#x2F;看到FAbilityTargetData委托的声明:<br>&#x2F;** Generic callback for returning when target data is available *&#x2F;<br>DECLARE_MULTICAST_DELEGATE_OneParam(FAbilityTargetData, const FGameplayAbilityTargetDataHandle&amp;);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">*	Handle for Targeting Data. This servers two main purposes:</span><br><span class="line">*		-Avoid us having to copy around the full targeting data structure in Blueprints//避免复制完整的数据</span><br><span class="line">*		-Allows us to leverage polymorphism in the target data structure//在目标数据结构中充分利用多态性</span><br><span class="line">*		-Allows us to implement NetSerialize and replicate by value between clients/server//网络序列化</span><br><span class="line">*</span><br><span class="line">*		-Avoid using UObjects could be used to give us polymorphism and by reference passing in blueprints.</span><br><span class="line">*		-However we would still be screwed when it came to replication</span><br><span class="line">*</span><br><span class="line">*		-Replication by value//值复制</span><br><span class="line">*		-Pass by reference in blueprints//蓝图引用传递</span><br><span class="line">*		-Polymophism in TargetData structure//目标数据结构的多态性</span><br><span class="line">*/</span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line">struct GAMEPLAYABILITIES_API FGameplayAbilityTargetDataHandle</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_USTRUCT_BODY()</span><br><span class="line"></span><br><span class="line">    FGameplayAbilityTargetDataHandle() &#123; &#125;</span><br><span class="line">    FGameplayAbilityTargetDataHandle(FGameplayAbilityTargetData* DataPtr)</span><br><span class="line">    &#123;</span><br><span class="line">        Data.Add(TSharedPtr&lt;FGameplayAbilityTargetData&gt;(DataPtr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FGameplayAbilityTargetDataHandle(FGameplayAbilityTargetDataHandle&amp;&amp; Other) : UniqueId(Other.UniqueId), Data(MoveTemp(Other.Data))	&#123; &#125;</span><br><span class="line">    FGameplayAbilityTargetDataHandle(const FGameplayAbilityTargetDataHandle&amp; Other) : UniqueId(Other.UniqueId), Data(Other.Data) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    FGameplayAbilityTargetDataHandle&amp; operator=(FGameplayAbilityTargetDataHandle&amp;&amp; Other) &#123; UniqueId = Other.UniqueId; Data = MoveTemp(Other.Data); return *this; &#125;</span><br><span class="line">    FGameplayAbilityTargetDataHandle&amp; operator=(const FGameplayAbilityTargetDataHandle&amp; Other) &#123; UniqueId = Other.UniqueId; Data = Other.Data; return *this; &#125;</span><br><span class="line"></span><br><span class="line">    uint8 UniqueId = 0;</span><br><span class="line"></span><br><span class="line">    /** Raw storage of target data, do not modify this directly */</span><br><span class="line">    TArray&lt;TSharedPtr&lt;FGameplayAbilityTargetData&gt;, TInlineAllocator&lt;1&gt; &gt;	Data;</span><br><span class="line"></span><br><span class="line">    /** Resets handle to have no targets */</span><br><span class="line">    void Clear()</span><br><span class="line">    &#123;</span><br><span class="line">        Data.Reset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Returns number of target data, not number of actors/targets as target data may contain multiple actors */</span><br><span class="line">    int32 Num() const</span><br><span class="line">    &#123;</span><br><span class="line">        return Data.Num();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Returns true if there are any valid targets */</span><br><span class="line">    bool IsValid(int32 Index) const</span><br><span class="line">    &#123;</span><br><span class="line">        return (Index &lt; Data.Num() &amp;&amp; Data[Index].IsValid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Returns data at index, or nullptr if invalid */</span><br><span class="line">    const FGameplayAbilityTargetData* Get(int32 Index) const</span><br><span class="line">    &#123;</span><br><span class="line">        return IsValid(Index) ? Data[Index].Get() : nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Returns data at index, or nullptr if invalid */</span><br><span class="line">    FGameplayAbilityTargetData* Get(int32 Index)</span><br><span class="line">    &#123;</span><br><span class="line">        return IsValid(Index) ? Data[Index].Get() : nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Adds a new target data to handle, it must have been created with new */</span><br><span class="line">    void Add(FGameplayAbilityTargetData* DataPtr)</span><br><span class="line">    &#123;</span><br><span class="line">        Data.Add(TSharedPtr&lt;FGameplayAbilityTargetData&gt;(DataPtr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Does a shallow copy of target data from one handle to another */</span><br><span class="line">    void Append(const FGameplayAbilityTargetDataHandle&amp; OtherHandle)</span><br><span class="line">    &#123;</span><br><span class="line">        Data.Append(OtherHandle.Data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Serialize for networking, handles polymorphism */</span><br><span class="line">    bool NetSerialize(FArchive&amp; Ar, class UPackageMap* Map, bool&amp; bOutSuccess);</span><br><span class="line"></span><br><span class="line">    /** Comparison operator */</span><br><span class="line">    bool operator==(const FGameplayAbilityTargetDataHandle&amp; Other) const</span><br><span class="line">    &#123;</span><br><span class="line">        // Both invalid structs or both valid and Pointer compare (???) // deep comparison equality</span><br><span class="line">        if (Data.Num() != Other.Data.Num())</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int32 i = 0; i &lt; Data.Num(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if (Data[i].IsValid() != Other.Data[i].IsValid())</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (Data[i].Get() != Other.Data[i].Get())</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Comparison operator */</span><br><span class="line">    bool operator!=(const FGameplayAbilityTargetDataHandle&amp; Other) const</span><br><span class="line">    &#123;</span><br><span class="line">        return !(FGameplayAbilityTargetDataHandle::operator==(Other));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>GAS</tag>
        <tag>Lyra</tag>
      </tags>
  </entry>
  <entry>
    <title>UE5.5-Lyra-6-MeleeAttack</title>
    <url>/UE/Project/Lyra/UE55Lyra6/</url>
    <content><![CDATA[<p>学习目标：<br>近战攻击的实现和检测<br>这里还是以Lyra的近战攻击行为GA_Melee作为样例来学习。<br>同时参考项目ActionRPG。<br>ActionRPG本来是虚幻4的项目，网上有UE5的适配版本。以此作为学习的样本。不过，GAS在虚幻4到虚幻5之间还是有较大的改动的。学习的时候还是多想想，多看看。</p>
<h1 id="前言和方法"><a href="#前言和方法" class="headerlink" title="前言和方法"></a>前言和方法</h1><p>GATask的静态工厂函数并不会直接在蓝图中调用。（Rider）里面可以看到显示为“没有蓝图用法”。而是会走蓝图的包一层去实现。正如宏里面meta声明的<code>BlueprintInternalUseOnly = &quot;TRUE&quot;</code>一样。</p>
<p>要搜索蓝图中的用法 可以在编辑器中使用Tools -&gt; Find in Blueprints来查找对应的应用方法。</p>
<p>要查找资产引用，可以右键对应的资产，看到ReferenceViewer。</p>
<h1 id="GATask-PlayMontageAndWait"><a href="#GATask-PlayMontageAndWait" class="headerlink" title="GATask_PlayMontageAndWait"></a>GATask_PlayMontageAndWait</h1><p>首先还是看到蒙太奇的播放</p>
<h2 id="PlayMontageAndWait源码"><a href="#PlayMontageAndWait源码" class="headerlink" title="PlayMontageAndWait源码"></a>PlayMontageAndWait源码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">DECLARE_DYNAMIC_MULTICAST_DELEGATE(FMontageWaitSimpleDelegate);</span><br><span class="line"></span><br><span class="line">/** Ability task to simply play a montage. Many games will want to make a modified version of this task that looks for game-specific events */</span><br><span class="line">UCLASS()</span><br><span class="line">class GAMEPLAYABILITIES_API UAbilityTask_PlayMontageAndWait : public UAbilityTask</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FMontageWaitSimpleDelegate	OnCompleted;</span><br><span class="line"></span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FMontageWaitSimpleDelegate	OnBlendedIn;</span><br><span class="line"></span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FMontageWaitSimpleDelegate	OnBlendOut;</span><br><span class="line"></span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FMontageWaitSimpleDelegate	OnInterrupted;</span><br><span class="line"></span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FMontageWaitSimpleDelegate	OnCancelled;</span><br><span class="line"></span><br><span class="line">    UFUNCTION()</span><br><span class="line">    void OnMontageBlendedIn(UAnimMontage* Montage);</span><br><span class="line"></span><br><span class="line">    UFUNCTION()</span><br><span class="line">    void OnMontageBlendingOut(UAnimMontage* Montage, bool bInterrupted);</span><br><span class="line"></span><br><span class="line">    UE_DEPRECATED(5.3, &quot;Please use OnGameplayAbilityCancelled instead. This function naming implied the Montage was already interrupted (instead, we are about to interrupt it).&quot;)</span><br><span class="line">    UFUNCTION()</span><br><span class="line">    void OnMontageInterrupted();</span><br><span class="line"></span><br><span class="line">    /** Callback function for when the owning Gameplay Ability is cancelled */</span><br><span class="line">    UFUNCTION()</span><br><span class="line">    void OnGameplayAbilityCancelled();</span><br><span class="line"></span><br><span class="line">    UFUNCTION()</span><br><span class="line">    void OnMontageEnded(UAnimMontage* Montage, bool bInterrupted);</span><br><span class="line"></span><br><span class="line">    /** </span><br><span class="line">        * Start playing an animation montage on the avatar actor and wait for it to finish</span><br><span class="line">        * If StopWhenAbilityEnds is true, this montage will be aborted if the ability ends normally. It is always stopped when the ability is explicitly cancelled.</span><br><span class="line">        * On normal execution, OnBlendOut is called when the montage is blending out, and OnCompleted when it is completely done playing</span><br><span class="line">        * OnInterrupted is called if another montage overwrites this, and OnCancelled is called if the ability or task is cancelled</span><br><span class="line">        *</span><br><span class="line">        * @param TaskInstanceName Set to override the name of this task, for later querying</span><br><span class="line">        * @param MontageToPlay The montage to play on the character</span><br><span class="line">        * @param Rate Change to play the montage faster or slower</span><br><span class="line">        * @param StartSection If not empty, named montage section to start from</span><br><span class="line">        * @param bStopWhenAbilityEnds If true, this montage will be aborted if the ability ends normally. It is always stopped when the ability is explicitly cancelled</span><br><span class="line">        * @param AnimRootMotionTranslationScale Change to modify size of root motion or set to 0 to block it entirely</span><br><span class="line">        * @param StartTimeSeconds Starting time offset in montage, this will be overridden by StartSection if that is also set</span><br><span class="line">        * @param bAllowInterruptAfterBlendOut If true, you can receive OnInterrupted after an OnBlendOut started (otherwise OnInterrupted will not fire when interrupted, but you will not get OnComplete).</span><br><span class="line">        */</span><br><span class="line">    UFUNCTION(BlueprintCallable, Category=&quot;Ability|Tasks&quot;, meta = (DisplayName=&quot;PlayMontageAndWait&quot;,</span><br><span class="line">        HidePin = &quot;OwningAbility&quot;, DefaultToSelf = &quot;OwningAbility&quot;, BlueprintInternalUseOnly = &quot;TRUE&quot;))</span><br><span class="line">    static UAbilityTask_PlayMontageAndWait* CreatePlayMontageAndWaitProxy(UGameplayAbility* OwningAbility,</span><br><span class="line">        FName TaskInstanceName, UAnimMontage* MontageToPlay, float Rate = 1.f, FName StartSection = NAME_None, bool bStopWhenAbilityEnds = true, float AnimRootMotionTranslationScale = 1.f, float StartTimeSeconds = 0.f, bool bAllowInterruptAfterBlendOut = false);</span><br><span class="line"></span><br><span class="line">    virtual void Activate() override;</span><br><span class="line"></span><br><span class="line">    /** Called when the ability is asked to cancel from an outside node. What this means depends on the individual task. By default, this does nothing other than ending the task. */</span><br><span class="line">    virtual void ExternalCancel() override;</span><br><span class="line"></span><br><span class="line">    virtual FString GetDebugString() const override;</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line"></span><br><span class="line">    virtual void OnDestroy(bool AbilityEnded) override;</span><br><span class="line"></span><br><span class="line">    /** Checks if the ability is playing a montage and stops that montage, returns true if a montage was stopped, false if not. */</span><br><span class="line">    bool StopPlayingMontage();</span><br><span class="line"></span><br><span class="line">    FOnMontageBlendedInEnded BlendedInDelegate;</span><br><span class="line">    FOnMontageBlendingOutStarted BlendingOutDelegate;</span><br><span class="line">    FOnMontageEnded MontageEndedDelegate;</span><br><span class="line">    FDelegateHandle InterruptedHandle;</span><br><span class="line"></span><br><span class="line">    UPROPERTY()</span><br><span class="line">    TObjectPtr&lt;UAnimMontage&gt; MontageToPlay;</span><br><span class="line"></span><br><span class="line">    UPROPERTY()</span><br><span class="line">    float Rate;</span><br><span class="line"></span><br><span class="line">    UPROPERTY()</span><br><span class="line">    FName StartSection;</span><br><span class="line"></span><br><span class="line">    UPROPERTY()</span><br><span class="line">    float AnimRootMotionTranslationScale;</span><br><span class="line"></span><br><span class="line">    UPROPERTY()</span><br><span class="line">    float StartTimeSeconds;</span><br><span class="line"></span><br><span class="line">    UPROPERTY()</span><br><span class="line">    bool bStopWhenAbilityEnds;</span><br><span class="line"></span><br><span class="line">    UPROPERTY()</span><br><span class="line">    bool bAllowInterruptAfterBlendOut;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include UE_INLINE_GENERATED_CPP_BY_NAME(AbilityTask_PlayMontageAndWait)</span><br><span class="line"></span><br><span class="line">static bool GUseAggressivePlayMontageAndWaitEndTask = true;</span><br><span class="line">static FAutoConsoleVariableRef CVarAggressivePlayMontageAndWaitEndTask(TEXT(&quot;AbilitySystem.PlayMontage.AggressiveEndTask&quot;), GUseAggressivePlayMontageAndWaitEndTask, TEXT(&quot;This should be set to true in order to avoid multiple callbacks off an AbilityTask_PlayMontageAndWait node&quot;));</span><br><span class="line"></span><br><span class="line">static bool GPlayMontageAndWaitFireInterruptOnAnimEndInterrupt = true;</span><br><span class="line">static FAutoConsoleVariableRef CVarPlayMontageAndWaitFireInterruptOnAnimEndInterrupt(TEXT(&quot;AbilitySystem.PlayMontage.FireInterruptOnAnimEndInterrupt&quot;), GPlayMontageAndWaitFireInterruptOnAnimEndInterrupt, TEXT(&quot;This is a fix that will cause AbilityTask_PlayMontageAndWait to fire its Interrupt event if the underlying AnimInstance ends in an interrupted&quot;));</span><br><span class="line"></span><br><span class="line">void UAbilityTask_PlayMontageAndWait::OnMontageBlendingOut(UAnimMontage* Montage, bool bInterrupted)</span><br><span class="line">&#123;</span><br><span class="line">    const bool bPlayingThisMontage = (Montage == MontageToPlay) &amp;&amp; Ability &amp;&amp; Ability-&gt;GetCurrentMontage() == MontageToPlay;</span><br><span class="line">    if (bPlayingThisMontage)</span><br><span class="line">    &#123;</span><br><span class="line">        // Reset AnimRootMotionTranslationScale</span><br><span class="line">        ACharacter* Character = Cast&lt;ACharacter&gt;(GetAvatarActor());</span><br><span class="line">        if (Character &amp;&amp; (Character-&gt;GetLocalRole() == ROLE_Authority ||</span><br><span class="line">                            (Character-&gt;GetLocalRole() == ROLE_AutonomousProxy &amp;&amp; Ability-&gt;GetNetExecutionPolicy() == EGameplayAbilityNetExecutionPolicy::LocalPredicted)))</span><br><span class="line">        &#123;</span><br><span class="line">            Character-&gt;SetAnimRootMotionTranslationScale(1.f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (bPlayingThisMontage &amp;&amp; (bInterrupted || !bAllowInterruptAfterBlendOut))</span><br><span class="line">    &#123;</span><br><span class="line">        if (UAbilitySystemComponent* ASC = AbilitySystemComponent.Get())</span><br><span class="line">        &#123;</span><br><span class="line">            ASC-&gt;ClearAnimatingAbility(Ability);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">    &#123;</span><br><span class="line">        if (bInterrupted)</span><br><span class="line">        &#123;</span><br><span class="line">            bAllowInterruptAfterBlendOut = false;</span><br><span class="line">            OnInterrupted.Broadcast();</span><br><span class="line"></span><br><span class="line">            if (GUseAggressivePlayMontageAndWaitEndTask)</span><br><span class="line">            &#123;</span><br><span class="line">                EndTask();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            OnBlendOut.Broadcast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_PlayMontageAndWait::OnMontageBlendedIn(UAnimMontage* Montage)</span><br><span class="line">&#123;</span><br><span class="line">    if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">    &#123;</span><br><span class="line">        OnBlendedIn.Broadcast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_PlayMontageAndWait::OnMontageInterrupted()</span><br><span class="line">&#123;</span><br><span class="line">    // Call the new function</span><br><span class="line">    OnGameplayAbilityCancelled();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_PlayMontageAndWait::OnGameplayAbilityCancelled()</span><br><span class="line">&#123;</span><br><span class="line">    if (StopPlayingMontage() || bAllowInterruptAfterBlendOut)</span><br><span class="line">    &#123;</span><br><span class="line">        // Let the BP handle the interrupt as well</span><br><span class="line">        if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">        &#123;</span><br><span class="line">            bAllowInterruptAfterBlendOut = false;</span><br><span class="line">            OnInterrupted.Broadcast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (GUseAggressivePlayMontageAndWaitEndTask)</span><br><span class="line">    &#123;</span><br><span class="line">        EndTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_PlayMontageAndWait::OnMontageEnded(UAnimMontage* Montage, bool bInterrupted)</span><br><span class="line">&#123;</span><br><span class="line">    if (!bInterrupted)</span><br><span class="line">    &#123;</span><br><span class="line">        if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">        &#123;</span><br><span class="line">            OnCompleted.Broadcast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(bAllowInterruptAfterBlendOut &amp;&amp; GPlayMontageAndWaitFireInterruptOnAnimEndInterrupt)</span><br><span class="line">    &#123;</span><br><span class="line">        if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">        &#123;</span><br><span class="line">            OnInterrupted.Broadcast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EndTask();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UAbilityTask_PlayMontageAndWait* UAbilityTask_PlayMontageAndWait::CreatePlayMontageAndWaitProxy(UGameplayAbility* OwningAbility,</span><br><span class="line">    FName TaskInstanceName, UAnimMontage *MontageToPlay, float Rate, FName StartSection, bool bStopWhenAbilityEnds, float AnimRootMotionTranslationScale, float StartTimeSeconds, bool bAllowInterruptAfterBlendOut)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    UAbilitySystemGlobals::NonShipping_ApplyGlobalAbilityScaler_Rate(Rate);</span><br><span class="line"></span><br><span class="line">    //创建对应的对象</span><br><span class="line">    UAbilityTask_PlayMontageAndWait* MyObj = NewAbilityTask&lt;UAbilityTask_PlayMontageAndWait&gt;(OwningAbility, TaskInstanceName);</span><br><span class="line">    //设置参数</span><br><span class="line">    MyObj-&gt;MontageToPlay = MontageToPlay;</span><br><span class="line">    MyObj-&gt;Rate = Rate;</span><br><span class="line">    MyObj-&gt;StartSection = StartSection;</span><br><span class="line">    MyObj-&gt;AnimRootMotionTranslationScale = AnimRootMotionTranslationScale;</span><br><span class="line">    MyObj-&gt;bStopWhenAbilityEnds = bStopWhenAbilityEnds;</span><br><span class="line">    MyObj-&gt;bAllowInterruptAfterBlendOut = bAllowInterruptAfterBlendOut;</span><br><span class="line">    MyObj-&gt;StartTimeSeconds = StartTimeSeconds;</span><br><span class="line"></span><br><span class="line">    return MyObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_PlayMontageAndWait::Activate()</span><br><span class="line">&#123;</span><br><span class="line">    if (Ability == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool bPlayedMontage = false;</span><br><span class="line"></span><br><span class="line">    if (UAbilitySystemComponent* ASC = AbilitySystemComponent.Get())</span><br><span class="line">    &#123;</span><br><span class="line">        const FGameplayAbilityActorInfo* ActorInfo = Ability-&gt;GetCurrentActorInfo();</span><br><span class="line">        //获取动画实例</span><br><span class="line">        //内部通过SkeletalMeshComponent来获取</span><br><span class="line">        UAnimInstance* AnimInstance = ActorInfo-&gt;GetAnimInstance();</span><br><span class="line">        if (AnimInstance != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            //使用ASC来播放蒙太奇 ASC内部处理网络复制与预测</span><br><span class="line">            //AnimInstance播放失败时返回值为0.f</span><br><span class="line">            if (ASC-&gt;PlayMontage(Ability, Ability-&gt;GetCurrentActivationInfo(), MontageToPlay, Rate, StartSection, StartTimeSeconds) &gt; 0.f)</span><br><span class="line">            &#123;</span><br><span class="line">                // Playing a montage could potentially fire off a callback into game code which could kill this ability! Early out if we are pending kill.</span><br><span class="line"></span><br><span class="line">                //确认当前有效性</span><br><span class="line">                if (ShouldBroadcastAbilityTaskDelegates() == false)</span><br><span class="line">                &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //相关事件的侦听注册</span><br><span class="line">                InterruptedHandle = Ability-&gt;OnGameplayAbilityCancelled.AddUObject(this, &amp;UAbilityTask_PlayMontageAndWait::OnGameplayAbilityCancelled);</span><br><span class="line"></span><br><span class="line">                BlendedInDelegate.BindUObject(this, &amp;UAbilityTask_PlayMontageAndWait::OnMontageBlendedIn);</span><br><span class="line">                AnimInstance-&gt;Montage_SetBlendedInDelegate(BlendedInDelegate, MontageToPlay);</span><br><span class="line"></span><br><span class="line">                BlendingOutDelegate.BindUObject(this, &amp;UAbilityTask_PlayMontageAndWait::OnMontageBlendingOut);</span><br><span class="line">                AnimInstance-&gt;Montage_SetBlendingOutDelegate(BlendingOutDelegate, MontageToPlay);</span><br><span class="line"></span><br><span class="line">                MontageEndedDelegate.BindUObject(this, &amp;UAbilityTask_PlayMontageAndWait::OnMontageEnded);</span><br><span class="line">                AnimInstance-&gt;Montage_SetEndDelegate(MontageEndedDelegate, MontageToPlay);</span><br><span class="line"></span><br><span class="line">                ACharacter* Character = Cast&lt;ACharacter&gt;(GetAvatarActor());</span><br><span class="line">                //服务端/本地客户端预测</span><br><span class="line">                if (Character &amp;&amp; (Character-&gt;GetLocalRole() == ROLE_Authority ||</span><br><span class="line">                                    (Character-&gt;GetLocalRole() == ROLE_AutonomousProxy &amp;&amp; Ability-&gt;GetNetExecutionPolicy() == EGameplayAbilityNetExecutionPolicy::LocalPredicted)))</span><br><span class="line">                &#123;</span><br><span class="line">                    //RootMotion参数设置</span><br><span class="line">                    Character-&gt;SetAnimRootMotionTranslationScale(AnimRootMotionTranslationScale);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                bPlayedMontage = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            ABILITY_LOG(Warning, TEXT(&quot;UAbilityTask_PlayMontageAndWait call to PlayMontage failed!&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        ABILITY_LOG(Warning, TEXT(&quot;UAbilityTask_PlayMontageAndWait called on invalid AbilitySystemComponent&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!bPlayedMontage)</span><br><span class="line">    &#123;</span><br><span class="line">        ABILITY_LOG(Warning, TEXT(&quot;UAbilityTask_PlayMontageAndWait called in Ability %s failed to play montage %s; Task Instance Name %s.&quot;), *Ability-&gt;GetName(), *GetNameSafe(MontageToPlay),*InstanceName.ToString());</span><br><span class="line">        if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">        &#123;</span><br><span class="line">            //播放不成功也是走Cancel</span><br><span class="line">            OnCancelled.Broadcast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //实体销毁时 由ASC终止GA</span><br><span class="line">    SetWaitingOnAvatar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_PlayMontageAndWait::ExternalCancel()</span><br><span class="line">&#123;</span><br><span class="line">    if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">    &#123;</span><br><span class="line">        OnCancelled.Broadcast();</span><br><span class="line">    &#125;</span><br><span class="line">    Super::ExternalCancel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_PlayMontageAndWait::OnDestroy(bool AbilityEnded)</span><br><span class="line">&#123;</span><br><span class="line">    // Note: Clearing montage end delegate isn&#x27;t necessary since its not a multicast and will be cleared when the next montage plays.</span><br><span class="line">    // (If we are destroyed, it will detect this and not do anything)</span><br><span class="line"></span><br><span class="line">    // This delegate, however, should be cleared as it is a multicast</span><br><span class="line">    if (Ability)</span><br><span class="line">    &#123;</span><br><span class="line">        //移除侦听</span><br><span class="line">        Ability-&gt;OnGameplayAbilityCancelled.Remove(InterruptedHandle);</span><br><span class="line">        if (AbilityEnded &amp;&amp; bStopWhenAbilityEnds)</span><br><span class="line">        &#123;</span><br><span class="line">            StopPlayingMontage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Super::OnDestroy(AbilityEnded);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool UAbilityTask_PlayMontageAndWait::StopPlayingMontage()</span><br><span class="line">&#123;</span><br><span class="line">    if (Ability == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const FGameplayAbilityActorInfo* ActorInfo = Ability-&gt;GetCurrentActorInfo();</span><br><span class="line">    if (ActorInfo == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UAnimInstance* AnimInstance = ActorInfo-&gt;GetAnimInstance();</span><br><span class="line">    if (AnimInstance == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Check if the montage is still playing</span><br><span class="line">    // The ability would have been interrupted, in which case we should automatically stop the montage</span><br><span class="line">    UAbilitySystemComponent* ASC = AbilitySystemComponent.Get();</span><br><span class="line">    if (ASC &amp;&amp; Ability)</span><br><span class="line">    &#123;</span><br><span class="line">        if (ASC-&gt;GetAnimatingAbility() == Ability</span><br><span class="line">            &amp;&amp; ASC-&gt;GetCurrentMontage() == MontageToPlay)</span><br><span class="line">        &#123;</span><br><span class="line">            // Unbind delegates so they don&#x27;t get called as well</span><br><span class="line">            FAnimMontageInstance* MontageInstance = AnimInstance-&gt;GetActiveInstanceForMontage(MontageToPlay);</span><br><span class="line">            if (MontageInstance)</span><br><span class="line">            &#123;</span><br><span class="line">                //解除委托绑定</span><br><span class="line">                //这里的这些委托，并不是多播委托 而为单播委托</span><br><span class="line">                MontageInstance-&gt;OnMontageBlendedInEnded.Unbind();</span><br><span class="line">                MontageInstance-&gt;OnMontageBlendingOutStarted.Unbind();</span><br><span class="line">                MontageInstance-&gt;OnMontageEnded.Unbind();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //ASC调用处理蒙太奇停止</span><br><span class="line">            ASC-&gt;CurrentMontageStop();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FString UAbilityTask_PlayMontageAndWait::GetDebugString() const</span><br><span class="line">&#123;</span><br><span class="line">    UAnimMontage* PlayingMontage = nullptr;</span><br><span class="line">    if (Ability)</span><br><span class="line">    &#123;</span><br><span class="line">        const FGameplayAbilityActorInfo* ActorInfo = Ability-&gt;GetCurrentActorInfo();</span><br><span class="line">        UAnimInstance* AnimInstance = ActorInfo-&gt;GetAnimInstance();</span><br><span class="line"></span><br><span class="line">        if (AnimInstance != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            PlayingMontage = AnimInstance-&gt;Montage_IsActive(MontageToPlay) ? ToRawPtr(MontageToPlay) : AnimInstance-&gt;GetCurrentActiveMontage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return FString::Printf(TEXT(&quot;PlayMontageAndWait. MontageToPlay: %s  (Currently Playing): %s&quot;), *GetNameSafe(MontageToPlay), *GetNameSafe(PlayingMontage));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="补充源码"><a href="#补充源码" class="headerlink" title="补充源码"></a>补充源码</h2><h3 id="ASC的PlayMontage"><a href="#ASC的PlayMontage" class="headerlink" title="ASC的PlayMontage"></a>ASC的PlayMontage</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">float UAbilitySystemComponent::PlayMontage(UGameplayAbility* InAnimatingAbility, FGameplayAbilityActivationInfo ActivationInfo, UAnimMontage* NewAnimMontage, float InPlayRate, FName StartSectionName, float StartTimeSeconds)</span><br><span class="line">&#123;</span><br><span class="line">    float Duration = -1.f;</span><br><span class="line"></span><br><span class="line">    UAnimInstance* AnimInstance = AbilityActorInfo.IsValid() ? AbilityActorInfo-&gt;GetAnimInstance() : nullptr;</span><br><span class="line">    if (AnimInstance &amp;&amp; NewAnimMontage)</span><br><span class="line">    &#123;   </span><br><span class="line">        //执行蒙太奇播放</span><br><span class="line">        //客户端预测 &amp;&amp; 服务端执行</span><br><span class="line">        //播放失败时返回0.f</span><br><span class="line">        Duration = AnimInstance-&gt;Montage_Play(NewAnimMontage, InPlayRate, EMontagePlayReturnType::MontageLength, StartTimeSeconds);</span><br><span class="line">        if (Duration &gt; 0.f)</span><br><span class="line">        &#123;</span><br><span class="line">            if (const UGameplayAbility* RawAnimatingAbility = LocalAnimMontageInfo.AnimatingAbility.Get())</span><br><span class="line">            &#123;</span><br><span class="line">                if (RawAnimatingAbility != InAnimatingAbility)</span><br><span class="line">                &#123;</span><br><span class="line">                    // The ability that was previously animating will have already gotten the &#x27;interrupted&#x27; callback.</span><br><span class="line">                    // It may be a good idea to make this a global policy and &#x27;cancel&#x27; the ability.</span><br><span class="line">                    // </span><br><span class="line">                    // For now, we expect it to end itself when this happens.</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            UAnimSequenceBase* Animation = NewAnimMontage-&gt;IsDynamicMontage() ? NewAnimMontage-&gt;GetFirstAnimReference() : NewAnimMontage;</span><br><span class="line"></span><br><span class="line">            if (NewAnimMontage-&gt;HasRootMotion() &amp;&amp; AnimInstance-&gt;GetOwningActor())</span><br><span class="line">            &#123;</span><br><span class="line">                UE_LOG(LogRootMotion, Log, TEXT(&quot;UAbilitySystemComponent::PlayMontage %s, Role: %s&quot;)</span><br><span class="line">                    , *GetNameSafe(Animation)</span><br><span class="line">                    , *UEnum::GetValueAsString(TEXT(&quot;Engine.ENetRole&quot;), AnimInstance-&gt;GetOwningActor()-&gt;GetLocalRole())</span><br><span class="line">                    );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            LocalAnimMontageInfo.AnimMontage = NewAnimMontage;</span><br><span class="line">            LocalAnimMontageInfo.AnimatingAbility = InAnimatingAbility;</span><br><span class="line">            LocalAnimMontageInfo.PlayInstanceId = (LocalAnimMontageInfo.PlayInstanceId &lt; UINT8_MAX ? LocalAnimMontageInfo.PlayInstanceId + 1 : 0);</span><br><span class="line">            </span><br><span class="line">            //设置GA当前播放的蒙太奇信息</span><br><span class="line">            if (InAnimatingAbility)</span><br><span class="line">            &#123;</span><br><span class="line">                InAnimatingAbility-&gt;SetCurrentMontage(NewAnimMontage);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // Start at a given Section.</span><br><span class="line">            if (StartSectionName != NAME_None)</span><br><span class="line">            &#123;</span><br><span class="line">                AnimInstance-&gt;Montage_JumpToSection(StartSectionName, NewAnimMontage);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //网络复制</span><br><span class="line">            // Replicate for non-owners and for replay recordings</span><br><span class="line">            // The data we set from GetRepAnimMontageInfo_Mutable() is used both by the server to replicate to clients and by clients to record replays.</span><br><span class="line">            // - 服务端广播以及客户端用于记录回放</span><br><span class="line">            // We need to set this data for recording clients because there exists network configurations where an abilities montage data will not replicate to some clients (for example: if the client is an autonomous proxy.)</span><br><span class="line">            //客户端自己是自主代理时。且需要回放</span><br><span class="line"></span><br><span class="line">            // Returns true IF the owner is authoritative OR the world is recording a replay.</span><br><span class="line">            //（服务端）||（客户端 - 回放时） 客户端非回放时不用考虑</span><br><span class="line">            if (ShouldRecordMontageReplication())</span><br><span class="line">            &#123;</span><br><span class="line">                FGameplayAbilityRepAnimMontage&amp; MutableRepAnimMontageInfo = GetRepAnimMontageInfo_Mutable();</span><br><span class="line"></span><br><span class="line">                // Those are static parameters, they are only set when the montage is played. They are not changed after that.</span><br><span class="line">                MutableRepAnimMontageInfo.Animation = Animation;</span><br><span class="line">                MutableRepAnimMontageInfo.PlayInstanceId = (MutableRepAnimMontageInfo.PlayInstanceId &lt; UINT8_MAX ? MutableRepAnimMontageInfo.PlayInstanceId + 1 : 0);</span><br><span class="line"></span><br><span class="line">                MutableRepAnimMontageInfo.SectionIdToPlay = 0;</span><br><span class="line">                if (MutableRepAnimMontageInfo.Animation &amp;&amp; StartSectionName != NAME_None)</span><br><span class="line">                &#123;</span><br><span class="line">                    // we add one so INDEX_NONE can be used in the on rep</span><br><span class="line">                    MutableRepAnimMontageInfo.SectionIdToPlay = NewAnimMontage-&gt;GetSectionIndex(StartSectionName) + 1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (NewAnimMontage-&gt;IsDynamicMontage())</span><br><span class="line">                &#123;</span><br><span class="line">                    check(!NewAnimMontage-&gt;SlotAnimTracks.IsEmpty());</span><br><span class="line">                    MutableRepAnimMontageInfo.SlotName = NewAnimMontage-&gt;SlotAnimTracks[0].SlotName;</span><br><span class="line">                    MutableRepAnimMontageInfo.BlendOutTime = NewAnimMontage-&gt;GetDefaultBlendInTime();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Update parameters that change during Montage life time.</span><br><span class="line">                AnimMontage_UpdateReplicatedData();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //服务端广播</span><br><span class="line">            // Replicate to non-owners</span><br><span class="line">            if (IsOwnerActorAuthoritative())</span><br><span class="line">            &#123;</span><br><span class="line">                // Force net update on our avatar actor.</span><br><span class="line">                if (AbilityActorInfo-&gt;AvatarActor != nullptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    AbilityActorInfo-&gt;AvatarActor-&gt;ForceNetUpdate();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                // If this prediction key is rejected, we need to end the preview</span><br><span class="line">                FPredictionKey PredictionKey = GetPredictionKeyForNewAction();</span><br><span class="line">                if (PredictionKey.IsValidKey())</span><br><span class="line">                &#123;</span><br><span class="line">                    //注册回调</span><br><span class="line">                    PredictionKey.NewRejectedDelegate().BindUObject(this, &amp;UAbilitySystemComponent::OnPredictiveMontageRejected, NewAnimMontage);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return Duration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Lyra的近战攻击检测"><a href="#Lyra的近战攻击检测" class="headerlink" title="Lyra的近战攻击检测"></a>Lyra的近战攻击检测</h1><p>Lyra的近战检测做的其实比较简单。<br>可以看到GA_Melee蓝图。</p>
<img src="/UE/Project/Lyra/UE55Lyra6/image-1.png" class="" title="alt text">  
<p>依据Authority - 控制仅在服务端进行伤害逻辑处理<br>碰撞检测方式 - Capsule碰撞检测[基于挂点socket和直线确定起点和终点]<br>在获取到应用对象后，服务端使用ApplyGameplayEffectToTarget来应用近战伤害效果。<br>从实现上看，Lyra的客户端并没有做伤害预测。表现上，客户端仅会预测播放蒙太奇。如果有目标，目标也不会有预测的受击效果（受击效果位于GE上而不是GA了）。<br>要等到服务端确认了，执行了对应的检测和GE应用逻辑，客户端才能看到对应的受击效果。</p>
<h1 id="ActionRPG的近战攻击检测"><a href="#ActionRPG的近战攻击检测" class="headerlink" title="ActionRPG的近战攻击检测"></a>ActionRPG的近战攻击检测</h1><p>ActionRPG中的近战攻击检测主要还是依赖于蒙太奇。</p>
<img src="/UE/Project/Lyra/UE55Lyra6/image-2.png" class="" title="alt text">
<h2 id="GA与GE应用"><a href="#GA与GE应用" class="headerlink" title="GA与GE应用"></a>GA与GE应用</h2><p>这部分还是可以研究一下：</p>
<h3 id="GA重写和重要函数"><a href="#GA重写和重要函数" class="headerlink" title="GA重写和重要函数"></a>GA重写和重要函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Subclass of ability blueprint type with game-specific data</span><br><span class="line"> * This class uses GameplayEffectContainers to allow easier execution of gameplay effects based on a triggering tag</span><br><span class="line"> * Most games will need to implement a subclass to support their game-specific code</span><br><span class="line"> */</span><br><span class="line">UCLASS()</span><br><span class="line">class ACTIONRPG_API URPGGameplayAbility : public UGameplayAbility</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line">public:</span><br><span class="line">    // Constructor and overrides</span><br><span class="line">    URPGGameplayAbility();</span><br><span class="line"></span><br><span class="line">    //GATags-&gt;GEContainer</span><br><span class="line">    //这里的GEContainer是单独声明的一个容器，非GAS系统自带的。</span><br><span class="line">    /** Map of gameplay tags to gameplay effect containers */</span><br><span class="line">    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = GameplayEffects)</span><br><span class="line">    TMap&lt;FGameplayTag, FRPGGameplayEffectContainer&gt; EffectContainerMap;</span><br><span class="line"></span><br><span class="line">    /** Make gameplay effect container spec to be applied later, using the passed in container */</span><br><span class="line">    UFUNCTION(BlueprintCallable, Category = Ability, meta=(AutoCreateRefTerm = &quot;EventData&quot;))</span><br><span class="line">    virtual FRPGGameplayEffectContainerSpec MakeEffectContainerSpecFromContainer(const FRPGGameplayEffectContainer&amp; Container, const FGameplayEventData&amp; EventData, int32 OverrideGameplayLevel = -1);</span><br><span class="line"></span><br><span class="line">    /** Search for and make a gameplay effect container spec to be applied later, from the EffectContainerMap */</span><br><span class="line">    UFUNCTION(BlueprintCallable, Category = Ability, meta = (AutoCreateRefTerm = &quot;EventData&quot;))</span><br><span class="line">    virtual FRPGGameplayEffectContainerSpec MakeEffectContainerSpec(FGameplayTag ContainerTag, const FGameplayEventData&amp; EventData, int32 OverrideGameplayLevel = -1);</span><br><span class="line"></span><br><span class="line">    /** Applies a gameplay effect container spec that was previously created */</span><br><span class="line">    UFUNCTION(BlueprintCallable, Category = Ability)</span><br><span class="line">    virtual TArray&lt;FActiveGameplayEffectHandle&gt; ApplyEffectContainerSpec(const FRPGGameplayEffectContainerSpec&amp; ContainerSpec);</span><br><span class="line"></span><br><span class="line">    /** Applies a gameplay effect container, by creating and then applying the spec */</span><br><span class="line">    UFUNCTION(BlueprintCallable, Category = Ability, meta = (AutoCreateRefTerm = &quot;EventData&quot;))</span><br><span class="line">    virtual TArray&lt;FActiveGameplayEffectHandle&gt; ApplyEffectContainer(FGameplayTag ContainerTag, const FGameplayEventData&amp; EventData, int32 OverrideGameplayLevel = -1);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">URPGGameplayAbility::URPGGameplayAbility() &#123;&#125;</span><br><span class="line"></span><br><span class="line">FRPGGameplayEffectContainerSpec URPGGameplayAbility::MakeEffectContainerSpecFromContainer(const FRPGGameplayEffectContainer&amp; Container, const FGameplayEventData&amp; EventData, int32 OverrideGameplayLevel)</span><br><span class="line">&#123;</span><br><span class="line">    // First figure out our actor info</span><br><span class="line">    FRPGGameplayEffectContainerSpec ReturnSpec;</span><br><span class="line">    AActor* OwningActor = GetOwningActorFromActorInfo();</span><br><span class="line">    ARPGCharacterBase* OwningCharacter = Cast&lt;ARPGCharacterBase&gt;(OwningActor);</span><br><span class="line">    URPGAbilitySystemComponent* OwningASC = URPGAbilitySystemComponent::GetAbilitySystemComponentFromActor(OwningActor);</span><br><span class="line"></span><br><span class="line">    if (OwningASC)</span><br><span class="line">    &#123;</span><br><span class="line">        // If we have a target type, run the targeting logic. This is optional, targets can be added later</span><br><span class="line">        if (Container.TargetType.Get())</span><br><span class="line">        &#123;</span><br><span class="line">            TArray&lt;FHitResult&gt; HitResults;</span><br><span class="line">            TArray&lt;AActor*&gt; TargetActors;</span><br><span class="line">            const URPGTargetType* TargetTypeCDO = Container.TargetType.GetDefaultObject();</span><br><span class="line">            AActor* AvatarActor = GetAvatarActorFromActorInfo();</span><br><span class="line">            TargetTypeCDO-&gt;GetTargets(OwningCharacter, AvatarActor, EventData, HitResults, TargetActors);</span><br><span class="line">            ReturnSpec.AddTargets(HitResults, TargetActors);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // If we don&#x27;t have an override level, use the default on the ability itself</span><br><span class="line">        if (OverrideGameplayLevel == INDEX_NONE)</span><br><span class="line">        &#123;</span><br><span class="line">            OverrideGameplayLevel = OverrideGameplayLevel = this-&gt;GetAbilityLevel(); //OwningASC-&gt;GetDefaultAbilityLevel();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //创建GESpec</span><br><span class="line">        // Build GameplayEffectSpecs for each applied effect</span><br><span class="line">        for (const TSubclassOf&lt;UGameplayEffect&gt;&amp; EffectClass : Container.TargetGameplayEffectClasses)</span><br><span class="line">        &#123;</span><br><span class="line">            ReturnSpec.TargetGameplayEffectSpecs.Add(MakeOutgoingGameplayEffectSpec(EffectClass, OverrideGameplayLevel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ReturnSpec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FRPGGameplayEffectContainerSpec URPGGameplayAbility::MakeEffectContainerSpec(FGameplayTag ContainerTag, const FGameplayEventData&amp; EventData, int32 OverrideGameplayLevel)</span><br><span class="line">&#123;</span><br><span class="line">    FRPGGameplayEffectContainer* FoundContainer = EffectContainerMap.Find(ContainerTag);</span><br><span class="line"></span><br><span class="line">    if (FoundContainer)</span><br><span class="line">    &#123;</span><br><span class="line">        return MakeEffectContainerSpecFromContainer(*FoundContainer, EventData, OverrideGameplayLevel);</span><br><span class="line">    &#125;</span><br><span class="line">    return FRPGGameplayEffectContainerSpec();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TArray&lt;FActiveGameplayEffectHandle&gt; URPGGameplayAbility::ApplyEffectContainerSpec(const FRPGGameplayEffectContainerSpec&amp; ContainerSpec)</span><br><span class="line">&#123;</span><br><span class="line">    TArray&lt;FActiveGameplayEffectHandle&gt; AllEffects;</span><br><span class="line"></span><br><span class="line">    // Iterate list of effect specs and apply them to their target data</span><br><span class="line">    for (const FGameplayEffectSpecHandle&amp; SpecHandle : ContainerSpec.TargetGameplayEffectSpecs)</span><br><span class="line">    &#123;</span><br><span class="line">        AllEffects.Append(K2_ApplyGameplayEffectSpecToTarget(SpecHandle, ContainerSpec.TargetData));</span><br><span class="line">    &#125;</span><br><span class="line">    return AllEffects;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TArray&lt;FActiveGameplayEffectHandle&gt; URPGGameplayAbility::ApplyEffectContainer(FGameplayTag ContainerTag, const FGameplayEventData&amp; EventData, int32 OverrideGameplayLevel)</span><br><span class="line">&#123;</span><br><span class="line">    FRPGGameplayEffectContainerSpec Spec = MakeEffectContainerSpec(ContainerTag, EventData, OverrideGameplayLevel);</span><br><span class="line">    return ApplyEffectContainerSpec(Spec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="辅助类声明"><a href="#辅助类声明" class="headerlink" title="辅助类声明"></a>辅助类声明</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Struct defining a list of gameplay effects, a tag, and targeting info</span><br><span class="line"> * These containers are defined statically in blueprints or assets and then turn into Specs at runtime</span><br><span class="line"> */</span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line">struct FRPGGameplayEffectContainer</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line">public:</span><br><span class="line">    FRPGGameplayEffectContainer() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    /** Sets the way that targeting happens */</span><br><span class="line">    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = GameplayEffectContainer)</span><br><span class="line">    TSubclassOf&lt;URPGTargetType&gt; TargetType;</span><br><span class="line"></span><br><span class="line">    /** List of gameplay effects to apply to the targets */</span><br><span class="line">    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = GameplayEffectContainer)</span><br><span class="line">    TArray&lt;TSubclassOf&lt;UGameplayEffect&gt;&gt; TargetGameplayEffectClasses;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Class that is used to determine targeting for abilities</span><br><span class="line"> * It is meant to be blueprinted to run target logic</span><br><span class="line"> * This does not subclass GameplayAbilityTargetActor because this class is never instanced into the world</span><br><span class="line"> * This can be used as a basis for a game-specific targeting blueprint</span><br><span class="line"> * If your targeting is more complicated you may need to instance into the world once or as a pooled actor</span><br><span class="line"> */</span><br><span class="line">UCLASS(Blueprintable, meta = (ShowWorldContextPin))</span><br><span class="line">class ACTIONRPG_API URPGTargetType : public UObject</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line">public:</span><br><span class="line">    // Constructor and overrides</span><br><span class="line">    URPGTargetType() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    /** Called to determine targets to apply gameplay effects to */</span><br><span class="line">    UFUNCTION(BlueprintNativeEvent)</span><br><span class="line">    void GetTargets(ARPGCharacterBase* TargetingCharacter, AActor* TargetingActor, FGameplayEventData EventData, TArray&lt;FHitResult&gt;&amp; OutHitResults, TArray&lt;AActor*&gt;&amp; OutActors) const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/** Trivial target type that uses the owner */</span><br><span class="line">UCLASS(NotBlueprintable)</span><br><span class="line">class ACTIONRPG_API URPGTargetType_UseOwner : public URPGTargetType</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line">public:</span><br><span class="line">    // Constructor and overrides</span><br><span class="line">    URPGTargetType_UseOwner() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    /** Uses the passed in event data */</span><br><span class="line">    virtual void GetTargets_Implementation(ARPGCharacterBase* TargetingCharacter, AActor* TargetingActor, FGameplayEventData EventData, TArray&lt;FHitResult&gt;&amp; OutHitResults, TArray&lt;AActor*&gt;&amp; OutActors) const override;</span><br><span class="line"></span><br><span class="line">    //cpp实现逻辑</span><br><span class="line">    void URPGTargetType_UseOwner::GetTargets_Implementation(ARPGCharacterBase* TargetingCharacter, AActor* TargetingActor, FGameplayEventData EventData, TArray&lt;FHitResult&gt;&amp; OutHitResults, TArray&lt;AActor*&gt;&amp; OutActors) const</span><br><span class="line">    &#123;</span><br><span class="line">        OutActors.Add(TargetingCharacter);</span><br><span class="line">    &#125;</span><br><span class="line">    //</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/** Trivial target type that pulls the target out of the event data */</span><br><span class="line">UCLASS(NotBlueprintable)</span><br><span class="line">class ACTIONRPG_API URPGTargetType_UseEventData : public URPGTargetType</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line">public:</span><br><span class="line">    // Constructor and overrides</span><br><span class="line">    URPGTargetType_UseEventData() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    /** Uses the passed in event data */</span><br><span class="line">    virtual void GetTargets_Implementation(ARPGCharacterBase* TargetingCharacter, AActor* TargetingActor, FGameplayEventData EventData, TArray&lt;FHitResult&gt;&amp; OutHitResults, TArray&lt;AActor*&gt;&amp; OutActors) const override;</span><br><span class="line"></span><br><span class="line">    //cpp实现逻辑：</span><br><span class="line">    void URPGTargetType_UseEventData::GetTargets_Implementation(ARPGCharacterBase* TargetingCharacter, AActor* TargetingActor, FGameplayEventData EventData, TArray&lt;FHitResult&gt;&amp; OutHitResults, TArray&lt;AActor*&gt;&amp; OutActors) const</span><br><span class="line">    &#123;</span><br><span class="line">        const FHitResult* FoundHitResult = EventData.ContextHandle.GetHitResult();</span><br><span class="line">        if (FoundHitResult)</span><br><span class="line">        &#123;</span><br><span class="line">            OutHitResults.Add(*FoundHitResult);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (EventData.Target)</span><br><span class="line">        &#123;</span><br><span class="line">            //OutActors.Add(const_cast&lt;AActor*&gt;(EventData.Target));</span><br><span class="line">            OutActors.Add(const_cast&lt;AActor*&gt;(ToRawPtr(EventData.Target)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>主要是用Tag来映射对应的GEList。一个GA可以通过不同的Tag来应用不同的GEList。中间的函数会帮助确定GE的应用对象（Target），并创建对应的GESpec来处理GE应用逻辑。</p>
<h2 id="目标筛选与Tag"><a href="#目标筛选与Tag" class="headerlink" title="目标筛选与Tag"></a>目标筛选与Tag</h2><h3 id="PlayMontageAndWaitForEvent"><a href="#PlayMontageAndWaitForEvent" class="headerlink" title="PlayMontageAndWaitForEvent"></a>PlayMontageAndWaitForEvent</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class URPGAbilitySystemComponent;</span><br><span class="line"></span><br><span class="line">/** Delegate type used, EventTag and Payload may be empty if it came from the montage callbacks */</span><br><span class="line">DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FRPGPlayMontageAndWaitForEventDelegate, FGameplayTag, EventTag, FGameplayEventData, EventData);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * This task combines PlayMontageAndWait and WaitForEvent into one task, so you can wait for multiple types of activations such as from a melee combo</span><br><span class="line"> * Much of this code is copied from one of those two ability tasks</span><br><span class="line"> * This is a good task to look at as an example when creating game-specific tasks</span><br><span class="line"> * It is expected that each game will have a set of game-specific tasks to do what they want</span><br><span class="line"> */</span><br><span class="line">UCLASS()</span><br><span class="line">class ACTIONRPG_API URPGAbilityTask_PlayMontageAndWaitForEvent : public UAbilityTask</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line">public:</span><br><span class="line">    // Constructor and overrides</span><br><span class="line">    URPGAbilityTask_PlayMontageAndWaitForEvent(const FObjectInitializer&amp; ObjectInitializer);</span><br><span class="line">    virtual void Activate() override;</span><br><span class="line">    virtual void ExternalCancel() override;</span><br><span class="line">    virtual FString GetDebugString() const override;</span><br><span class="line">    virtual void OnDestroy(bool AbilityEnded) override;</span><br><span class="line"></span><br><span class="line">    /** The montage completely finished playing */</span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FRPGPlayMontageAndWaitForEventDelegate OnCompleted;</span><br><span class="line"></span><br><span class="line">    /** The montage started blending out */</span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FRPGPlayMontageAndWaitForEventDelegate OnBlendOut;</span><br><span class="line"></span><br><span class="line">    /** The montage was interrupted */</span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FRPGPlayMontageAndWaitForEventDelegate OnInterrupted;</span><br><span class="line"></span><br><span class="line">    /** The ability task was explicitly cancelled by another ability */</span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FRPGPlayMontageAndWaitForEventDelegate OnCancelled;</span><br><span class="line"></span><br><span class="line">    /** One of the triggering gameplay events happened */</span><br><span class="line">    UPROPERTY(BlueprintAssignable)</span><br><span class="line">    FRPGPlayMontageAndWaitForEventDelegate EventReceived;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        * Play a montage and wait for it end. If a gameplay event happens that matches EventTags (or EventTags is empty), the EventReceived delegate will fire with a tag and event data.</span><br><span class="line">        * If StopWhenAbilityEnds is true, this montage will be aborted if the ability ends normally. It is always stopped when the ability is explicitly cancelled.</span><br><span class="line">        * On normal execution, OnBlendOut is called when the montage is blending out, and OnCompleted when it is completely done playing</span><br><span class="line">        * OnInterrupted is called if another montage overwrites this, and OnCancelled is called if the ability or task is cancelled</span><br><span class="line">        *</span><br><span class="line">        * @param TaskInstanceName Set to override the name of this task, for later querying</span><br><span class="line">        * @param MontageToPlay The montage to play on the character</span><br><span class="line">        * @param EventTags Any gameplay events matching this tag will activate the EventReceived callback. If empty, all events will trigger callback</span><br><span class="line">        * @param Rate Change to play the montage faster or slower</span><br><span class="line">        * @param bStopWhenAbilityEnds If true, this montage will be aborted if the ability ends normally. It is always stopped when the ability is explicitly cancelled</span><br><span class="line">        * @param AnimRootMotionTranslationScale Change to modify size of root motion or set to 0 to block it entirely</span><br><span class="line">        */</span><br><span class="line">    UFUNCTION(BlueprintCallable, Category=&quot;Ability|Tasks&quot;, meta = (HidePin = &quot;OwningAbility&quot;, DefaultToSelf = &quot;OwningAbility&quot;, BlueprintInternalUseOnly = &quot;TRUE&quot;))</span><br><span class="line">    static URPGAbilityTask_PlayMontageAndWaitForEvent* PlayMontageAndWaitForEvent(</span><br><span class="line">        UGameplayAbility* OwningAbility,</span><br><span class="line">        FName TaskInstanceName,</span><br><span class="line">        UAnimMontage* MontageToPlay,</span><br><span class="line">        FGameplayTagContainer EventTags,</span><br><span class="line">        float Rate = 1.f,</span><br><span class="line">        FName StartSection = NAME_None,</span><br><span class="line">        bool bStopWhenAbilityEnds = true,</span><br><span class="line">        float AnimRootMotionTranslationScale = 1.f);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    /** Montage that is playing */</span><br><span class="line">    UPROPERTY()</span><br><span class="line">    UAnimMontage* MontageToPlay;</span><br><span class="line"></span><br><span class="line">    //关键参数</span><br><span class="line">    /** List of tags to match against gameplay events */</span><br><span class="line">    UPROPERTY()</span><br><span class="line">    FGameplayTagContainer EventTags;</span><br><span class="line"></span><br><span class="line">    /** Playback rate */</span><br><span class="line">    UPROPERTY()</span><br><span class="line">    float Rate;</span><br><span class="line"></span><br><span class="line">    /** Section to start montage from */</span><br><span class="line">    UPROPERTY()</span><br><span class="line">    FName StartSection;</span><br><span class="line"></span><br><span class="line">    /** Modifies how root motion movement to apply */</span><br><span class="line">    UPROPERTY()</span><br><span class="line">    float AnimRootMotionTranslationScale;</span><br><span class="line"></span><br><span class="line">    /** Rather montage should be aborted if ability ends */</span><br><span class="line">    UPROPERTY()</span><br><span class="line">    bool bStopWhenAbilityEnds;</span><br><span class="line"></span><br><span class="line">    /** Checks if the ability is playing a montage and stops that montage, returns true if a montage was stopped, false if not. */</span><br><span class="line">    bool StopPlayingMontage();</span><br><span class="line"></span><br><span class="line">    /** Returns our ability system component */</span><br><span class="line">    URPGAbilitySystemComponent* GetTargetASC();</span><br><span class="line"></span><br><span class="line">    void OnMontageBlendingOut(UAnimMontage* Montage, bool bInterrupted);</span><br><span class="line">    void OnAbilityCancelled();</span><br><span class="line">    void OnMontageEnded(UAnimMontage* Montage, bool bInterrupted);</span><br><span class="line">    void OnGameplayEvent(FGameplayTag EventTag, const FGameplayEventData* Payload);</span><br><span class="line"></span><br><span class="line">    FOnMontageBlendingOutStarted BlendingOutDelegate;</span><br><span class="line">    FOnMontageEnded MontageEndedDelegate;</span><br><span class="line">    FDelegateHandle CancelledHandle;</span><br><span class="line">    FDelegateHandle EventHandle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">URPGAbilityTask_PlayMontageAndWaitForEvent::URPGAbilityTask_PlayMontageAndWaitForEvent(const FObjectInitializer&amp; ObjectInitializer)</span><br><span class="line">    : Super(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">    Rate = 1.f;</span><br><span class="line">    bStopWhenAbilityEnds = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">URPGAbilitySystemComponent* URPGAbilityTask_PlayMontageAndWaitForEvent::GetTargetASC()</span><br><span class="line">&#123;</span><br><span class="line">    return Cast&lt;URPGAbilitySystemComponent&gt;(AbilitySystemComponent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void URPGAbilityTask_PlayMontageAndWaitForEvent::OnMontageBlendingOut(UAnimMontage* Montage, bool bInterrupted)</span><br><span class="line">&#123;</span><br><span class="line">    if (Ability &amp;&amp; Ability-&gt;GetCurrentMontage() == MontageToPlay)</span><br><span class="line">    &#123;</span><br><span class="line">        if (Montage == MontageToPlay)</span><br><span class="line">        &#123;</span><br><span class="line">            AbilitySystemComponent-&gt;ClearAnimatingAbility(Ability);</span><br><span class="line"></span><br><span class="line">            // Reset AnimRootMotionTranslationScale</span><br><span class="line">            ACharacter* Character = Cast&lt;ACharacter&gt;(GetAvatarActor());</span><br><span class="line">            if (Character &amp;&amp; (Character-&gt;GetLocalRole() == ROLE_Authority ||</span><br><span class="line">                                (Character-&gt;GetLocalRole() == ROLE_AutonomousProxy &amp;&amp; Ability-&gt;GetNetExecutionPolicy() == EGameplayAbilityNetExecutionPolicy::LocalPredicted)))</span><br><span class="line">            &#123;</span><br><span class="line">                Character-&gt;SetAnimRootMotionTranslationScale(1.f);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (bInterrupted)</span><br><span class="line">    &#123;</span><br><span class="line">        if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">        &#123;</span><br><span class="line">            OnInterrupted.Broadcast(FGameplayTag(), FGameplayEventData());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">        &#123;</span><br><span class="line">            OnBlendOut.Broadcast(FGameplayTag(), FGameplayEventData());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void URPGAbilityTask_PlayMontageAndWaitForEvent::OnAbilityCancelled()</span><br><span class="line">&#123;</span><br><span class="line">    // TODO: Merge this fix back to engine, it was calling the wrong callback</span><br><span class="line"></span><br><span class="line">    if (StopPlayingMontage())</span><br><span class="line">    &#123;</span><br><span class="line">        // Let the BP handle the interrupt as well</span><br><span class="line">        if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">        &#123;</span><br><span class="line">            OnCancelled.Broadcast(FGameplayTag(), FGameplayEventData());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void URPGAbilityTask_PlayMontageAndWaitForEvent::OnMontageEnded(UAnimMontage* Montage, bool bInterrupted)</span><br><span class="line">&#123;</span><br><span class="line">    if (!bInterrupted)</span><br><span class="line">    &#123;</span><br><span class="line">        if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">        &#123;</span><br><span class="line">            OnCompleted.Broadcast(FGameplayTag(), FGameplayEventData());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EndTask();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//重点广播函数</span><br><span class="line">void URPGAbilityTask_PlayMontageAndWaitForEvent::OnGameplayEvent(FGameplayTag EventTag, const FGameplayEventData* Payload)</span><br><span class="line">&#123;</span><br><span class="line">    if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">    &#123;</span><br><span class="line">        FGameplayEventData TempData = *Payload;</span><br><span class="line">        TempData.EventTag = EventTag;</span><br><span class="line"></span><br><span class="line">        EventReceived.Broadcast(EventTag, TempData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">URPGAbilityTask_PlayMontageAndWaitForEvent* URPGAbilityTask_PlayMontageAndWaitForEvent::PlayMontageAndWaitForEvent(UGameplayAbility* OwningAbility,</span><br><span class="line">    FName TaskInstanceName, UAnimMontage* MontageToPlay, FGameplayTagContainer EventTags, float Rate, FName StartSection, bool bStopWhenAbilityEnds, float AnimRootMotionTranslationScale)</span><br><span class="line">&#123;</span><br><span class="line">    //静态工厂函数。这部分和PlayMontageAndWait大差不差</span><br><span class="line">    UAbilitySystemGlobals::NonShipping_ApplyGlobalAbilityScaler_Rate(Rate);</span><br><span class="line"></span><br><span class="line">    URPGAbilityTask_PlayMontageAndWaitForEvent* MyObj = NewAbilityTask&lt;URPGAbilityTask_PlayMontageAndWaitForEvent&gt;(OwningAbility, TaskInstanceName);</span><br><span class="line">    MyObj-&gt;MontageToPlay = MontageToPlay;</span><br><span class="line">    MyObj-&gt;EventTags = EventTags;</span><br><span class="line">    MyObj-&gt;Rate = Rate;</span><br><span class="line">    MyObj-&gt;StartSection = StartSection;</span><br><span class="line">    MyObj-&gt;AnimRootMotionTranslationScale = AnimRootMotionTranslationScale;</span><br><span class="line">    MyObj-&gt;bStopWhenAbilityEnds = bStopWhenAbilityEnds;</span><br><span class="line"></span><br><span class="line">    return MyObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void URPGAbilityTask_PlayMontageAndWaitForEvent::Activate()</span><br><span class="line">&#123;</span><br><span class="line">    //这部分也是和PlayMontageAndWait大体相似</span><br><span class="line"></span><br><span class="line">    if (Ability == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool bPlayedMontage = false;</span><br><span class="line">    URPGAbilitySystemComponent* RPGAbilitySystemComponent = GetTargetASC();</span><br><span class="line"></span><br><span class="line">    if (RPGAbilitySystemComponent)</span><br><span class="line">    &#123;</span><br><span class="line">        const FGameplayAbilityActorInfo* ActorInfo = Ability-&gt;GetCurrentActorInfo();</span><br><span class="line">        UAnimInstance* AnimInstance = ActorInfo-&gt;GetAnimInstance();</span><br><span class="line">        if (AnimInstance != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            //关键事件侦听函数</span><br><span class="line">            // Bind to event callback</span><br><span class="line">            EventHandle = RPGAbilitySystemComponent-&gt;AddGameplayEventTagContainerDelegate(EventTags, FGameplayEventTagMulticastDelegate::FDelegate::CreateUObject(this, &amp;URPGAbilityTask_PlayMontageAndWaitForEvent::OnGameplayEvent));</span><br><span class="line"></span><br><span class="line">            if (RPGAbilitySystemComponent-&gt;PlayMontage(Ability, Ability-&gt;GetCurrentActivationInfo(), MontageToPlay, Rate, StartSection) &gt; 0.f)</span><br><span class="line">            &#123;</span><br><span class="line">                // Playing a montage could potentially fire off a callback into game code which could kill this ability! Early out if we are  pending kill.</span><br><span class="line">                if (ShouldBroadcastAbilityTaskDelegates() == false)</span><br><span class="line">                &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                CancelledHandle = Ability-&gt;OnGameplayAbilityCancelled.AddUObject(this, &amp;URPGAbilityTask_PlayMontageAndWaitForEvent::OnAbilityCancelled);</span><br><span class="line"></span><br><span class="line">                BlendingOutDelegate.BindUObject(this, &amp;URPGAbilityTask_PlayMontageAndWaitForEvent::OnMontageBlendingOut);</span><br><span class="line">                AnimInstance-&gt;Montage_SetBlendingOutDelegate(BlendingOutDelegate, MontageToPlay);</span><br><span class="line"></span><br><span class="line">                MontageEndedDelegate.BindUObject(this, &amp;URPGAbilityTask_PlayMontageAndWaitForEvent::OnMontageEnded);</span><br><span class="line">                AnimInstance-&gt;Montage_SetEndDelegate(MontageEndedDelegate, MontageToPlay);</span><br><span class="line"></span><br><span class="line">                ACharacter* Character = Cast&lt;ACharacter&gt;(GetAvatarActor());</span><br><span class="line">                if (Character &amp;&amp; (Character-&gt;GetLocalRole() == ROLE_Authority ||</span><br><span class="line">                                    (Character-&gt;GetLocalRole() == ROLE_AutonomousProxy &amp;&amp; Ability-&gt;GetNetExecutionPolicy() == EGameplayAbilityNetExecutionPolicy::LocalPredicted)))</span><br><span class="line">                &#123;</span><br><span class="line">                    Character-&gt;SetAnimRootMotionTranslationScale(AnimRootMotionTranslationScale);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                bPlayedMontage = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            ABILITY_LOG(Warning, TEXT(&quot;URPGAbilityTask_PlayMontageAndWaitForEvent call to PlayMontage failed!&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        ABILITY_LOG(Warning, TEXT(&quot;URPGAbilityTask_PlayMontageAndWaitForEvent called on invalid AbilitySystemComponent&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!bPlayedMontage)</span><br><span class="line">    &#123;</span><br><span class="line">        ABILITY_LOG(Warning, TEXT(&quot;URPGAbilityTask_PlayMontageAndWaitForEvent called in Ability %s failed to play montage %s; Task Instance Name %s.&quot;), *Ability-&gt;GetName(), *GetNameSafe(MontageToPlay),*InstanceName.ToString());</span><br><span class="line">        if (ShouldBroadcastAbilityTaskDelegates())</span><br><span class="line">        &#123;</span><br><span class="line">            OnCancelled.Broadcast(FGameplayTag(), FGameplayEventData());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SetWaitingOnAvatar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void URPGAbilityTask_PlayMontageAndWaitForEvent::ExternalCancel()</span><br><span class="line">&#123;</span><br><span class="line">    UAbilitySystemComponent* ASC = GetTargetASC();</span><br><span class="line"></span><br><span class="line">    if (ASC)</span><br><span class="line">    //check(AbilitySystemComponent);</span><br><span class="line"></span><br><span class="line">    OnAbilityCancelled();</span><br><span class="line"></span><br><span class="line">    Super::ExternalCancel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void URPGAbilityTask_PlayMontageAndWaitForEvent::OnDestroy(bool AbilityEnded)</span><br><span class="line">&#123;</span><br><span class="line">    // Note: Clearing montage end delegate isn&#x27;t necessary since its not a multicast and will be cleared when the next montage plays.</span><br><span class="line">    // (If we are destroyed, it will detect this and not do anything)</span><br><span class="line"></span><br><span class="line">    // This delegate, however, should be cleared as it is a multicast</span><br><span class="line">    if (Ability)</span><br><span class="line">    &#123;</span><br><span class="line">        Ability-&gt;OnGameplayAbilityCancelled.Remove(CancelledHandle);</span><br><span class="line">        if (AbilityEnded &amp;&amp; bStopWhenAbilityEnds)</span><br><span class="line">        &#123;</span><br><span class="line">            StopPlayingMontage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    URPGAbilitySystemComponent* RPGAbilitySystemComponent = GetTargetASC();</span><br><span class="line">    if (RPGAbilitySystemComponent)</span><br><span class="line">    &#123;</span><br><span class="line">        RPGAbilitySystemComponent-&gt;RemoveGameplayEventTagContainerDelegate(EventTags, EventHandle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Super::OnDestroy(AbilityEnded);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool URPGAbilityTask_PlayMontageAndWaitForEvent::StopPlayingMontage()</span><br><span class="line">&#123;</span><br><span class="line">    const FGameplayAbilityActorInfo* ActorInfo = Ability-&gt;GetCurrentActorInfo();</span><br><span class="line">    if (!ActorInfo)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UAnimInstance* AnimInstance = ActorInfo-&gt;GetAnimInstance();</span><br><span class="line">    if (AnimInstance == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Check if the montage is still playing</span><br><span class="line">    // The ability would have been interrupted, in which case we should automatically stop the montage</span><br><span class="line">    UAbilitySystemComponent* ASC = GetTargetASC();</span><br><span class="line"></span><br><span class="line">    if (ASC &amp;&amp; Ability)</span><br><span class="line">    //if (AbilitySystemComponent &amp;&amp; Ability)</span><br><span class="line">    &#123;</span><br><span class="line">        if (AbilitySystemComponent-&gt;GetAnimatingAbility() == Ability</span><br><span class="line">            &amp;&amp; AbilitySystemComponent-&gt;GetCurrentMontage() == MontageToPlay)</span><br><span class="line">        &#123;</span><br><span class="line">            // Unbind delegates so they don&#x27;t get called as well</span><br><span class="line">            FAnimMontageInstance* MontageInstance = AnimInstance-&gt;GetActiveInstanceForMontage(MontageToPlay);</span><br><span class="line">            if (MontageInstance)</span><br><span class="line">            &#123;</span><br><span class="line">                MontageInstance-&gt;OnMontageBlendingOutStarted.Unbind();</span><br><span class="line">                MontageInstance-&gt;OnMontageEnded.Unbind();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            AbilitySystemComponent-&gt;CurrentMontageStop();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FString URPGAbilityTask_PlayMontageAndWaitForEvent::GetDebugString() const</span><br><span class="line">&#123;</span><br><span class="line">    UAnimMontage* PlayingMontage = nullptr;</span><br><span class="line">    if (Ability)</span><br><span class="line">    &#123;</span><br><span class="line">        const FGameplayAbilityActorInfo* ActorInfo = Ability-&gt;GetCurrentActorInfo();</span><br><span class="line">        UAnimInstance* AnimInstance = ActorInfo-&gt;GetAnimInstance();</span><br><span class="line"></span><br><span class="line">        if (AnimInstance != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            PlayingMontage = AnimInstance-&gt;Montage_IsActive(MontageToPlay) ? MontageToPlay : AnimInstance-&gt;GetCurrentActiveMontage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return FString::Printf(TEXT(&quot;PlayMontageAndWaitForEvent. MontageToPlay: %s  (Currently Playing): %s&quot;), *GetNameSafe(MontageToPlay), *GetNameSafe(PlayingMontage));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="蒙太奇播放与Notify"><a href="#蒙太奇播放与Notify" class="headerlink" title="蒙太奇播放与Notify"></a>蒙太奇播放与Notify</h2><img src="/UE/Project/Lyra/UE55Lyra6/image-3.png" class="" title="alt text">
<p>这里有两个相对关键重要的Notify<br>1.Weapon Attack NS<br>2.Jump Section NS</p>
<h3 id="WeaponAttackNS"><a href="#WeaponAttackNS" class="headerlink" title="WeaponAttackNS"></a>WeaponAttackNS</h3><p>这个动画通知主要用于启用武器攻击检测。<br>关键参数 - EventTag<br>具体的检测逻辑 放在WeaponActor上。<br>逻辑链条：<br>RecNotifyBegin -&gt; 获取Actor -&gt; 获取Weapon -&gt; Weapon设置开始攻击检测<br>RecNotifyEnd -&gt; 获取Actor -&gt; 获取Weapon -&gt; Weapon设置结束攻击检测</p>
<h4 id="攻击检测"><a href="#攻击检测" class="headerlink" title="攻击检测"></a>攻击检测</h4><p>看到WeaponActor。实际上还是在某段时间内，启用Capsule碰撞体积来实现的。</p>
<p>碰撞逻辑内部使用了DoOnce,并用结束碰撞的延迟来做DoOnce的Reset，从而设置攻击间隔。在进行了目标非发出者(Instigator)的检测后，使用目标和发出者来构造GameplayEventData,并使用SendGameplayEventToActor将Tag和构造的GameplayEventData发送给发出者。</p>
<p>ASC::HandleGameplayEvent -&gt; ASC的GameplayEventTagContainerDelegates进行广播。</p>
<h3 id="JumpSectionNS"><a href="#JumpSectionNS" class="headerlink" title="JumpSectionNS"></a>JumpSectionNS</h3><p>主要是理解ActionRPG中，Combo的实现方式。<br>在这个项目中，一个攻击的多个连段是放在同一个蒙太奇里做的，分为了不同的Section。Combo其实是在不同的Section中进行切换。</p>
<p>Character上存在一个EnableComboPeriod标志位，NotifyBegin与End的时候设置该标志位。<br>在Notify上会存一个JumpSection的信息。</p>
<img src="/UE/Project/Lyra/UE55Lyra6/image4.png" class="" title="alt text">
<img src="/UE/Project/Lyra/UE55Lyra6/image5.png" class="" title="alt text">
<p>可以看到，仅有第一个Combo会使用GA。后面的只是切换蒙太奇片段。<br>这种设计并不严谨。</p>
<h1 id="网络延迟模拟和测试"><a href="#网络延迟模拟和测试" class="headerlink" title="网络延迟模拟和测试"></a>网络延迟模拟和测试</h1><p>还是以Lyra项目为例子<br>NetMode使用Play As Client，并设置为2个玩家来作为测试样例。<br>网络延迟可以在下面的AdvancedSettings来进行设置</p>
<img src="/UE/Project/Lyra/UE55Lyra6/image.png" class="" title="alt text">
<p>通过网络延迟，可以更好的看到客户端的预测效果和情况。</p>
<p>如果这里的网络延迟没有生效，可以尝试以下配置。</p>
<img src="/UE/Project/Lyra/UE55Lyra6/image6.png" class="" title="alt text">

<h1 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h1><p>ActionRPG的生命值相关改动 还是通过GE来实现的。定义为“PassivegGameplayEffects”。<br>ActionRPG的设计和实现，可以看出来还是针对单机模式的。包括连击的实现，也没有使用多个GA，仅在第一次触发的时候使用了GA。可以参考其武器近战攻击的碰撞检测实现，以及连击的Notify设置，但这块最好还是用Tag来做比较好。</p>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>GAS</tag>
        <tag>Lyra</tag>
      </tags>
  </entry>
  <entry>
    <title>UE5.5-Lyra-8-Shooting</title>
    <url>/UE/Project/Lyra/UE55Lyra8/</url>
    <content><![CDATA[<p>主要分析Lyra项目射击的完整流程。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>深入分析的时候，GAS的调试工具就很重要了。<br>可以参考官方GAS插件目录下的Readme文件。</p>
<h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行 &#96;"></a>命令行 &#96;</h2><h2 id="基础调试命令"><a href="#基础调试命令" class="headerlink" title="基础调试命令"></a>基础调试命令</h2><p>启用GAS调试 - ShowDebug AbilitySystem</p>
<p>切换目录 - AbilitySystem.Debug.NextCategory</p>
<h1 id="Lyra射击分析"><a href="#Lyra射击分析" class="headerlink" title="Lyra射击分析"></a>Lyra射击分析</h1><h2 id="主要GA分析"><a href="#主要GA分析" class="headerlink" title="主要GA分析"></a>主要GA分析</h2><h3 id="类继承图"><a href="#类继承图" class="headerlink" title="类继承图"></a>类继承图</h3><p>以手枪射击为例子<br>GA_Weapon_Fire_Pistol<br>↑<br>GA_Weapon_Fire<br>↑<br>ULyraGameplayAbility_RangedWeapon<br>↑<br>ULyraGameplayAbility_FromEquipment<br>↑<br>ULyraGameplayAbility</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>从ActivateAbility来看。<br>逻辑处理函数:</p>
<ul>
<li>(Locally Controlled判定) - StartRangedWeaponTargeting</li>
</ul>
<p>表现处理函数：</p>
<ul>
<li>播放蒙太奇异步任务 PlayMontageAndWait</li>
</ul>
<p>这里比较巧妙的一点是，由人物的蒙太奇播放，添加动画通知，驱动了武器蒙太奇动画的播放。</p>
<p>StartRangedWeaponTargeting：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void ULyraGameplayAbility_RangedWeapon::StartRangedWeaponTargeting()</span><br><span class="line">&#123;</span><br><span class="line">  check(CurrentActorInfo);</span><br><span class="line"></span><br><span class="line">  AActor* AvatarActor = CurrentActorInfo-&gt;AvatarActor.Get();</span><br><span class="line">  check(AvatarActor);</span><br><span class="line"></span><br><span class="line">  UAbilitySystemComponent* MyAbilityComponent = CurrentActorInfo-&gt;AbilitySystemComponent.Get();</span><br><span class="line">  check(MyAbilityComponent);</span><br><span class="line"></span><br><span class="line">  AController* Controller = GetControllerFromActorInfo();</span><br><span class="line">  check(Controller);</span><br><span class="line"></span><br><span class="line">  //继承自UControllerComponent.(用于接受Controller的Events)</span><br><span class="line">  //Tracks weapon state and recent confirmed hit markers to display on screen</span><br><span class="line">  ULyraWeaponStateComponent* WeaponStateComponent = Controller-&gt;FindComponentByClass&lt;ULyraWeaponStateComponent&gt;();</span><br><span class="line"></span><br><span class="line">  //预测窗口</span><br><span class="line">  FScopedPredictionWindow ScopedPrediction(MyAbilityComponent, CurrentActivationInfo.GetActivationPredictionKey());</span><br><span class="line"></span><br><span class="line">  TArray&lt;FHitResult&gt; FoundHits;</span><br><span class="line"></span><br><span class="line">  //关键函数</span><br><span class="line">  PerformLocalTargeting(/*out*/ FoundHits);</span><br><span class="line"></span><br><span class="line">  // Fill out the target data from the hit results</span><br><span class="line">  FGameplayAbilityTargetDataHandle TargetData;</span><br><span class="line">  TargetData.UniqueId = WeaponStateComponent ? WeaponStateComponent-&gt;GetUnconfirmedServerSideHitMarkerCount() : 0;</span><br><span class="line"></span><br><span class="line">  //处理TargetData</span><br><span class="line">  if (FoundHits.Num() &gt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    const int32 CartridgeID = FMath::Rand();</span><br><span class="line"></span><br><span class="line">    for (const FHitResult&amp; FoundHit : FoundHits)</span><br><span class="line">    &#123;</span><br><span class="line">      FLyraGameplayAbilityTargetData_SingleTargetHit* NewTargetData = new FLyraGameplayAbilityTargetData_SingleTargetHit();</span><br><span class="line">      NewTargetData-&gt;HitResult = FoundHit;</span><br><span class="line">      NewTargetData-&gt;CartridgeID = CartridgeID;</span><br><span class="line"></span><br><span class="line">      TargetData.Add(NewTargetData);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Send hit marker information</span><br><span class="line">  const bool bProjectileWeapon = false;</span><br><span class="line">  if (!bProjectileWeapon &amp;&amp; (WeaponStateComponent != nullptr))</span><br><span class="line">  &#123;</span><br><span class="line">    WeaponStateComponent-&gt;AddUnconfirmedServerSideHitMarkers(TargetData, FoundHits);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Process the target data immediately</span><br><span class="line">  OnTargetDataReadyCallback(TargetData, FGameplayTag());</span><br><span class="line"></span><br><span class="line">  //预测窗口结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总体而言还是比较复杂的 一个一个来吧。</p>
<h4 id="目标逻辑数据的获取-PerformLocalTargeting"><a href="#目标逻辑数据的获取-PerformLocalTargeting" class="headerlink" title="目标逻辑数据的获取 - PerformLocalTargeting"></a>目标逻辑数据的获取 - PerformLocalTargeting</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void ULyraGameplayAbility_RangedWeapon::PerformLocalTargeting(OUT TArray&lt;FHitResult&gt;&amp; OutHits)</span><br><span class="line">&#123;</span><br><span class="line">  APawn* const AvatarPawn = Cast&lt;APawn&gt;(GetAvatarActorFromActorInfo());</span><br><span class="line"></span><br><span class="line">  ULyraRangedWeaponInstance* WeaponData = GetWeaponInstance();</span><br><span class="line"></span><br><span class="line">  //还是一样的 IsLocallyControlled判断。</span><br><span class="line">  if (AvatarPawn &amp;&amp; AvatarPawn-&gt;IsLocallyControlled() &amp;&amp; WeaponData)</span><br><span class="line">  &#123;</span><br><span class="line">    FRangedWeaponFiringInput InputData;</span><br><span class="line">    //武器数据</span><br><span class="line">    InputData.WeaponData = WeaponData;</span><br><span class="line"></span><br><span class="line">    //非专用服务器时可以播放特效</span><br><span class="line">    InputData.bCanPlayBulletFX = (AvatarPawn-&gt;GetNetMode() != NM_DedicatedServer);</span><br><span class="line"></span><br><span class="line">    //开始做射线检测相关工作</span><br><span class="line">    //@TODO: Should do more complicated logic here when the player is close to a wall, etc...</span><br><span class="line">    //选取射线检测的位置和方向</span><br><span class="line">    const FTransform TargetTransform = GetTargetingTransform(AvatarPawn, ELyraAbilityTargetingSource::CameraTowardsFocus);</span><br><span class="line"></span><br><span class="line">    InputData.AimDir = TargetTransform.GetUnitAxis(EAxis::X);</span><br><span class="line"></span><br><span class="line">    InputData.StartTrace = TargetTransform.GetTranslation();</span><br><span class="line"></span><br><span class="line">    InputData.EndAim = InputData.StartTrace + InputData.AimDir * WeaponData-&gt;GetMaxDamageRange();</span><br><span class="line"></span><br><span class="line">  #if ENABLE_DRAW_DEBUG</span><br><span class="line">    if (LyraConsoleVariables::DrawBulletTracesDuration &gt; 0.0f)</span><br><span class="line">    &#123;</span><br><span class="line">      static float DebugThickness = 2.0f;</span><br><span class="line">      DrawDebugLine(GetWorld(), InputData.StartTrace, InputData.StartTrace + (InputData.AimDir * 100.0f), FColor::Yellow, false, LyraConsoleVariables::DrawBulletTracesDuration, 0, DebugThickness);</span><br><span class="line">    &#125;</span><br><span class="line">  #endif</span><br><span class="line">    //这里单独有一个函数出来处理逻辑</span><br><span class="line">    //主要是对于霰弹枪这种多子弹情况</span><br><span class="line">    //具体的检测函数可以看到WeaponTrace函数</span><br><span class="line">    TraceBulletsInCartridge(InputData, /*out*/ OutHits);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="数据逻辑处理-OnTargetDataReadyCallback"><a href="#数据逻辑处理-OnTargetDataReadyCallback" class="headerlink" title="数据逻辑处理 - OnTargetDataReadyCallback"></a>数据逻辑处理 - OnTargetDataReadyCallback</h4><p>通过PerformLocalTargeting，我们获取到了目标对象（如果有）。<br>即确定了GE的应用对象和本GA的效果的目标对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void ULyraGameplayAbility_RangedWeapon::OnTargetDataReadyCallback(const FGameplayAbilityTargetDataHandle&amp; InData, FGameplayTag ApplicationTag)</span><br><span class="line">&#123;</span><br><span class="line">  UAbilitySystemComponent* MyAbilityComponent = CurrentActorInfo-&gt;AbilitySystemComponent.Get();</span><br><span class="line">  check(MyAbilityComponent);</span><br><span class="line"></span><br><span class="line">  //获取当前的GASpec</span><br><span class="line">  if (const FGameplayAbilitySpec* AbilitySpec = MyAbilityComponent-&gt;FindAbilitySpecFromHandle(CurrentSpecHandle))</span><br><span class="line">  &#123;</span><br><span class="line">    //创建预测窗口</span><br><span class="line">    FScopedPredictionWindow	ScopedPrediction(MyAbilityComponent);</span><br><span class="line"></span><br><span class="line">    //确保对当前数据的掌控权</span><br><span class="line">    //考虑数据结构</span><br><span class="line">    //Take ownership of the target data to make sure no callbacks into game code invalidate it out from under us</span><br><span class="line">    FGameplayAbilityTargetDataHandle LocalTargetDataHandle(MoveTemp(const_cast&lt;FGameplayAbilityTargetDataHandle&amp;&gt;(InData)));</span><br><span class="line"></span><br><span class="line">    const bool bShouldNotifyServer = CurrentActorInfo-&gt;IsLocallyControlled() &amp;&amp; !CurrentActorInfo-&gt;IsNetAuthority();</span><br><span class="line">    if (bShouldNotifyServer)</span><br><span class="line">    &#123;</span><br><span class="line">      //传输数据给服务器</span><br><span class="line">      //这里需要进行对应事件的绑定。</span><br><span class="line">      MyAbilityComponent-&gt;CallServerSetReplicatedTargetData(CurrentSpecHandle, CurrentActivationInfo.GetActivationPredictionKey(), LocalTargetDataHandle, ApplicationTag, MyAbilityComponent-&gt;ScopedPredictionKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const bool bIsTargetDataValid = true;</span><br><span class="line"></span><br><span class="line">    bool bProjectileWeapon = false;</span><br><span class="line"></span><br><span class="line">  #if WITH_SERVER_CODE</span><br><span class="line">    if (!bProjectileWeapon)</span><br><span class="line">    &#123;</span><br><span class="line">      if (AController* Controller = GetControllerFromActorInfo())</span><br><span class="line">      &#123;</span><br><span class="line">        if (Controller-&gt;GetLocalRole() == ROLE_Authority)</span><br><span class="line">        &#123;</span><br><span class="line">          // Confirm hit markers</span><br><span class="line">          if (ULyraWeaponStateComponent* WeaponStateComponent = Controller-&gt;FindComponentByClass&lt;ULyraWeaponStateComponent&gt;())</span><br><span class="line">          &#123;</span><br><span class="line">            TArray&lt;uint8&gt; HitReplaces;</span><br><span class="line">            for (uint8 i = 0; (i &lt; LocalTargetDataHandle.Num()) &amp;&amp; (i &lt; 255); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">              if (FGameplayAbilityTargetData_SingleTargetHit* SingleTargetHit = static_cast&lt;FGameplayAbilityTargetData_SingleTargetHit*&gt;(LocalTargetDataHandle.Get(i)))</span><br><span class="line">              &#123;</span><br><span class="line">                if (SingleTargetHit-&gt;bHitReplaced)</span><br><span class="line">                &#123;</span><br><span class="line">                  HitReplaces.Add(i);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            WeaponStateComponent-&gt;ClientConfirmTargetData(LocalTargetDataHandle.UniqueId, bIsTargetDataValid, HitReplaces);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  #endif //WITH_SERVER_CODE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //CommitAbility在这里进行的 </span><br><span class="line">    // See if we still have ammo（弹药）</span><br><span class="line">    if (bIsTargetDataValid &amp;&amp; CommitAbility(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo))</span><br><span class="line">    &#123;</span><br><span class="line">      // We fired the weapon, add spread</span><br><span class="line">      ULyraRangedWeaponInstance* WeaponData = GetWeaponInstance();</span><br><span class="line">      check(WeaponData);</span><br><span class="line">      </span><br><span class="line">      //表现</span><br><span class="line">      WeaponData-&gt;AddSpread();</span><br><span class="line"></span><br><span class="line">      //蓝图 - GE/GCN</span><br><span class="line">      // Let the blueprint do stuff like apply effects to the targets</span><br><span class="line">      OnRangedWeaponTargetDataReady(LocalTargetDataHandle);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      UE_LOG(LogLyraAbilitySystem, Warning, TEXT(&quot;Weapon ability %s failed to commit (bIsTargetDataValid=%d)&quot;), *GetPathName(), bIsTargetDataValid ? 1 : 0);</span><br><span class="line">      K2_EndAbility();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // We&#x27;ve processed the data</span><br><span class="line">  MyAbilityComponent-&gt;ConsumeClientReplicatedTargetData(CurrentSpecHandle, CurrentActivationInfo.GetActivationPredictionKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="射击的伤害效果和表现-OnRangedWeaponTargetDataReady"><a href="#射击的伤害效果和表现-OnRangedWeaponTargetDataReady" class="headerlink" title="射击的伤害效果和表现 - OnRangedWeaponTargetDataReady"></a>射击的伤害效果和表现 - OnRangedWeaponTargetDataReady</h4><p>这部分逻辑Lyra项目使用蓝图来实现。</p>
<ul>
<li>表现部分 - GCN - 使用 ExectueGameplayCueWithParamsOnOwner来做。<ul>
<li>攻击者GCN：音效、镜头抖动、手柄反馈。武器的Fire逻辑（粒子特效等）</li>
<li>受击者GCN：音效、镜头抖动、手柄反馈（见ForceFeedbackEffect）</li>
</ul>
</li>
<li>逻辑部分 - GE - 仅服务端执行 - ApplyGameplayEffectToTarget。<ul>
<li>添加GE Damage。并由其处理伤害逻辑。</li>
</ul>
</li>
</ul>
<h4 id="蒙太奇表现"><a href="#蒙太奇表现" class="headerlink" title="蒙太奇表现"></a>蒙太奇表现</h4><p>使用了GATask - PlayMontageAndWait来处理蒙太奇动画播放。<br>并设置了定时器，动画播放完毕触发事件&#x2F;定时器触发事件后，EndAbility。</p>
<p>蒙太奇内容：<br>3个Notify：<br>1.武器蒙太奇播放通知 - 通过人物蒙太奇驱动武器来播放蒙太奇，处理武器动画<br>2.骨架的动画通知 - SaveAttack<br>3.骨架的动画通知 - ResetCombo</p>
<p>创建的自定义通知保存在骨架上，并可以用于执行自定义逻辑。如在动画蓝图进行处理。<br>目前看Lyra并没有详细用到这两个通知。</p>
<h4 id="ULyraGameplayAbility-FromEquipment"><a href="#ULyraGameplayAbility-FromEquipment" class="headerlink" title="ULyraGameplayAbility_FromEquipment"></a>ULyraGameplayAbility_FromEquipment</h4><p>主要是处理了其中的装备类：ULyraEquipmentInstance<br>以及对应的库存Item：ULyraInventoryItemInstance</p>
<h4 id="ULyraGameplayAbility-RangedWeapon"><a href="#ULyraGameplayAbility-RangedWeapon" class="headerlink" title="ULyraGameplayAbility_RangedWeapon"></a>ULyraGameplayAbility_RangedWeapon</h4><p>定义了对应的武器信息：ULyraRangedWeaponInstance</p>
<p>定义了目标选择的相关数据结构（用于射线检测）:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct FRangedWeaponFiringInput</span><br><span class="line">&#123;</span><br><span class="line">    // Start of the trace</span><br><span class="line">    FVector StartTrace;</span><br><span class="line"></span><br><span class="line">    // End of the trace if aim were perfect</span><br><span class="line">    FVector EndAim;</span><br><span class="line"></span><br><span class="line">    // The direction of the trace if aim were perfect</span><br><span class="line">    FVector AimDir;</span><br><span class="line"></span><br><span class="line">    // The weapon instance / source of weapon data</span><br><span class="line">    ULyraRangedWeaponInstance* WeaponData = nullptr;</span><br><span class="line"></span><br><span class="line">    // Can we play bullet FX for hits during this trace</span><br><span class="line">    bool bCanPlayBulletFX = false;</span><br><span class="line"></span><br><span class="line">    FRangedWeaponFiringInput()</span><br><span class="line">        : StartTrace(ForceInitToZero)</span><br><span class="line">        , EndAim(ForceInitToZero)</span><br><span class="line">        , AimDir(ForceInitToZero)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="关键变量"><a href="#关键变量" class="headerlink" title="关键变量:"></a>关键变量:</h5><p>定义委托 - FDelegateHandle OnTargetDataReadyCallbackDelegateHandle</p>
<h5 id="关键函数："><a href="#关键函数：" class="headerlink" title="关键函数："></a>关键函数：</h5><p>&#x2F;&#x2F;能力激活后的主函数<br>StartRangedWeaponTargeting</p>
<p>&#x2F;&#x2F;GA的目标选取<br>PerformLocalTargeting</p>
<p>&#x2F;&#x2F;射线检测，以及中间障碍物判定<br>WeaponTrace </p>
<p>&#x2F;&#x2F;目标选取完毕后的回调函数。服务端与客户端的连接。<br>OnTargetDataReadyCallback</p>
<p>&#x2F;&#x2F;关键蓝图事件，处理伤害判定等。<br>OnRangedWeaponTargetDataReady </p>
<p>关于回调的注册：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void ULyraGameplayAbility_RangedWeapon::ActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo, const FGameplayEventData* TriggerEventData)</span><br><span class="line">&#123;</span><br><span class="line">  //注册回调。回调的UnRegister在EndAbility部分进行。</span><br><span class="line">  // Bind target data callback</span><br><span class="line">  UAbilitySystemComponent* MyAbilityComponent = CurrentActorInfo-&gt;AbilitySystemComponent.Get();</span><br><span class="line">  check(MyAbilityComponent);</span><br><span class="line"></span><br><span class="line">  OnTargetDataReadyCallbackDelegateHandle = MyAbilityComponent-&gt;AbilityTargetDataSetDelegate(CurrentSpecHandle, CurrentActivationInfo.GetActivationPredictionKey()).AddUObject(this, &amp;ThisClass::OnTargetDataReadyCallback);</span><br><span class="line"></span><br><span class="line">  // Update the last firing time</span><br><span class="line">  ULyraRangedWeaponInstance* WeaponData = GetWeaponInstance();</span><br><span class="line">  check(WeaponData);</span><br><span class="line">  WeaponData-&gt;UpdateFiringTime();</span><br><span class="line"></span><br><span class="line">  Super::ActivateAbility(Handle, ActorInfo, ActivationInfo, TriggerEventData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="额外话题"><a href="#额外话题" class="headerlink" title="额外话题"></a>额外话题</h3><h4 id="增强输入，输入绑定和GA的触发"><a href="#增强输入，输入绑定和GA的触发" class="headerlink" title="增强输入，输入绑定和GA的触发"></a>增强输入，输入绑定和GA的触发</h4><p>LyrHeroComponent -&gt; LyraASC AbilityInputTagPressed</p>
<p>关于输入映射关系<br>B_Hero_ShooterMannequin -&gt; B_Hero_Default<br>B_Hero_Default的LyraHeroComp 重定义了 DefaultInputMappings</p>
<p>关于能力、增强输入设置：<br>见到数据文件：InputData_Hero<br>具体的绑定可以看到ULyraInputComponent。<br>其中进行了相关的AbilityInputActions绑定。由此，在进行对应的增强操作时，会触发对应的Tag。并由Tag去激活对应的能力。</p>
<p>空子弹时，也会尝试触发对应的能力。但在GA的CanActivateAbility会被驳回。<br>（子类的GA写了子弹数量作为Cost）。<br>关于开销，可以看到ULyraAbilityCost_ItemTagStack。</p>
<h4 id="Lyra中GameplayCue目录的添加："><a href="#Lyra中GameplayCue目录的添加：" class="headerlink" title="Lyra中GameplayCue目录的添加："></a>Lyra中GameplayCue目录的添加：</h4><p>正如之前所述，必须要注册GameplayCueNotfiy对应的目录，在运行时才能通过对应的Tag来触发GameplayCue。Lyra中做了对应的插件GameplayCueNotify目录注册工作。可以以插件ShotterCoreContent为例子。看到关键文件：ShooterCore。Lyra中添加了对应GameFeature的注册回调，看到类ULyraGameFeaturePolicy，内部有做对应的工作。<br>这样GameplayCueNotify的目录规划就可以比较整洁好处理了。<br>体外话：要看哪些东西使用了对应的GameplayTag,可以在蓝图中找到对应Tag后右键，点击SearchForReferences。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Lyra射击的判定还是以LocallyControled为准。如果是专用服务器，那么射击的判定都是依赖于客户端提供的数据的。</p>
<p>依赖于客户端提供数据的好处在于，即便有网络延迟，玩家自己本地的攻击也能够较为正常的结算。</p>
<p>但是在竞技&#x2F;多人网络游戏中，防作弊就成了一个非常关键的话题了。虽然GAS本身的机制，确保了对应的开销判断，但是Lyra并没有对目标传来的实体对象有效性做判断。<br>比如，如果A客户端的攻击目标在服务器收到之前，A客户端的实体在服务器端由于其他玩家伤害，而被击杀，对于的GA在服务端就不会被激活。（在客户端，GA的激活和TargetData的选取是有序执行的，预测窗口和GAS的底层涉及确保了服务端的执行顺序也一致。）</p>
<p>换言之，服务端在处理OnRangedWeaponTargetDataReady事件之前，需要对客户端传来的数据进行有效性判定。否则可能会出现比较离谱的情况。</p>
<p>此外，从逻辑实现可以看到，Lyra本身并没有创建“实体子弹”，而是依赖于射线检测。</p>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>GAS</tag>
        <tag>Lyra</tag>
      </tags>
  </entry>
  <entry>
    <title>UE - PhyscisNetworkReplication</title>
    <url>/UE/OfficialDocLearn/Physcis/PhyscisNetwork/</url>
    <content><![CDATA[<h1 id="笔记内容"><a href="#笔记内容" class="headerlink" title="笔记内容"></a>笔记内容</h1><img src="/UE/OfficialDocLearn/Physcis/PhyscisNetwork/img.png" class="">

<h1 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h1><p>综述：<br>    主要的问题：<br>        - 物体速度和网络延迟<br>        - 模拟碰撞</p>
<p>默认的物理复制<br>复制前提条件[Condition]:</p>
<ul>
<li>移动复制 Replicate movement</li>
<li>根组件启用物理模拟 Simulate Physics</li>
</ul>
<p>客户端使用服务器的位置进行矫正和预测，[抛弃本地的模拟]</p>
<ul>
<li>服务端传输:半个RTT</li>
<li>客户端预测:半个RTT</li>
</ul>
<p>影响因素：<br>    - 客户端当前的位置ClientPos 以及服务端的预测位置 ServerPredictPos (两者计算出一个Offset)<br>    - 服务端物体的速度Velocity</p>
<p>矫正速度(简单记为Vc) Vc &#x3D; Offset&#x2F; DesiredCorrectionTime</p>
<p>V &#x3D; Vc + Velocity(Server)  -&gt; 矫正时间内 可以移动到服务端的预测位置。</p>
<p>[这里很重要的一点是使用服务端的当前速度]</p>
<p>预测性插值 Predictive Interpolation</p>
<ul>
<li>服务器授权Actor [Server-Authoritative Actors]</li>
</ul>
<p>也是修改Client的Velocity来匹配Server的情况。</p>
<ul>
<li>会考虑Client本地的Velocity</li>
<li>考虑RTT 以及数据同步频率 [Time Interval When The Client Receives Data From Server]</li>
<li>客户端可以先力效果来预测模拟表现</li>
</ul>
<p>重新模拟Resimulation</p>
<p>适用于服务器授权的Pawns与Actors</p>
<ul>
<li>主要用于 Handle interactions between Actors running the two different replication modes.</li>
<li>Pawns movement 由玩家Inputs -&gt; Physics Forces 来驱动</li>
<li>开销较高</li>
</ul>
<p>[客户端纯前向预测] </p>
<ul>
<li>Client比Server状态相比 提前半个RTT</li>
<li>和收到服务端确认相比 提前一个RTT</li>
</ul>
<p>[History 缓存和回滚]</p>
<ul>
<li>由以上条件，至少需要缓存一个RTT时间内的物理tick状态</li>
<li>收到服务端结果后，比较并确定是否需要进行重模拟</li>
</ul>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>Physcis</tag>
      </tags>
  </entry>
  <entry>
    <title>UE - Physcis总览</title>
    <url>/UE/OfficialDocLearn/Physcis/PhyscisTotal/</url>
    <content><![CDATA[<h1 id="笔记内容"><a href="#笔记内容" class="headerlink" title="笔记内容"></a>笔记内容</h1><img src="/UE/OfficialDocLearn/Physcis/PhyscisTotal/img.png" class="">

<h1 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h1><p>小结：<br>Destruction - 破坏系统<br>可以指定具体的部分去展示<br>同时缓存提供了重播功能，对性能做了优化<br>可以和物理场结合应用。自己也有BreakEvent、CollisionEvent,可以和粒子系统结合在一起。<br>小结 Netwrok Replication<br>主要处理在多人游戏中的物理复制。<br>目标是服务端、客户端的物理模拟效果尽量一致 且流畅<br>共三种模式</p>
<ol>
<li>Default: [在复制移动的Actor上生效] - 使用RootComp来模拟物理</li>
<li>Predictive Interpolation: [Server-Authoritative Actors] - 改变客户端速度Velocity来匹配服务端的速度，<br>从而模拟(预测性插值)</li>
<li>Resimulation:[Server-Authoritative Pawns and Actors] 允许客户端预测Client Prediction.<br>并且在误差较大时 触发重模拟Resimulation<br>小结 - Debug Tools<br>可视化调试工具<br>Runtime下运行录制并进行Replay<br>刚体运动学<br>子模块部分：<br>Collision<br>Trace with Raycast<br>Physics Constraints<br>Physics Components<br>刚体动画节点和物理动画<br>角色动画中加入刚体部位的模拟<br>Rigid bodies -&gt; Skeletal Mesh<br>小结 布料模拟 Cloth<br>可以在蓝图中调整模拟参数来实现同个布料在不同环境有着不同的表现<br>Debug Tools<br>5.3提供Chaos Cloth Panel Node  新的布料模拟工作流程<br>布娃娃系统<br>载具Vehicle<br>车轮、机翼[飞行载具]等。<br>上升下降的力、转向、摩擦<br>以及相应的物理碰撞<br>小结 物理场 Field<br>指定空间进行模拟<br>和其他系统进行交互 (对物理场进行采样Sample)<br>小结 流体 Fluid<br>毛发物理<br>小结 柔性物理(形变)<br>Static and Skeletal Meshes.<br>肌肉<br>离线处理优化<br>小结 数据流系统 Dataflow Graph System<br>复用性 + 可视化节点工作流程</li>
</ol>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>Physcis</tag>
      </tags>
  </entry>
  <entry>
    <title>UE - Level</title>
    <url>/UE/OfficialDocLearn/Levels/Level/</url>
    <content><![CDATA[<h1 id="笔记内容"><a href="#笔记内容" class="headerlink" title="笔记内容"></a>笔记内容</h1><img src="/UE/OfficialDocLearn/Levels/Level/img.png" class="">

<h1 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h1><p>Level 或者亦可以称之为 Map </p>
<ul>
<li>资产文件.umap</li>
</ul>
<p>Levels &amp;&amp; World Partition<br>结合UWorld相关的概念进行理解</p>
<p>World Settings (结合ULevel UWorld)</p>
<p>设置和Level相关的各类信息。不过这里感觉还是要留意World的概念，以及SubLevels。<br>具体详细的还是看到官方文档。这里没必要做过多赘述。</p>
<ul>
<li><p>Precomputed Visibility<br>  -&gt; volumes reduce rendering thread time.<br>  -&gt; For smaller level, Hardware limitation  | 移动设备</p>
</li>
<li><p>GameMode</p>
</li>
<li><p>Lightmass 光源设置</p>
</li>
<li><p>World [相关还是可以看看官方文档]</p>
<ul>
<li>Level bounds</li>
<li>navigation systems</li>
<li>“World Depth”</li>
</ul>
</li>
<li><p>Physics</p>
<ul>
<li>World Gravity 重力</li>
</ul>
</li>
<li><p>Broadphase</p>
<ul>
<li>Feature of NVIDIA’s PhysX system</li>
<li>这部分可以看看知乎文章<a href="https://zhuanlan.zhihu.com/p/113415779">https://zhuanlan.zhihu.com/p/113415779</a></li>
<li>粗碰撞检测</li>
</ul>
</li>
<li><p>HLODSystem</p>
<ul>
<li>Replace multiple Static Mesh Actors with single combined Satic Mesh<br>Actor at long view distances.</li>
<li>优化Drawcalls</li>
</ul>
</li>
<li><p>World Partition</p>
<ul>
<li>For Large world management. [Distance-based level streaming]</li>
<li>和Sublevels还有关。</li>
</ul>
</li>
<li><p>Navigation</p>
</li>
<li><p>VR</p>
</li>
<li><p>Rendering</p>
<ul>
<li>Distance field ambient occlusion “距离场环境光遮蔽”</li>
<li>Dynamic indirect shadows</li>
</ul>
</li>
<li><p>Audio</p>
<ul>
<li>Volume,Reverb,Fade time</li>
</ul>
</li>
<li><p>Tick</p>
<ul>
<li>详细见 Actor ticking</li>
</ul>
</li>
<li><p>AI</p>
</li>
<li><p>Cooking</p>
<ul>
<li>Affect how the content in Scenes will be included in built game.</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>Level</tag>
      </tags>
  </entry>
  <entry>
    <title>UE - PhyscisCollision</title>
    <url>/UE/OfficialDocLearn/Physcis/PhyscisCollision/</url>
    <content><![CDATA[<h1 id="笔记内容"><a href="#笔记内容" class="headerlink" title="笔记内容"></a>笔记内容</h1><img src="/UE/OfficialDocLearn/Physcis/PhyscisCollision/img.png" class="">

<h1 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h1><p>概述 : Collision &amp; Trace</p>
<ul>
<li><p>Object Type</p>
</li>
<li><p>Trace Response Type</p>
</li>
<li><p>ObjectTypes 互相之前应当一致来满足预期效果</p>
</li>
<li><p>Events:</p>
<ul>
<li>Collision Events</li>
<li>Overlap Events</li>
</ul>
</li>
</ul>
<p>在要处理碰撞事件的对象上才启用 Simulation Generates Hit Events.<br>处理事件时 进行Filter 筛选出目标事件</p>
<p>对于Overlap 和 Ignore：<br>如果Overlap不启用对应的事件(Generate Overlap Events), 则其和Ignore其实是一样的。</p>
<p>重叠事件 ReceiveBeginOverlap 与 ReceiveEndOverlap</p>
<ul>
<li>需要重叠的两个实体都启用事件</li>
<li>在都启用Generate Overlap Events 时，可以一个Overlap 一个 Block。<br>事件会正常触发</li>
</ul>
<p>小结： 简单碰撞和复杂碰撞 Simple &amp; Complex</p>
<ul>
<li>性能和不同用途</li>
<li>注意在Use Complex Collision As Simple 时， 不能进行物理模拟，仅可用于静态碰撞</li>
</ul>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>Physcis</tag>
      </tags>
  </entry>
  <entry>
    <title>UE - LevelInstancing</title>
    <url>/UE/OfficialDocLearn/Levels/LevelInstancing/</url>
    <content><![CDATA[<h1 id="笔记内容"><a href="#笔记内容" class="headerlink" title="笔记内容"></a>笔记内容</h1><img src="/UE/OfficialDocLearn/Levels/LevelInstancing/img.png" class="">

<h1 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h1><p>Level Instances </p>
<pre><code>- 1. Level Instances -&gt; Collection of Actors, to create sublevel

- 2. Packed Level Blueprints -&gt; 静态网格体组合[渲染优化] 
</code></pre>
<p>Creating Level Instances</p>
<p>小结:<br> 两者其实都是将场景中的对象进行组合一起管理的一种方式。并且提供了复制的功能、<br>在改动时 可以同步对应的改动。<br>  Packed Level Blueprint 有着对应的蓝图对象可以用来操作</p>
<p>默认情况下使用组合节点的Data Layer,<br>内部也可以自定义不同的Data Layer</p>
<p>Level Steaming Modes:</p>
<ol>
<li><p>Embedded Mode - 相当于仅在编辑器时，存在对应的 Level Instances. 运行<br>时还是加载对应的Actor [这个也是推荐的模式 需要OFPA]</p>
</li>
<li><p>Level Streaming Mode - 作为一个整体。其所在的World Partition Cell被加载时，<br>整一个Level也会被加载[Level instances that do not use OFPA]</p>
</li>
</ol>
<p>Summary:<br>比较在意的一点是，官方在这里用的概念是”Level”。在Level Instances中用的概念也<br>是”SubLevel”。实际上，在编辑器中选择Actors打包成Level Instance时,也确实会生成<br>一个Level，并需要保存。而Packed Level Blueprint会生成一个Level和一个Packed Level<br>Actor的蓝图类。</p>
<p>在逻辑和应用上，我们应该是希望把某一些静态的对象作为一个整体来进行管理，或者是<br>复用。类似于预制体的概念。</p>
<p>在使用WorldPartition并使用OAPF时可以考虑其进行场景对象的管理[但也需要注意改动一<br>个会影响到其他 可以认为是同一份数据],不影响运行时[Embedded Mode]。而Packed<br>Level Blueprints提到的渲染优化特性也可以一起利用上。</p>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>Level</tag>
      </tags>
  </entry>
  <entry>
    <title>UE - WorldPartition</title>
    <url>/UE/OfficialDocLearn/Levels/WorldPartition/</url>
    <content><![CDATA[<h1 id="笔记内容"><a href="#笔记内容" class="headerlink" title="笔记内容"></a>笔记内容</h1><img src="/UE/OfficialDocLearn/Levels/WorldPartition/img.png" class="">

<h1 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h1><p>目录和话题：</p>
<ul>
<li>World Partition</li>
<li>One File Per Actor</li>
<li>Data Layers</li>
</ul>
<p>World Partition:<br>世界分区 结合之前Level 与 SubLevels的概念</p>
<ul>
<li>重点在于如何处理大世界 </li>
<li>动态的加载和卸载对应的”子地图模块”以及上面的资源</li>
<li>处理跨地图的寻路和Actor逻辑</li>
<li>子模块的单独开发[资源独立性 开发效率]</li>
</ul>
<p>基于上述需求 - 新的解决方案： World Partition</p>
<ul>
<li><p>“Cells” 的概念</p>
</li>
<li><p>由WorldPartition来控制Cells的加载与卸载</p>
</li>
<li><p>基于流送源的距离 [Based on distance from a streaming source]</p>
</li>
<li><p>Single Persistent Level  单个Level</p>
</li>
<li><p>“Grid Cells” 单元格概念</p>
</li>
</ul>
<p>Actors - 需要了解 One File Per Actor的概念</p>
<ul>
<li>在World Partition中设置其归属Grid</li>
<li>在不属于Disabled Data Layer时 依据 Is Spatially Loaded 来控制是否动态加载</li>
</ul>
<p>One File Per Actor </p>
<ul>
<li>Extra File To Save Data For Instatnce Actor</li>
<li>改变关卡内的Actor时 不需要改变Level</li>
<li>使用ViewChangeList Window 来查看改动<br>[虚幻内部的管理工具 可了解 In-Editor Source Control]</li>
</ul>
<p>Steaming Sources 流送源 [Think of AOI]</p>
<p>额外需要思考的是服务端与客户端不同情况的加载<br>从PlayerController 的角度来看 服务端为玩家个数 而客户端就为单个了。</p>
<ul>
<li>PlayerController 子项设置里面的enable Streaming Source</li>
</ul>
<p>World Partition Steaming Source Component<br>这里做一些简要例举 详细的可以看官方Doc</p>
<p>Cell Size - 256*256*256的正方体<br>Loading Range  - 768(Meter) around a steaming source</p>
<p>Editor加载逻辑 - 主要是编辑器下相关操作和内容 详细见官方Doc</p>
<p>HLOD -</p>
<ul>
<li>不同的Cells 有着自己的HLOD设定 </li>
<li>Build -&gt; Build HLODs 依据设定生成对应的数据</li>
</ul>
<p>Blueprint -<br>  “世界分区”世界[World Partition world]可以用Blueprint与Level Blueprint<br>但更推荐用Blueprint。</p>
<ul>
<li>“Any Actors referenced in Level Blueprint will be marked as Always Loaded”<br>这样就丢失了动态加载的特性了</li>
</ul>
<p>World Partition - Data Layers<br>[旧版本的 Layers System]</p>
<p>Organize Actors 管理对象 [Both runtime and in the Editor]</p>
<ul>
<li>两个概念： Data Layer Assets &amp; Data Layer Instance</li>
<li>动态加载&#x2F;事件触发</li>
<li>区分元素 Gameplay元素 &amp; 环境元素[美术]</li>
</ul>
<p>Data Layer Assets </p>
<ul>
<li>独立于”World”的概念 </li>
<li>Editor 与 Runtime 两种类别。前者用于帮助组织资产，后者可以用于游戏性功能</li>
</ul>
<p>具体的实例 - Data Layer Instance [World-Specific]</p>
<p>Data Layers Outliner 主要也是管理 Data Layer Instance</p>
<p>Using Data Layers:</p>
<pre><code>- Start by creating Data Layers Asset

- Create Data Layer Instance [默认是空白的]

- Assign DataLayerAsset to Instance[给Instance指定Asset]
</code></pre>
<p>Add Actors to Data Layer Instance</p>
<p>Performance - 合理组织<br>避免一次性加载过多。</p>
<p>相关函数:<br>Set Data Layer Instance Runtime State<br>    - Loaded 加载不可见<br>    - Activated 加载并可见</p>
<p>Level Instances &amp; Packed Level Blueprints</p>
<ul>
<li>默认情况下 使用的对应的Data Layer。</li>
<li>可以内部设置不同的Data Layer, 便于依据情况动态启用</li>
</ul>
<p>总之 Actors与DataLayer的耦合不高，对DataLayer的操作不会影响到Actor<br>最多是处理 One File Per Actor文件</p>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>Level</tag>
      </tags>
  </entry>
</search>
