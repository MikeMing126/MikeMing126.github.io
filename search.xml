<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git相关内容学习</title>
    <url>/2025/03/06/GitLearning/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Git在版本维护上面还是能发挥很好的作用的。当然也可以考虑用TortoiseSVN。<br>主要目的还是维护好代码吧。这样有什么临时改动想回滚到之前版本也比较好处理。避免某些操作无法撤销而花很多精力去重新编写内容。</p>
<h1 id="基础Git指令"><a href="#基础Git指令" class="headerlink" title="基础Git指令"></a>基础Git指令</h1><p>有需要再补充。</p>
<h1 id="配置GitIgnore相关内容"><a href="#配置GitIgnore相关内容" class="headerlink" title="配置GitIgnore相关内容"></a>配置GitIgnore相关内容</h1><h2 id="基础说明"><a href="#基础说明" class="headerlink" title="基础说明"></a>基础说明</h2><p>在Git中，.gitignore文件用于指定项目中要忽略的文件和目录，这些文件和目录不会被跟踪和提交到远程仓库。编写.gitignore文件时，你可以使用一系列规则来匹配要忽略的文件和目录。</p>
<h2 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h2><h3 id="忽略特定文件："><a href="#忽略特定文件：" class="headerlink" title="忽略特定文件："></a>忽略特定文件：</h3><p>  filename.ext</p>
<h3 id="忽略特定目录："><a href="#忽略特定目录：" class="headerlink" title="忽略特定目录："></a>忽略特定目录：</h3><p>  directory&#x2F;</p>
<h3 id="忽略特定扩展名的所有文件："><a href="#忽略特定扩展名的所有文件：" class="headerlink" title="忽略特定扩展名的所有文件："></a>忽略特定扩展名的所有文件：</h3><p>  *.log</p>
<h3 id="忽略特定目录下的所有文件："><a href="#忽略特定目录下的所有文件：" class="headerlink" title="忽略特定目录下的所有文件："></a>忽略特定目录下的所有文件：</h3><p>  directory&#x2F;*</p>
<h3 id="忽略特定目录及其所有子目录："><a href="#忽略特定目录及其所有子目录：" class="headerlink" title="忽略特定目录及其所有子目录："></a>忽略特定目录及其所有子目录：</h3><p>  directory&#x2F;**</p>
<h2 id="高级规则"><a href="#高级规则" class="headerlink" title="高级规则"></a>高级规则</h2><h3 id="忽略特定模式的文件："><a href="#忽略特定模式的文件：" class="headerlink" title="忽略特定模式的文件："></a>忽略特定模式的文件：</h3><p>  file[0-9].txt</p>
<h3 id="忽略特定模式的目录："><a href="#忽略特定模式的目录：" class="headerlink" title="忽略特定模式的目录："></a>忽略特定模式的目录：</h3><p>  dir*&#x2F;subdir&#x2F;</p>
<h3 id="忽略特定目录下的特定文件："><a href="#忽略特定目录下的特定文件：" class="headerlink" title="忽略特定目录下的特定文件："></a>忽略特定目录下的特定文件：</h3><p>  directory&#x2F;filename.ext</p>
<h3 id="忽略特定目录下的所有文件，但不包括子目录："><a href="#忽略特定目录下的所有文件，但不包括子目录：" class="headerlink" title="忽略特定目录下的所有文件，但不包括子目录："></a>忽略特定目录下的所有文件，但不包括子目录：</h3><p>  directory&#x2F;<em>.</em></p>
<h3 id="忽略特定目录下的所有文件，但包括子目录中的某些文件："><a href="#忽略特定目录下的所有文件，但包括子目录中的某些文件：" class="headerlink" title="忽略特定目录下的所有文件，但包括子目录中的某些文件："></a>忽略特定目录下的所有文件，但包括子目录中的某些文件：</h3><p>  directory&#x2F;*<br>  !directory&#x2F;subdir&#x2F;important.file</p>
<h2 id="特殊规则"><a href="#特殊规则" class="headerlink" title="特殊规则"></a>特殊规则</h2><h3 id="忽略隐藏文件"><a href="#忽略隐藏文件" class="headerlink" title="忽略隐藏文件"></a>忽略隐藏文件</h3><p>  以.开头的文件：.*</p>
<h3 id="忽略空目录"><a href="#忽略空目录" class="headerlink" title="忽略空目录"></a>忽略空目录</h3><p>  Git默认不跟踪空目录，但可以通过创建一个空的.gitkeep文件来跟踪：<br>  忽略所有空目录<br>  *&#x2F;<br>  但跟踪特定空目录<br>  !important_dir&#x2F;</p>
<h3 id="全局忽略文件"><a href="#全局忽略文件" class="headerlink" title="全局忽略文件"></a>全局忽略文件</h3><p>  在全局配置中设置，适用于所有项目：<br>  git config –global core.excludesfile ~&#x2F;.gitignore_global</p>
<h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><h3 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h3><p>  Git会按照.gitignore文件中的顺序匹配规则，后面的规则可能会覆盖前面的规则。</p>
<h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><p>  规则是相对于.gitignore文件所在目录的。</p>
<h3 id="全局忽略文件-1"><a href="#全局忽略文件-1" class="headerlink" title="全局忽略文件"></a>全局忽略文件</h3><p>  如果你有一些文件或目录在所有项目中都需要忽略，可以考虑使用全局忽略文件。</p>
<p>通过合理编写.gitignore文件，可以有效地管理项目中的不必要文件，保持仓库的整洁。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo APlayer 音频播放及切换网页时保存音频进度</title>
    <url>/2025/03/08/HexoAPlayer/</url>
    <content><![CDATA[<h1 id="音乐播放"><a href="#音乐播放" class="headerlink" title="音乐播放"></a>音乐播放</h1><p>主要用于实现网页在线音乐播放</p>
<h2 id="基于Butterfly主题的音乐播放器"><a href="#基于Butterfly主题的音乐播放器" class="headerlink" title="基于Butterfly主题的音乐播放器"></a>基于Butterfly主题的音乐播放器</h2><p>参考文章 <a href="https://polar-bear.eu.org/2023/07/21/hexo-tag-aplayer-cha-jian/">博客</a></p>
<p>插件：hexo-tag-aplayer</p>
<p>启用MeingJS来使用在线网站歌单。</p>
<h3 id="底部播放器切换网站问题"><a href="#底部播放器切换网站问题" class="headerlink" title="底部播放器切换网站问题"></a>底部播放器切换网站问题</h3><h4 id="基于Hexo-Tag-APlayer的PJAX-兼容："><a href="#基于Hexo-Tag-APlayer的PJAX-兼容：" class="headerlink" title="基于Hexo-Tag-APlayer的PJAX 兼容："></a>基于Hexo-Tag-APlayer的PJAX 兼容：</h4><p>在主题配置文件中设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pjax:</span><br><span class="line">  enable: ture</span><br><span class="line">  exclude:</span><br></pre></td></tr></table></figure>

<p><strong>!!!PJAX问题!!!</strong><br>基于这种配置，虽然网页在切换时，音频播放器的进度不会重置，但是很多网页的动画也因此而丢失了。</p>
<h4 id="不使用PJAX的实现方案"><a href="#不使用PJAX的实现方案" class="headerlink" title="不使用PJAX的实现方案:"></a>不使用PJAX的实现方案:</h4><p>参考文章 <a href="https://zsyyblog.com/90153be9.html">博客</a></p>
<ol>
<li>在博客对应的source文件夹中 创建script文件夹。</li>
<li>编写对应的代码文件，并放于script文件夹中。如APlayerHolder.js</li>
<li>在主题yml配置对应的代码</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inject:</span><br><span class="line">  head:</span><br><span class="line">  bottom:</span><br><span class="line">    - &lt;script src=&quot;/script/APlayerHolder.js&quot;&gt;&lt;/script&gt; //新增代码使用。</span><br><span class="line">    - &lt;class=&quot;aplayer&quot;&gt; //这里是你的音乐播放器配置，不用改。</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>对应代码文件APlayerHolder.js示例</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">InitAPlayerHolder</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//获取全局对象aplayer。</span></span><br><span class="line">    <span class="comment">//注意判空</span></span><br><span class="line">    <span class="keyword">var</span> ap = <span class="variable language_">window</span>.<span class="property">aplayers</span> &amp;&amp; <span class="variable language_">window</span>.<span class="property">aplayers</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ap == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//等待aplayer对象被创建</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="title class_">InitAPlayerHolder</span>, <span class="number">50</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//#region 状态保存函数</span></span><br><span class="line">    <span class="comment">//原基础上加了个检测暂停免得切换页面后爆零(bushi)（指社死）</span></span><br><span class="line">    ap.<span class="title function_">on</span>(<span class="string">&quot;pause&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;aPlayerMusicPaused&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//ap.lrc.hide()</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//自带播放暂停时显隐歌词，后面那句可以删，上同</span></span><br><span class="line">    ap.<span class="title function_">on</span>(<span class="string">&quot;play&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;aPlayerMusicPaused&quot;</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//ap.lrc.show()</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存音量</span></span><br><span class="line">    ap.<span class="property">audio</span>.<span class="property">onvolumechange</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;aPlayerMusicVolume&quot;</span>,ap.<span class="property">audio</span>.<span class="property">volume</span>);&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Index/Time/Mode 定时保存</span></span><br><span class="line">    <span class="keyword">var</span> saveTimeInterval = <span class="number">150</span>;</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;aPlayerMusicIndex&quot;</span>,ap.<span class="property">list</span>.<span class="property">index</span>);</span><br><span class="line">        <span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;aPlayerMusicTime&quot;</span>,ap.<span class="property">audio</span>.<span class="property">currentTime</span>);</span><br><span class="line">        <span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;aPlayerMusicMode&quot;</span>,ap.<span class="property">mode</span>);</span><br><span class="line">    &#125;,saveTimeInterval);</span><br><span class="line">    <span class="comment">//#endregion 状态保存函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//#region 加载保存进度</span></span><br><span class="line">    <span class="comment">//自带播放暂停时显隐歌词，可以删</span></span><br><span class="line">    ap.<span class="property">lrc</span>.<span class="title function_">hide</span>();</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;aplayer-icon-menu&quot;</span>)[<span class="number">0</span>].<span class="title function_">click</span>()</span><br><span class="line">    <span class="comment">//Index</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;aPlayerMusicIndex&quot;</span>)!=<span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        aPlayerMusicIndex = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;aPlayerMusicIndex&quot;</span>);</span><br><span class="line">        ap.<span class="property">list</span>.<span class="title function_">switch</span>(aPlayerMusicIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Time</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;aPlayerMusicTime&quot;</span>) != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">musict</span> = <span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;aPlayerMusicTime&quot;</span>);</span><br><span class="line">        ap.<span class="title function_">setMode</span>(<span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;aPlayerMusicMode&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;aPlayerMusicPaused&quot;</span>)==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ap.<span class="title function_">pause</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ap.<span class="title function_">play</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// setTimeout(function()&#123;</span></span><br><span class="line">        <span class="comment">//     ap.seek(window.musict); //seek炸了我很久，最后决定加个延时（本来要用canplay但是莫名鬼畜了）</span></span><br><span class="line">        <span class="comment">// &#125;,500);</span></span><br><span class="line">        <span class="keyword">var</span> g=<span class="literal">true</span>; <span class="comment">//加个变量以防鬼畜但是不知道怎么节流qwq</span></span><br><span class="line">        ap.<span class="title function_">on</span>(<span class="string">&quot;canplay&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g)&#123;</span><br><span class="line">                ap.<span class="title function_">seek</span>(<span class="variable language_">window</span>.<span class="property">musict</span>);</span><br><span class="line">                g=<span class="literal">false</span>;<span class="comment">//如果不加oncanplay的话会seek失败就这原因炸很久</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;aPlayerMusicPaused&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        ap.<span class="title function_">setMode</span>(<span class="string">&quot;mini&quot;</span>); <span class="comment">//新版添加了保存展开状态功能</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Volume</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;aPlayerMusicVolume&quot;</span>) != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ap.<span class="property">audio</span>.<span class="property">volume</span>=<span class="title class_">Number</span>(<span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;aPlayerMusicVolume&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//#endregion 加载保存进度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行逻辑</span></span><br><span class="line"><span class="title class_">InitAPlayerHolder</span>();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>RAGFlow</title>
    <url>/2025/03/14/RAGFlow/</url>
    <content><![CDATA[<h1 id="使用RAGFlow处理大语言模型幻觉问题。"><a href="#使用RAGFlow处理大语言模型幻觉问题。" class="headerlink" title="使用RAGFlow处理大语言模型幻觉问题。"></a>使用RAGFlow处理大语言模型幻觉问题。</h1><p>大语言模型：基于Ollama部署。</p>
<p>重点优势：自动化的RAG工作流。</p>
<h2 id="Ollama模型部署和本地配置。"><a href="#Ollama模型部署和本地配置。" class="headerlink" title="Ollama模型部署和本地配置。"></a>Ollama模型部署和本地配置。</h2><p>略。简单且已完成。可以参考其他教程。</p>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>参考文档<br><a href="https://docs.docker.com/engine/install/">Install Docker Engine</a><br><a href="https://docs.docker.com/desktop/">Docker Desktop</a></p>
<p>注意了，使用不同底层性能是有差异的。可以看下面的介绍。还是用WSL2好点。</p>
<blockquote>
<p>碎碎念: 想要开发和涉及AI部分，还是少不了Linux。而不是在Windows平台去处理对应的逻辑。大部分AI训练的模型都是直接用Linux的,且很多依赖在Windows上都要单独去做处理，找对应的编译文件……<br>坑已踩。不过基于Docker去使用模型和直接在Windwos环境下使用模型又有多少性能损失，是一个值得考虑和研究的问题。</p>
</blockquote>
<h3 id="基于WSL的Docekr安装-Windwos部分"><a href="#基于WSL的Docekr安装-Windwos部分" class="headerlink" title="基于WSL的Docekr安装 - Windwos部分"></a>基于WSL的Docekr安装 - Windwos部分</h3><p>说明见WSL2 backend x86_64</p>
<p>Windows WSL(Windows Subsystem for Linux)<br>Windows文档说明 <a href="https://learn.microsoft.com/zh-cn/windows/wsl/install">URL</a></p>
<p>如果安装较慢 进度为0，可以先执行下面步骤1，重启电脑，执行步骤3，重启电脑。<br><a href="https://learn.microsoft.com/zh-cn/windows/wsl/install-manual#step-1---enable-the-windows-subsystem-for-linux">解决安装问题</a></p>
<p>注意Windows版本需求。<br>安装指令还是非常简单的。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wsl <span class="literal">--install</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note：<br>The above command only works if WSL is not installed at all. If you run wsl –install and see the WSL help text, please try running wsl –list –online to see a list of available distros and run wsl –install -d <DistroName> to install a distro. To uninstall WSL, see Uninstall legacy version of WSL or unregister or uninstall a Linux distribution.</p>
</blockquote>
<h3 id="基于WSL的Docekr安装-Docker部分"><a href="#基于WSL的Docekr安装-Docker部分" class="headerlink" title="基于WSL的Docekr安装 - Docker部分"></a>基于WSL的Docekr安装 - Docker部分</h3><p>Docker文档说明 <a href="https://docs.docker.com/desktop/features/wsl/">URL</a><br>安装Docker的博客教程 <a href="https://blog.csdn.net/Natsuago/article/details/145588600">文章</a></p>
<h2 id="RAGFlow"><a href="#RAGFlow" class="headerlink" title="RAGFlow"></a>RAGFlow</h2><p>官方 <a href="https://github.com/infiniflow/ragflow">GitHub</a></p>
<h3 id="GitHub项目运行Docker"><a href="#GitHub项目运行Docker" class="headerlink" title="GitHub项目运行Docker"></a>GitHub项目运行Docker</h3><p>CheckOut下对应的GitSource文件,依据需求,进入Docker文件夹中，设置.env的RAGFLOW_IMAGE。<br>下载有问题的话尝试设置镜像源:<br><a href="https://blog.csdn.net/Lichen0196/article/details/137355517">参考文章</a><br><a href="https://blog.csdn.net/Lyon_Nee/article/details/124169099">Windwos参考文章</a><br><a href="https://blog.csdn.net/qq_62878146/article/details/144191062">镜像问题</a><br>ragFlow部分也要设置镜像：位于.env中：<br>RAGFLOW_IMAGE&#x3D;swr.cn-north-4.myhuaweicloud.com&#x2F;infiniflow&#x2F;ragflow:v0.17.0</p>
<h3 id="配置Ollama"><a href="#配置Ollama" class="headerlink" title="配置Ollama"></a>配置Ollama</h3><p>系统环境变量配置 OLLAMA_ORIGINS 为 *<br>以及OLLAMA_HOST为 0.0.0.0。<br>这里需要注意的一点是，OLLAMA_HOST配置为0.0.0.0 如果是公网IP 有相应风险。<br>如果不使用0.0.0.0 需要另外解决docker访问的问题。可以另寻方案。</p>
<p>CMD 中ip config找到虚拟机对应的地址<br>默认端口号为11434<br>http:&#x2F;&#x2F;虚拟机地址:11434</p>
<h3 id="Embedding模型"><a href="#Embedding模型" class="headerlink" title="Embedding模型:"></a>Embedding模型:</h3><p>.env中有介绍模型的相关内容。v0.17.0非slim版本默认会有zh-cn的embedding模型。但对于英文模型需要额外下载。这部分应该要做额外处理逻辑。<br>目前来看,使用nomic-embed-text-v1.5的可以较好的处理中英文需求。<br>DockerDestop中设置 - 资源 - 网络部分启用主机网络。<br>对应Docker中命令行设置相关镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装huggingface_hub库</span><br><span class="line">pip install -U huggingface_hub</span><br><span class="line"># 设置国内镜像</span><br><span class="line"># 建议将这一行写入 ~/.bashrc。若没有写入，则每次下载时都需要先输入该命令</span><br><span class="line">export HF_ENDPOINT=https://hf-mirror.com  </span><br></pre></td></tr></table></figure>

<h2 id="Docker介绍-DeepSeek生成"><a href="#Docker介绍-DeepSeek生成" class="headerlink" title="Docker介绍[DeepSeek生成]"></a>Docker介绍[DeepSeek生成]</h2><p>Docker 是一个开源的<strong>容器化平台</strong>，用于快速构建、打包、部署和运行应用程序。它通过容器技术将应用及其依赖环境（如代码、库、配置等）打包成一个轻量级、可移植的单元，从而实现<strong>一次构建，随处运行</strong>的目标。<br>以下是 Docker Desktop 在 <strong>Hyper-V 模式</strong> 和 <strong>WSL2 模式</strong> 下的优缺点对比，结合不同场景的实际需求分析：</p>
<h3 id="一、Hyper-V-模式"><a href="#一、Hyper-V-模式" class="headerlink" title="一、Hyper-V 模式"></a><strong>一、Hyper-V 模式</strong></h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ol>
<li><p><strong>高隔离性</strong><br>• 基于完整的虚拟机（如 MobyLinuxVM）运行 Docker，与宿主机完全隔离，适合需要严格环境隔离的场景。<br>• 支持运行不同内核的操作系统（如旧版 Linux 发行版）。</p>
</li>
<li><p><strong>兼容性广</strong><br>• 适用于所有支持 Hyper-V 的 Windows 版本（如 Windows 10 专业版&#x2F;企业版）。</p>
</li>
<li><p><strong>独立资源分配</strong><br>• 可为虚拟机预先分配固定的 CPU 和内存资源，避免资源争用。</p>
</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ol>
<li><p><strong>性能损失较大</strong><br>• 虚拟化层导致 CPU 和内存性能损失约 15%<del>25%，I&#x2F;O 密集型任务（如编译、文件读写）延迟显著。<br>• 文件系统交互需通过虚拟化层中转，挂载 Windows 目录时 I&#x2F;O 速度下降 30%</del>50%。</p>
</li>
<li><p><strong>资源占用高</strong><br>• 需独立运行完整的 Linux 虚拟机，内存占用较高（默认分配 2GB 以上）。</p>
</li>
<li><p><strong>启动速度慢</strong><br>• 冷启动 Docker 服务需 30 秒至 1 分钟，容器启动时间较长。</p>
</li>
</ol>
<hr>
<h3 id="二、WSL2-模式"><a href="#二、WSL2-模式" class="headerlink" title="二、WSL2 模式"></a><strong>二、WSL2 模式</strong></h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a><strong>优点</strong></h4><ol>
<li><p><strong>接近原生性能</strong><br>• 基于轻量级虚拟机运行完整 Linux 内核，CPU 和内存性能损失仅 5%~15%，接近原生 Linux。<br>• 文件系统优化：若将代码存储在 WSL2 的 Linux 分区内，I&#x2F;O 性能与原生 Linux 一致。</p>
</li>
<li><p><strong>动态资源管理</strong><br>• 自动按需分配 CPU 和内存资源，避免资源浪费（如默认动态分配内存）。</p>
</li>
<li><p><strong>开发友好</strong><br>• 支持与 VS Code 无缝集成（通过 Remote-WSL 插件），可直接编辑 Linux 文件。<br>• 支持 GPU 加速（如 CUDA、DirectML），适合机器学习等高性能任务。</p>
</li>
<li><p><strong>快速启动</strong><br>• Docker 服务冷启动时间缩短至 10 秒以内，容器启动仅需 1~2 秒。</p>
</li>
</ol>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ol>
<li><p><strong>兼容性限制</strong><br>• 需 Windows 10 2004 或更高版本，且需启用 WSL2 功能。<br>• 不支持旧版 Linux 内核（依赖 Microsoft 提供的 Linux 内核版本）。</p>
</li>
<li><p><strong>文件系统交互问题</strong><br>• 直接挂载 Windows 目录（如 <code>/mnt/c</code>）时，文件读写性能较低（建议优先使用 WSL2 的 Linux 文件系统）。</p>
</li>
<li><p><strong>资源限制</strong><br>• 默认内存上限为 80% 宿主机内存，需手动调整 <code>.wslconfig</code> 文件以优化配置。</p>
</li>
</ol>
<hr>
<h3 id="三、场景推荐"><a href="#三、场景推荐" class="headerlink" title="三、场景推荐"></a><strong>三、场景推荐</strong></h3><table>
<thead>
<tr>
<th><strong>需求场景</strong></th>
<th><strong>推荐模式</strong></th>
<th><strong>理由</strong></th>
</tr>
</thead>
<tbody><tr>
<td>开发&#x2F;测试环境（高频启停容器）</td>
<td>WSL2</td>
<td>启动快、资源占用低，与 VS Code 集成流畅。</td>
</tr>
<tr>
<td>生产级隔离需求</td>
<td>Hyper-V</td>
<td>提供完整虚拟机隔离，避免宿主机干扰。</td>
</tr>
<tr>
<td>机器学习或 GPU 加速任务</td>
<td>WSL2</td>
<td>支持 GPU 直通和 CUDA 加速，性能接近原生。</td>
</tr>
<tr>
<td>跨平台兼容性测试</td>
<td>Hyper-V</td>
<td>可运行不同内核版本或非 Linux 系统（如 FreeBSD）。</td>
</tr>
<tr>
<td>文件密集型任务（如大数据处理）</td>
<td>WSL2</td>
<td>若数据存储在 Linux 分区内，I&#x2F;O 性能优于 Hyper-V。</td>
</tr>
</tbody></table>
<hr>
<h3 id="四、优化建议"><a href="#四、优化建议" class="headerlink" title="四、优化建议"></a><strong>四、优化建议</strong></h3><ol>
<li><p><strong>WSL2 配置优化</strong><br>• 修改 <code>.wslconfig</code> 文件，增加内存和 CPU 配额（如 <code>memory=8GB</code>）。<br>• 将代码和 Docker 数据卷存储在 WSL2 的 Linux 文件系统内（路径示例：<code>/home/user/project</code>）。</p>
</li>
<li><p><strong>Hyper-V 配置优化</strong><br>• 减少预分配内存（如从 4GB 降至 2GB），避免资源浪费。<br>• 使用 SSD 硬盘以缓解 I&#x2F;O 性能瓶颈。</p>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>• <strong>WSL2 是大多数开发场景的首选</strong>，尤其在性能、资源利用率和开发工具集成方面表现优异。<br>• <strong>Hyper-V 更适合需要严格隔离或运行特殊内核的场景</strong>，但需接受更高的性能损失。<br>• 根据具体需求灵活选择，亦可同时启用两种模式（需切换 Docker Desktop 后端）。</p>
]]></content>
      <categories>
        <category>RAG</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>RAG</tag>
        <tag>RAGFlow</tag>
        <tag>Ollama</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo开发</title>
    <url>/2025/03/03/HexoDev/</url>
    <content><![CDATA[<h1 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h1><h2 id="Hexo开发去除缓存-重新刷新生成"><a href="#Hexo开发去除缓存-重新刷新生成" class="headerlink" title="Hexo开发去除缓存-重新刷新生成"></a>Hexo开发去除缓存-重新刷新生成</h2><h3 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h3><p>在开发一个 Hexo 插件，在开发的过程中，遇到了一些小的问题：插件的代码发生了修改，但运行hexo 的时候却没有实时刷新出来。</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>在对代码进行分析后发现，hexo 的 tag filter 的结果会缓存在数据库中，由于缓存了，所以我使用的 generator ，所以也会被缓存。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>在预览前，删除 db.json 即可让 hexo 重新开始生成</p>
<h2 id="网页缓存问题"><a href="#网页缓存问题" class="headerlink" title="网页缓存问题"></a>网页缓存问题</h2><p>F12打开开发者工具，网络部分，选择禁用缓存即可。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>UE5.5-GameplayPrediction</title>
    <url>/2025/03/05/UE55GamplayPrediction/</url>
    <content><![CDATA[<h1 id="SourceCode源码"><a href="#SourceCode源码" class="headerlink" title="SourceCode源码"></a><a href="https://github.com/MikeMing126/UESourceCode/blob/main/UE55_GAS_GameplayPrediction.h">SourceCode源码</a></h1><h1 id="Overview-of-Gameplay-Ability-Prediction"><a href="#Overview-of-Gameplay-Ability-Prediction" class="headerlink" title="Overview of Gameplay Ability Prediction"></a>Overview of Gameplay Ability Prediction</h1><h2 id="High-Level-Goals"><a href="#High-Level-Goals" class="headerlink" title="High Level Goals"></a>High Level Goals</h2><ul>
<li>At the GameplayAbility level (implementing an ability) prediction is transparent. An ability says “Do X-&gt;Y-&gt;Z”, and we will automatically predict the parts of that that we can.</li>
<li>We wish to avoid having logic such as “If Authority: Do X. Else: Do predictive version of X” in the ability itself.</li>
</ul>
<p>At this point, not all cases are solved, but we have a very solid framework for working with client side prediction.</p>
<p>When we say “client side prediction” we really mean client predicting game simulation state. Things can still be ‘completely client side’ without having to work within a prediction system.<br>For example, footsteps are completely client side and never interact with this system. But clients predicting their mana going from 100 to 90 when they cast a spell is ‘client side prediction’.</p>
<h2 id="What-do-we-currently-predict"><a href="#What-do-we-currently-predict" class="headerlink" title="What do we currently predict?"></a>What do we currently predict?</h2><ul>
<li>Initial GameplayAbility activation (and chained activation with caveats)</li>
<li>Triggered Events</li>
<li>GameplayEffect application:<ul>
<li>Attribute modification (EXCEPTIONS: Executions do not currently predict, only attribute modifiers)</li>
<li>GameplayTag modification</li>
</ul>
</li>
<li>Gameplay Cue events (both from within predictive gameplay effect and on their own)</li>
<li>Montages</li>
<li>Movement (built into UE UCharacterMovement)</li>
</ul>
<h2 id="Some-things-we-don’t-predict-most-of-these-we-potentially-could-but-currently-dont"><a href="#Some-things-we-don’t-predict-most-of-these-we-potentially-could-but-currently-dont" class="headerlink" title="Some things we don’t predict (most of these we potentially could, but currently dont):"></a>Some things we don’t predict (most of these we potentially could, but currently dont):</h2><ul>
<li>GameplayEffect removal</li>
<li>GameplayEffect periodic effects (dots ticking)</li>
</ul>
<h2 id="Problems-we-attempt-to-solve"><a href="#Problems-we-attempt-to-solve" class="headerlink" title="Problems we attempt to solve"></a>Problems we attempt to solve</h2><ol>
<li>“Can I do this?” Basic protocol for prediction.</li>
<li>“Undo” How to undo side effects when a prediction fails.</li>
<li>“Redo” How to avoid replaying side effects that we predicted locally but that also get replicated from the server.</li>
<li>“Completeness” How to be sure we &#x2F;really&#x2F; predicted all side effects.</li>
<li>“Dependencies” How to manage dependent prediction and chains of predicted events.</li>
<li>“Override” How to override state predictively that is otherwise replicated&#x2F;owned by the server.</li>
</ol>
<hr>
<h2 id="Implementation-Details"><a href="#Implementation-Details" class="headerlink" title="Implementation Details"></a>Implementation Details</h2><h3 id="​​-PredictionKey-​"><a href="#​​-PredictionKey-​" class="headerlink" title="​​ PredictionKey ​"></a>​<em><strong>​ PredictionKey ​</strong></em></h3><p>A fundamental concept in this system is the <code>FPredictionKey</code>. A prediction key on its own is simply a unique ID that is generated in a central place on the client. The client will send its prediction key to the server,<br>and associate predictive actions and side effects with this key. The server may respond with an accept&#x2F;reject for the prediction key, and will also associate the server-side created side effects with this prediction key.</p>
<p>(IMPORTANT) <code>FPredictionKey</code> always replicates client -&gt; server, but when replicating server -&gt; clients they <em>only</em> replicate to the client that sent the prediction key to the server in the first place.<br>This happens in <code>FPredictionKey::NetSerialize</code>. All other clients will receive an invalid (0) prediction key when a prediction key sent from a client is replicated back down through a replicated property.</p>
<hr>
<h3 id="​​-Ability-Activation-​"><a href="#​​-Ability-Activation-​" class="headerlink" title="​​ Ability Activation ​"></a>​<em><strong>​ Ability Activation ​</strong></em></h3><p>Ability Activation is a first class predictive action – it generates an initial prediction key. Whenever a client predictively activates an ability, it explicitly asks the server and the server explicitly responds. Once an ability has been<br>predictively activated (but the request has not yet been sent), the client has a valid ‘prediction window’ where predictive side effects can happen which are not explicitly ‘asked about’. (E.g., we do not explicitly ask ‘Can I decrement mana, Can I put this ability on cooldown. Those actions are considered logically atomic with activating an ability). You can think of this prediction window as being the initial callstack of <code>ActivateAbility</code>. Once <code>ActivateAbility</code> ends, your<br>prediction window (and therefore your prediction key) is no longer valid. This is important, because many things can invalidate your prediction window such as any timers or latent nodes in your Blueprint; we do not predict over multiple frames.</p>
<p><strong>AbilitySystemComponent</strong>​ provides a set of functions for communicating ability activation between clients and server: <code>TryActivateAbility</code> -&gt; <code>ServerTryActivateAbility</code> -&gt; <code>ClientActivateAbility(Failed/Succeed)</code>.</p>
<ol>
<li>Client calls <code>TryActivateAbility</code> which generates a new <code>FPredictionKey</code> and calls <code>ServerTryActivateAbility</code>.</li>
<li>Client continues (before hearing back from server) and calls <code>ActivateAbility</code> with the generated <code>PredictionKey</code> associated with the Ability’s <code>ActivationInfo</code>.</li>
<li>Any side effects that happen &#x2F;before the call to <code>ActivateAbility</code> finish&#x2F; have the generated <code>FPredictionKey</code> associated with them.</li>
<li>Server decides if the ability really happened in <code>ServerTryActivateAbility</code>, calls <code>ClientActivateAbility(Failed/Succeed)</code> and sets <code>UAbilitySystemComponent::ReplicatedPredictionKey</code> to the generated key that was sent with the request by the client.</li>
<li>If client receives <code>ClientAbilityFailed</code>, it immediately kills the ability and rolls back side effects that were associated with the prediction key.<ul>
<li>‘Rolling back’ logic is registered via <code>FPredictionKeyDelegates</code> and <code>FPredictionKey::NewRejectedDelegate/NewCaughtUpDelegate/NewRejectOrCaughtUpDelegate</code>.</li>
<li><code>ClientAbilityFailed</code> is really the only case where we ‘reject’ prediction keys and thus all of our current predictions rely on if an ability activates or not.</li>
</ul>
</li>
<li>If <code>ServerTryActivateAbility</code> succeeds, client must wait until property replication catches up (the Succeed RPC will be sent immediately, property replication will happen on its own). Once the <code>ReplicatedPredictionKey</code> catches up to the<br>key used previous steps, the client can undo its predictive side effects.<ul>
<li>See <code>FReplicatedPredictionKeyItem::OnRep</code> for the CatchUpTo logic. See <code>UAbilitySystemComponent::ReplicatedPredictionKeyMap</code> for how the keys actually get replicated. See ~&#96;FScopedPredictionWindow&#96; where the server acknowledges keys.</li>
</ul>
</li>
</ol>
<hr>
<h3 id="​​-GameplayEffect-Prediction-​"><a href="#​​-GameplayEffect-Prediction-​" class="headerlink" title="​​ GameplayEffect Prediction ​"></a>​<em><strong>​ GameplayEffect Prediction ​</strong></em></h3><p>GameplayEffects are considered side effects of ability activation and are not separately accepted&#x2F;rejected.</p>
<ol>
<li>GameplayEffects are only applied on clients if there is a valid prediction key. (If no prediction key, it simply skips the application on client).</li>
<li>Attributes, GameplayCues, and GameplayTags are all predicted if the GameplayEffect is predicted.</li>
<li>When the <code>FActiveGameplayEffect</code> is created, it stores the prediction key (<code>FActiveGameplayEffect::PredictionKey</code>)<ul>
<li>Instant effects are explained below in “Attribute Prediction”.</li>
</ul>
</li>
<li>On the server, the same prediction key is also set on the server’s <code>FActiveGameplayEffect</code> that will be replicated down.</li>
<li>As a client, if you get a replicated <code>FActiveGameplayEffect</code> with a valid prediction key on it, you check to see if you have an <code>ActiveGameplayEffect</code> with that same key, if there is match, we do not apply<br>the ‘on applied’ type of logic, e.g., GameplayCues. The solves the “Redo” problem. However we will have 2 of the ‘same’ GameplayEffects in our ActiveGameplayEffects container, temporarily:</li>
<li>At the same time, <code>FReplicatedPredictionKeyItem::OnRep</code> will catch up and the predictive effects will be removed. When they are removed in this case, we again check <code>PredictionKey</code> and decide<br>if we should not do the ‘On Remove’ logic &#x2F; GameplayCue.</li>
</ol>
<p>See <code>FActiveGameplayEffectsContainer::ApplyGameplayEffectSpec</code> where it registers what to do when caught-up (RemoveActiveGameplayEffect_NoReturn).<br>See <code>FActiveGameplayEffect::PostReplicatedAdd</code>, <code>FActiveGameplayEffect::PreReplicatedRemove</code>, and <code>FActiveGameplayCue::PostReplicatedAdd</code> for examples of how <code>FPredictionKey</code> is associated with the GE’s and GC’s.</p>
<hr>
<h3 id="​​-Attribute-Prediction-​"><a href="#​​-Attribute-Prediction-​" class="headerlink" title="​​ Attribute Prediction ​"></a>​<em><strong>​ Attribute Prediction ​</strong></em></h3><p>Since attributes are replicated as standard uproperties, predicting modification to them can be tricky (“Override” problem). Instantaneous modification can be even harder since these are non stateful by nature.<br>(E.g., rolling back an attribute mod is difficult if there is no book keeping past the modification). This makes the “Undo” and “Redo” problem also hard in this case.</p>
<p>The basic plan of attack is to treat attribute prediction as delta prediction rather than absolute value prediction. We do not predict that we have 90 mana, we predict that we have -10 mana from the server value, until<br>the server confirms our prediction key. Basically, treat instant modifications as &#x2F;infinite duration modifications&#x2F; to attributes while they are done predictively. The solves “Undo” and “Redo”.</p>
<p>For the “override” problem, we can handle this in the properties <code>OnRep</code> by treating the replicated (server) value as the ‘base value’ instead of ‘final value’ of the attribute, and to<br>reaggregate our ‘final value’ after a replication happens.</p>
<h4 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UMyHealthSet::GetLifetimeReplicatedProps</span><span class="params">(TArray&lt; FLifetimeProperty &gt; &amp; OutLifetimeProps)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::<span class="built_in">GetLifetimeReplicatedProps</span>(OutLifetimeProps);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">DOREPLIFETIME_CONDITION_NOTIFY</span>(UMyHealthSet, Health, COND_None, REPNOTIFY_Always);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Gameplay-Cue-Events"><a href="#Gameplay-Cue-Events" class="headerlink" title="Gameplay Cue Events"></a>Gameplay Cue Events</h1><p>Outside of GameplayEffects which are already explained, Gameplay Cues can be activated on their own. These functions (<code>UAbilitySystemComponent::ExecuteGameplayCue</code> etc) take network role and prediction keys into account.</p>
<p>In <code>UAbilitySystemComponent::ExecuteGameplayCue</code>, if authority then do the multicast event (with replication key). If non authority but w&#x2F; a valid prediction key, predict the GameplayCue.<br>On the receiving end (<code>NetMulticast_InvokeGameplayCueExecuted</code> etc), if there is a replication key, then don’t do the event (assume you predicted it).<br>Remember that <code>FPredictionKeys</code> only replicate to the originating owner. This is an intrinsic property of <code>FReplicationKey</code>.</p>
<hr>
<h1 id="Triggered-Data-Prediction"><a href="#Triggered-Data-Prediction" class="headerlink" title="Triggered Data Prediction"></a>Triggered Data Prediction</h1><p>Triggered Data is currently used to activate abilities. Essentially this all goes through the same code path as ActivateAbility. Rather than the ability being activated from input press, it is activated from<br>another game code driven event. Clients are able to predictively execute these events which predictively activate abilities.</p>
<p>There are some nuances to how, since the server will also run the code that triggers events. The server won’t just wait to hear from the client. The server will keep a list of triggered abilities that have been<br>activated from a predictive ability. When receiving a <code>TryActivate</code> from a triggered ability, the server will look to see if &#x2F;it&#x2F; has already run this ability, and respond with that information.</p>
<p>The issue is we do not properly rollback these operations. There is work left to do on Triggered Events and replication. (explained at the end).</p>
<hr>
<h2 id="Advanced-topic-Dependencies"><a href="#Advanced-topic-Dependencies" class="headerlink" title="Advanced topic! Dependencies"></a>Advanced topic! Dependencies</h2><p>We can have situations such as “Ability X activates and immediately triggers an event which activates Ability Y which triggers another Ability Z”. The dependency chain is X-&gt;Y-&gt;Z.<br>Each of those abilities could be rejected by the server. If Y is rejected, then Z also never happened, but the server does not explicitly decide ‘no Z can’t run’.<br>To handle this, we have a concept of a Base PredictionKey, which is a member of <code>FPredictionKey</code>. When calling <code>TryActivateAbility</code>, we pass in the current PredictionKey (if applicable). That prediction key<br>is used as the base for any new prediction keys generated. We build a chain of keys this way, and can then invalidate Z if Y is rejected.</p>
<p>This is slightly more nuanced though. In the X-&gt;Y-&gt;Z case, the server will only receive the PredictionKey for X before trying to run the chain itself. E.g., it will TryActivate Y and Z with the original prediction key<br>sent to it from the client, whereas the client will generate a new PredictionKey each time it calls <code>TryActivateAbility</code>. The client has to generate a new PredictionKey for each ability activate, since each activate<br>is not logically atomic. Each side effect produced in the chain of events has to have a unique PredictionKey. We cannot have GameplayEffects produced in X have the same PredictionKey produced in Z.</p>
<p>To get around this, The prediction key of X is considered the Base key for Y and Z. The dependency from Y to Z is kept completely client side, which is done in by <code>FPredictionKeyDelegates::AddDependency</code>. We add delegates<br>to reject&#x2F;catchup Z if Y rejected&#x2F;confirmed.</p>
<p>This dependency system allows us to have multiple predictive actions that are not logically atomic within a single prediction window&#x2F;scope.</p>
<p>There is a problem though: because the dependencies are kept client side, the server does not actually know if it had previously rejected a dependent action. You can design around this issue by using activation tags<br>in your gameplay abilities. For instance, when predicting dependents GA_Combo1 -&gt; GA_Combo2, you could make GA_Combo2 only activate if it has a GameplayTag given by GA_Combo1. Thus a rejection of GA_Combo1 would also<br>cause the server to reject the activation of GA_Combo2.</p>
<hr>
<h1 id="Additional-Prediction-Windows-within-an-Ability"><a href="#Additional-Prediction-Windows-within-an-Ability" class="headerlink" title="Additional Prediction Windows (within an Ability)"></a>Additional Prediction Windows (within an Ability)</h1><p>As stated, A prediction key is only usable during a single logical scope. Once <code>ActivateAbility</code> returns, we are essentially done with that key. If the ability is waiting on an external event or timer, it’s possible<br>we will have already received a confirm&#x2F;reject from the server by the time we’re ready to continue execution. Thus any additional side effects produced after the initial activation can no longer be tied to the lifespan of the original key.</p>
<p>This isn’t that bad, except that abilities will sometimes want to react to player input. For example, ‘a hold down and charge’ ability wants to instantly predict some stuff when the button is released. It is possible<br>to create a new prediction window within an ability with <code>FScopedPredictionWindow</code>.</p>
<p><strong>FScopedPredictionWindows</strong>​ provides a way to send the server a new prediction key and have the server pick up and use that key within the same logical scope.</p>
<p><code>UAbilityTask_WaitInputRelease::OnReleaseCallback</code> is a good example. The flow of events is as followed:</p>
<ol>
<li>Client enters <code>UAbilityTask_WaitInputRelease::OnReleaseCallback</code> and starts a new <code>FScopedPredictionWindow</code>. This creates a new prediction key for this scope (<code>FScopedPredictionWindow::ScopedPredictionKey</code>).</li>
<li>Client calls <code>AbilitySystemComponent-&gt;ServerInputRelease</code> which passes <code>ScopedPrediction.ScopedPredictionKey</code> as a parameter.</li>
<li>Server runs <code>ServerInputRelease_Implementation</code> which takes the passed in PredictionKey and sets it as <code>UAbilitySystemComponent::ScopedPredictionKey</code> with an <code>FScopedPredictionWindow</code>.</li>
<li>Server runs <code>UAbilityTask_WaitInputRelease::OnReleaseCallback</code> &#x2F;within the same scope&#x2F;</li>
<li>When the server hits the <code>FScopedPredictionWindow</code> in ::OnReleaseCallback, it gets the prediction key from <code>UAbilitySystemComponent::ScopedPredictionKey</code>. That is now used for all side effects within this logical scope.</li>
<li>Once the server ends this scoped prediction window, the prediction key used is finished and set to <code>ReplicatedPredictionKey</code>.</li>
<li>All side effects created in this scope now share a key between client and server.</li>
</ol>
<p>The key to this working is that ::OnReleaseCallback calls ::ServerInputRelease which calls ::OnReleaseCallback on the server. There is no room for anything else to happen and use the given prediction key.</p>
<p>While there is no “Try&#x2F;Failed&#x2F;Succeed” calls in this example, all side effects are procedurally grouped&#x2F;atomic. This solves the “Undo” and “Redo” problems for any arbitrary function calls that run on the server and client.</p>
<hr>
<h1 id="Unsupported-Issues-Todo"><a href="#Unsupported-Issues-Todo" class="headerlink" title="Unsupported &#x2F; Issues&#x2F; Todo"></a>Unsupported &#x2F; Issues&#x2F; Todo</h1><h3 id="Triggered-events-do-not-explicitly-replicate"><a href="#Triggered-events-do-not-explicitly-replicate" class="headerlink" title="Triggered events do not explicitly replicate"></a>Triggered events do not explicitly replicate</h3><ul>
<li>E.g., if a triggered event only runs on the server, the client will never hear about it. This also prevents us from doing cross player&#x2F;AI etc events. Support<br>for this should eventually be added and it should follow the same pattern that GameplayEffect and GameplayCues follow (predict triggered event with a prediction key, ignore the RPC event if it has a prediction key).</li>
</ul>
<p>Big caveat with this whole system: Rollback of any chained activations (including triggered events) is currently not possible out of the box. The reason for this is because each ServerTryActivateAbility is going to be responded to in order.<br>Let’s chain dependent GA’s as an example: GA_Mispredict -&gt; GA_Predict1. In this example, when GA_Mispredict is activated and predicted locally it will immediately also activate GA_Predict1. The client sends ServerTryActivateAbility for GA_Mispredict,<br>and the server rejects it (sending back a ClientActivateAbilityFailed). As it stands, we don’t have any delegates that reject dependent abilities on the client (and the server isn’t even aware there are dependencies). On the server, it also<br>receives a ServerTryActivateAbility for GA_Predict1. Assuming that succeeds, the Client and Server are now both executing GA_Predict1 even though GA_Mispredict never happened. You can design around this by using the tag system to ensure GA_Mispredict succeeded.</p>
<hr>
<h3 id="Predicting-“Meta”-Attributes-such-as-Damage-Healing-vs-“real”-attributes-such-as-Health"><a href="#Predicting-“Meta”-Attributes-such-as-Damage-Healing-vs-“real”-attributes-such-as-Health" class="headerlink" title="Predicting “Meta” Attributes such as Damage&#x2F;Healing vs “real” attributes such as Health"></a>Predicting “Meta” Attributes such as Damage&#x2F;Healing vs “real” attributes such as Health</h3><p>We are unable to apply meta attributes predictively. Meta attributes only work on instant effects, in the back end of GameplayEffect (Pre&#x2F;Post Modify Attribute on the UAttributeSet). These events are not called when<br>applying duration-based gameplay effects. E.g., a GameplayEffect that modifies damage for 5 seconds doesn’t make sense.</p>
<p>In order to support this, we would probably add some limited support for duration based meta attributes, and move the transform of the instant gameplay effect from the front end (<code>UAbilitySystemComponent::ApplyGameplayEffectSpecToSelf</code>)<br>to the backend (<code>UAttributeSet::PostModifyAttribute</code>).</p>
<hr>
<h3 id="Predicting-ongoing-multiplicative-GameplayEffects"><a href="#Predicting-ongoing-multiplicative-GameplayEffects" class="headerlink" title="Predicting ongoing multiplicative GameplayEffects"></a>Predicting ongoing multiplicative GameplayEffects</h3><p>There are also limitations when predicting % based gameplay effects. Since the server replicates down the ‘final value’ of an attribute, but not the entire aggregator chain of what is modifying it, we may run into cases where<br>the client cannot accurately predict new gameplay effects.</p>
<p>For example:</p>
<ul>
<li>Client has a perm +10% movement speed buff with base movement speed of 500 -&gt; 550 is the final movement speed for this client.</li>
<li>Client has an ability which grants an additional 10% movement speed buff. It is expected to <em>sum</em> the % based multipliers for a final 20% bonus to 500 -&gt; 600 movement speed.</li>
<li>However on the client, we just apply a 10% buff to 550 -&gt; 605.</li>
</ul>
<p>This will need to be fixed by replicating down the aggregator chain for attributes. We already replicate some of this data, but not the full modifier list. We will need to look into supporting this eventually.</p>
<hr>
<h3 id="“Weak-Prediction”"><a href="#“Weak-Prediction”" class="headerlink" title="“Weak Prediction”"></a>“Weak Prediction”</h3><p>We will probably still have cases that do not fit well into this system. Some situations will exist where a prediction key exchange is not feasible. For example, an ability where any one that player collides with&#x2F;touches<br>receives a GameplayEffect that slows them and their material blue. Since we can’t send Server RPCs every time this happens (and the server couldn’t necessarily handle the message at its point in the simulation), there is no<br>way to correlate the gameplay effect side effects between client and server.</p>
<p>One approach here may be to think about a weaker form of prediction. One where there is not a fresh prediction key used and instead the server assumes the client will predict all side effects from an entire ability. This would<br>at least solve the “redo” problem but would not solve the “completeness” problem. If the client side prediction could be made as minimal as possible - for example only predicting an initial particle effect rather than<br>predicting the state and attribute change - then the problems get less severe.</p>
<hr>
<h1 id="FPredictionKey-Implementation-Notes"><a href="#FPredictionKey-Implementation-Notes" class="headerlink" title="FPredictionKey Implementation Notes"></a>FPredictionKey Implementation Notes</h1><p><code>FPredictionKey</code> is a generic way of supporting Clientside Prediction in the GameplayAbility system.<br>A <code>FPredictionKey</code> is essentially an ID for identifying predictive actions and side effects that are<br>done on a client. <code>UAbilitySystemComponent</code> supports synchronization of the prediction key and its side effects<br>between client and server.</p>
<p>Essentially, anything can be associated with a <code>PredictionKey</code>, for example activating an Ability.<br>The client can generate a fresh <code>PredictionKey</code> and sends it to the server in its <code>ServerTryActivateAbility</code> call.<br>The server can confirm or reject this call (<code>ClientActivateAbilitySucceed/Failed</code>).</p>
<p>While the client is predicting its ability, it is creating side effects (GameplayEffects, TriggeredEvents, Animations, etc).<br>As the client predicts these side effects, it associates each one with the prediction key generated at the start of the ability<br>activation.</p>
<p>If the ability activation is rejected, the client can immediately revert these side effects.<br>If the ability activation is accepted, the client must wait until the replicated side effects are sent to the server.<br>(The <code>ClientActivatbleAbilitySucceed</code> RPC will be immediately sent. Property replication may happen a few frames later).<br>Once replication of the server created side effects is finished, the client can undo its locally predictive side effects.</p>
<p>The main things <code>FPredictionKey</code> itself provides are:</p>
<ul>
<li>Unique ID and a system for having dependant chains of <code>Prediction Keys</code> (“Current” and “Base” integers)</li>
<li>A special implementation of <code>::NetSerialize</code> which only serializes the prediction key to the predicting client<ul>
<li>This is important as it allows us to serialize prediction keys in replicated state, knowing that only clients that gave the server the prediction key will actually see them!</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>UE Source</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>GAS</tag>
        <tag>UE Source</tag>
      </tags>
  </entry>
  <entry>
    <title>UE GAS Modifier相关信息</title>
    <url>/2025/03/23/UE55GASModifierInfos/</url>
    <content><![CDATA[<h1 id="总"><a href="#总" class="headerlink" title="总"></a>总</h1><p>列举各个Modifier相关的信息</p>
<h2 id="FGameplayModifierInfo"><a href="#FGameplayModifierInfo" class="headerlink" title="FGameplayModifierInfo"></a>FGameplayModifierInfo</h2><p>用于定义修改器的规则<br>关键数据 </p>
<ul>
<li>目标属性</li>
<li>修改方式</li>
<li>修改值</li>
<li>生效条件(Tags)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * FGameplayModifierInfo</span><br><span class="line"> *	Tells us &quot;Who/What we&quot; modify</span><br><span class="line"> *	Does not tell us how exactly</span><br><span class="line"> */</span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line">struct GAMEPLAYABILITIES_API FGameplayModifierInfo</span><br><span class="line">&#123;</span><br><span class="line">	GENERATED_USTRUCT_BODY()</span><br><span class="line">	</span><br><span class="line">	/** The Attribute we modify or the GE we modify modifies. */</span><br><span class="line">	UPROPERTY(EditDefaultsOnly, Category=GameplayModifier, meta=(FilterMetaTag=&quot;HideFromModifiers&quot;))</span><br><span class="line">	FGameplayAttribute Attribute;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * The numeric operation of this modifier: Override, Add, Multiply, etc</span><br><span class="line">	 * When multiple modifiers aggregate together, the equation is:</span><br><span class="line">	 * ((BaseValue + AddBase) * MultiplyAdditive / DivideAdditive * MultiplyCompound) + AddFinal</span><br><span class="line">	 */</span><br><span class="line">	UPROPERTY(EditDefaultsOnly, Category=GameplayModifier)</span><br><span class="line">	TEnumAsByte&lt;EGameplayModOp::Type&gt; ModifierOp = EGameplayModOp::Additive;</span><br><span class="line"></span><br><span class="line">	/** Magnitude of the modifier */</span><br><span class="line">	UPROPERTY(EditDefaultsOnly, Category=GameplayModifier)</span><br><span class="line">	FGameplayEffectModifierMagnitude ModifierMagnitude;</span><br><span class="line"></span><br><span class="line">	/** Evaluation channel settings of the modifier */</span><br><span class="line">	UPROPERTY(EditDefaultsOnly, Category=GameplayModifier)</span><br><span class="line">	FGameplayModEvaluationChannelSettings EvaluationChannelSettings;</span><br><span class="line"></span><br><span class="line">	UPROPERTY(EditDefaultsOnly, Category=GameplayModifier)</span><br><span class="line">	FGameplayTagRequirements	SourceTags;</span><br><span class="line"></span><br><span class="line">	UPROPERTY(EditDefaultsOnly, Category=GameplayModifier)</span><br><span class="line">	FGameplayTagRequirements	TargetTags;</span><br><span class="line"></span><br><span class="line">	/** Equality/Inequality operators */</span><br><span class="line">	bool operator==(const FGameplayModifierInfo&amp; Other) const;</span><br><span class="line">	bool operator!=(const FGameplayModifierInfo&amp; Other) const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="FModifierSpec"><a href="#FModifierSpec" class="headerlink" title="FModifierSpec"></a>FModifierSpec</h2><p>存储GEModifier的最终计算值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** Holds evaluated magnitude from a GameplayEffect modifier */</span><br><span class="line">USTRUCT()</span><br><span class="line">struct FModifierSpec</span><br><span class="line">&#123;</span><br><span class="line">	GENERATED_USTRUCT_BODY()</span><br><span class="line"></span><br><span class="line">	FModifierSpec() : EvaluatedMagnitude(0.f) &#123; &#125;</span><br><span class="line"></span><br><span class="line">	float GetEvaluatedMagnitude() const &#123; return EvaluatedMagnitude; &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">	/** In the event that the modifier spec requires custom magnitude calculations, this is the authoritative, last evaluated value of the magnitude */</span><br><span class="line">	UPROPERTY()</span><br><span class="line">	float EvaluatedMagnitude;</span><br><span class="line"></span><br><span class="line">	/** These structures are the only ones that should internally be able to update the EvaluatedMagnitude. Any gamecode that gets its hands on FModifierSpec should never be setting EvaluatedMagnitude manually */</span><br><span class="line">	friend struct FGameplayEffectSpec;</span><br><span class="line">	friend struct FActiveGameplayEffectsContainer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="FGameplayModifierEvaluatedData"><a href="#FGameplayModifierEvaluatedData" class="headerlink" title="FGameplayModifierEvaluatedData"></a>FGameplayModifierEvaluatedData</h2><p>修改器具体结果数据<br>关键数据 </p>
<ul>
<li>目标属性</li>
<li>修改方式</li>
<li>修改值</li>
<li>FActiveGEHandle</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** Data that describes what happened in an attribute modification. This is passed to ability set callbacks */</span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line">struct FGameplayModifierEvaluatedData</span><br><span class="line">&#123;</span><br><span class="line">	GENERATED_USTRUCT_BODY()</span><br><span class="line"></span><br><span class="line">	FGameplayModifierEvaluatedData()</span><br><span class="line">		: Attribute()</span><br><span class="line">		, ModifierOp(EGameplayModOp::Additive)</span><br><span class="line">		, Magnitude(0.f)</span><br><span class="line">		, IsValid(false)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FGameplayModifierEvaluatedData(const FGameplayAttribute&amp; InAttribute, TEnumAsByte&lt;EGameplayModOp::Type&gt; InModOp, float InMagnitude, FActiveGameplayEffectHandle InHandle = FActiveGameplayEffectHandle())</span><br><span class="line">		: Attribute(InAttribute)</span><br><span class="line">		, ModifierOp(InModOp)</span><br><span class="line">		, Magnitude(InMagnitude)</span><br><span class="line">		, Handle(InHandle)</span><br><span class="line">		, IsValid(true)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/** What attribute was modified */</span><br><span class="line">	UPROPERTY()</span><br><span class="line">	FGameplayAttribute Attribute;</span><br><span class="line"></span><br><span class="line">	/** The numeric operation of this modifier: Override, Add, Multiply, etc  */</span><br><span class="line">	UPROPERTY()</span><br><span class="line">	TEnumAsByte&lt;EGameplayModOp::Type&gt; ModifierOp;</span><br><span class="line"></span><br><span class="line">	/** The raw magnitude of the applied attribute, this is generally before being clamped */</span><br><span class="line">	UPROPERTY()</span><br><span class="line">	float Magnitude;</span><br><span class="line"></span><br><span class="line">	/** Handle of the active gameplay effect that originated us. Will be invalid in many cases */</span><br><span class="line">	UPROPERTY()</span><br><span class="line">	FActiveGameplayEffectHandle	Handle;</span><br><span class="line"></span><br><span class="line">	/** True if something was evaluated */</span><br><span class="line">	UPROPERTY()</span><br><span class="line">	bool IsValid;</span><br><span class="line"></span><br><span class="line">	FString ToSimpleString() const</span><br><span class="line">	&#123;</span><br><span class="line">		return FString::Printf(TEXT(&quot;%s %s EvalMag: %f&quot;), *Attribute.GetName(), *EGameplayModOpToString(ModifierOp), Magnitude);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>UEGAS</tag>
        <tag>GAS Modifier</tag>
      </tags>
  </entry>
  <entry>
    <title>UE5.5-Lyra-2-GE</title>
    <url>/2025/03/23/UE55Lyra2/</url>
    <content><![CDATA[<h1 id="GE"><a href="#GE" class="headerlink" title="GE"></a>GE</h1><p>蓝图创建的GE。<br>基于 GameplayEffectParent_Damage_Basic 来看<br>GE:</p>
<ul>
<li>Gameplay效果<ul>
<li>组件 GEComponents<ul>
<li>包含很多个效果 可以在编辑器中细看</li>
</ul>
</li>
<li>修饰符 Modifiers</li>
<li>执行 Executions</li>
</ul>
</li>
<li>Gameplay Cue</li>
</ul>
<h2 id="GE的执行流程"><a href="#GE的执行流程" class="headerlink" title="GE的执行流程"></a>GE的执行流程</h2><p>以GA的ApplyCost为例子：</p>
<p>GA:ApplyGameplayEffectToOwner<br>↓<br>GA:ApplyGameplayEffectSpecToOwner<br>↓<br>ASC:ApplyGameplayEffectSpecToSelf</p>
<p>到这里可以分为两条路线了，一条是即刻执行的GE，Instant类型。第二种是有持续时间的GE（包括永久）。对于后者，会生成FActiveGameplayEffect。</p>
<p>在ASC:ApplyGameplayEffectSpecToSelf中就有两个关键函数了：</p>
<ul>
<li>持续类型的 由ASC的FActiveGameplayEffectContainer调用ApplyGameplayEffectSpec处理</li>
<li>Intant类型 ASC:ExecuteGameplayEffect</li>
</ul>
<p>ASC:ExecuteGameplayEffect<br>↓<br>由ASC的FActiveGameplayEffectContainer调用ExecuteActiveEffectsFrom。</p>
<p>虽然Instant类型，并不会生成FActiveGameplayEffect，可以认为是不会暴露给外部的，但执行接口可以一致。</p>
<p>ActiveGEContainer:ExecuteActiveEffectsFrom<br>↓<br>[一些关键函数]<br>GESpec:CalculateModifierMagnitudes</p>
<p>执行GE的Modifiers</p>
<ul>
<li>InternalExecuteMod</li>
</ul>
<p>执行各个Executions</p>
<ul>
<li>Execution:Execute(子类还是Execute_Implementation)</li>
<li>执行Execute内部生成的Modifiers<ul>
<li>InternalExecuteMod</li>
</ul>
</li>
</ul>
<p>↓<br>ActiveGEContainer:InternalExecuteMod<br>↓<br>ActiveGEContainer:ApplyModToAttribute<br>↓<br>ActiveGEContainer:SetAttributeBaseValue [更新BaseValue与CurrentValue]</p>
<h2 id="Execution"><a href="#Execution" class="headerlink" title="Execution"></a>Execution</h2><h3 id="Execution-LyraDamageExecution"><a href="#Execution-LyraDamageExecution" class="headerlink" title="Execution - LyraDamageExecution"></a>Execution - LyraDamageExecution</h3><p>继承链条：<br>UGameplayEffectCalculation<br>↓<br>UGameplayEffectExecutionCalculation<br>↓<br>ULyraDamageExecution</p>
<h4 id="GameplayEffectExecutionCalculation"><a href="#GameplayEffectExecutionCalculation" class="headerlink" title="GameplayEffectExecutionCalculation"></a>GameplayEffectExecutionCalculation</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//关键函数</span><br><span class="line">/**</span><br><span class="line">    * Called whenever the owning gameplay effect is executed. Allowed to do essentially whatever is desired, including generating new</span><br><span class="line">    * modifiers to instantly execute as well.</span><br><span class="line">    * </span><br><span class="line">    * @note: Native subclasses should override the auto-generated Execute_Implementation function and NOT this one.</span><br><span class="line">    * </span><br><span class="line">    * @param ExecutionParams		Parameters for the custom execution calculation</span><br><span class="line">    * @param OutExecutionOutput	[OUT] Output data populated by the execution detailing further behavior or results of the execution</span><br><span class="line">    */</span><br><span class="line">UFUNCTION(BlueprintNativeEvent, Category=&quot;Calculation&quot;)</span><br><span class="line">void Execute(const FGameplayEffectCustomExecutionParameters&amp; ExecutionParams, FGameplayEffectCustomExecutionOutput&amp; OutExecutionOutput) const;</span><br></pre></td></tr></table></figure>
<p>然后看到Lyra派生的伤害Execution:</p>
<h4 id="LyraDamageExecution"><a href="#LyraDamageExecution" class="headerlink" title="LyraDamageExecution"></a>LyraDamageExecution</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义Capture相关内容</span><br><span class="line"></span><br><span class="line">struct FDamageStatics</span><br><span class="line">&#123;</span><br><span class="line">    FGameplayEffectAttributeCaptureDefinition BaseDamageDef;</span><br><span class="line"></span><br><span class="line">    FDamageStatics()</span><br><span class="line">    &#123;</span><br><span class="line">        //CaptureSource有两种： Source 与 Target</span><br><span class="line">        //对应GE的Caster与Recipient</span><br><span class="line"></span><br><span class="line">        //指定捕获属性集的Damage</span><br><span class="line">        BaseDamageDef = FGameplayEffectAttributeCaptureDefinition(ULyraCombatSet::GetBaseDamageAttribute(), EGameplayEffectAttributeCaptureSource::Source, true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//提供单例模式访问</span><br><span class="line">static FDamageStatics&amp; DamageStatics()</span><br><span class="line">&#123;</span><br><span class="line">    static FDamageStatics Statics;</span><br><span class="line">    return Statics;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//属性Capture - &quot;Attributes to capture that are relevant to the calculation&quot;</span><br><span class="line">//这里的Capture定义了Execution的Modifier支持数据有哪些。算比较重要的一点。</span><br><span class="line">//如果没有添加对应的捕获属性，在编辑器视图看不到Execution的Modifiers。</span><br><span class="line">ULyraDamageExecution::ULyraDamageExecution()</span><br><span class="line">&#123;</span><br><span class="line">    RelevantAttributesToCapture.Add(DamageStatics().BaseDamageDef);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ULyraDamageExecution::Execute_Implementation(const FGameplayEffectCustomExecutionParameters&amp; ExecutionParams, FGameplayEffectCustomExecutionOutput&amp; OutExecutionOutput) const</span><br><span class="line">&#123;</span><br><span class="line">#if WITH_SERVER_CODE</span><br><span class="line">    const FGameplayEffectSpec&amp; Spec = ExecutionParams.GetOwningSpec();</span><br><span class="line">    FLyraGameplayEffectContext* TypedContext = FLyraGameplayEffectContext::ExtractEffectContext(Spec.GetContext());</span><br><span class="line">    check(TypedContext);</span><br><span class="line"></span><br><span class="line">    const FGameplayTagContainer* SourceTags = Spec.CapturedSourceTags.GetAggregatedTags();</span><br><span class="line">    const FGameplayTagContainer* TargetTags = Spec.CapturedTargetTags.GetAggregatedTags();</span><br><span class="line"></span><br><span class="line">    FAggregatorEvaluateParameters EvaluateParameters;</span><br><span class="line">    EvaluateParameters.SourceTags = SourceTags;</span><br><span class="line">    EvaluateParameters.TargetTags = TargetTags;</span><br><span class="line"></span><br><span class="line">    float BaseDamage = 0.0f;</span><br><span class="line">    //这里获取Execution定义的Modifier计算后的目标属性值</span><br><span class="line">    ExecutionParams.AttemptCalculateCapturedAttributeMagnitude(DamageStatics().BaseDamageDef, EvaluateParameters, BaseDamage);</span><br><span class="line"></span><br><span class="line">    //下面主要处理伤害的额外计算</span><br><span class="line">    //如距离 队伍 判定等</span><br><span class="line"></span><br><span class="line">    const AActor* EffectCauser = TypedContext-&gt;GetEffectCauser();</span><br><span class="line">    const FHitResult* HitActorResult = TypedContext-&gt;GetHitResult();</span><br><span class="line"></span><br><span class="line">    AActor* HitActor = nullptr;</span><br><span class="line">    FVector ImpactLocation = FVector::ZeroVector;</span><br><span class="line">    FVector ImpactNormal = FVector::ZeroVector;</span><br><span class="line">    FVector StartTrace = FVector::ZeroVector;</span><br><span class="line">    FVector EndTrace = FVector::ZeroVector;</span><br><span class="line"></span><br><span class="line">    // Calculation of hit actor, surface, zone, and distance all rely on whether the calculation has a hit result or not.</span><br><span class="line">    // Effects just being added directly w/o having been targeted will always come in without a hit result, which must default</span><br><span class="line">    // to some fallback information.</span><br><span class="line">    if (HitActorResult)</span><br><span class="line">    &#123;</span><br><span class="line">        const FHitResult&amp; CurHitResult = *HitActorResult;</span><br><span class="line">        HitActor = CurHitResult.HitObjectHandle.FetchActor();</span><br><span class="line">        if (HitActor)</span><br><span class="line">        &#123;</span><br><span class="line">            ImpactLocation = CurHitResult.ImpactPoint;</span><br><span class="line">            ImpactNormal = CurHitResult.ImpactNormal;</span><br><span class="line">            StartTrace = CurHitResult.TraceStart;</span><br><span class="line">            EndTrace = CurHitResult.TraceEnd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Handle case of no hit result or hit result not actually returning an actor</span><br><span class="line">    UAbilitySystemComponent* TargetAbilitySystemComponent = ExecutionParams.GetTargetAbilitySystemComponent();</span><br><span class="line">    if (!HitActor)</span><br><span class="line">    &#123;</span><br><span class="line">        HitActor = TargetAbilitySystemComponent ? TargetAbilitySystemComponent-&gt;GetAvatarActor_Direct() : nullptr;</span><br><span class="line">        if (HitActor)</span><br><span class="line">        &#123;</span><br><span class="line">            ImpactLocation = HitActor-&gt;GetActorLocation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Apply rules for team damage/self damage/etc...</span><br><span class="line">    float DamageInteractionAllowedMultiplier = 0.0f;</span><br><span class="line">    if (HitActor)</span><br><span class="line">    &#123;</span><br><span class="line">        ULyraTeamSubsystem* TeamSubsystem = HitActor-&gt;GetWorld()-&gt;GetSubsystem&lt;ULyraTeamSubsystem&gt;();</span><br><span class="line">        if (ensure(TeamSubsystem))</span><br><span class="line">        &#123;</span><br><span class="line">            DamageInteractionAllowedMultiplier = TeamSubsystem-&gt;CanCauseDamage(EffectCauser, HitActor) ? 1.0 : 0.0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Determine distance</span><br><span class="line">    double Distance = WORLD_MAX;</span><br><span class="line"></span><br><span class="line">    if (TypedContext-&gt;HasOrigin())</span><br><span class="line">    &#123;</span><br><span class="line">        Distance = FVector::Dist(TypedContext-&gt;GetOrigin(), ImpactLocation);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (EffectCauser)</span><br><span class="line">    &#123;</span><br><span class="line">        Distance = FVector::Dist(EffectCauser-&gt;GetActorLocation(), ImpactLocation);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        UE_LOG(LogLyraAbilitySystem, Error, TEXT(&quot;Damage Calculation cannot deduce a source location for damage coming from %s; Falling back to WORLD_MAX dist!&quot;), *GetPathNameSafe(Spec.Def));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Apply ability source modifiers</span><br><span class="line">    float PhysicalMaterialAttenuation = 1.0f;</span><br><span class="line">    float DistanceAttenuation = 1.0f;</span><br><span class="line">    if (const ILyraAbilitySourceInterface* AbilitySource = TypedContext-&gt;GetAbilitySource())</span><br><span class="line">    &#123;</span><br><span class="line">        if (const UPhysicalMaterial* PhysMat = TypedContext-&gt;GetPhysicalMaterial())</span><br><span class="line">        &#123;</span><br><span class="line">            PhysicalMaterialAttenuation = AbilitySource-&gt;GetPhysicalMaterialAttenuation(PhysMat, SourceTags, TargetTags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DistanceAttenuation = AbilitySource-&gt;GetDistanceAttenuation(Distance, SourceTags, TargetTags);</span><br><span class="line">    &#125;</span><br><span class="line">    DistanceAttenuation = FMath::Max(DistanceAttenuation, 0.0f);</span><br><span class="line"></span><br><span class="line">    // Clamping is done when damage is converted to -health</span><br><span class="line">    const float DamageDone = FMath::Max(BaseDamage * DistanceAttenuation * PhysicalMaterialAttenuation * DamageInteractionAllowedMultiplier, 0.0f);</span><br><span class="line"></span><br><span class="line">    //[关键逻辑]处理实际的伤害值 - 通过添加Modifier的方式实现伤害计算</span><br><span class="line">    if (DamageDone &gt; 0.0f)</span><br><span class="line">    &#123;</span><br><span class="line">        // Apply a damage modifier, this gets turned into - health on the target</span><br><span class="line">        OutExecutionOutput.AddOutputModifier(FGameplayModifierEvaluatedData(ULyraHealthSet::GetDamageAttribute(), EGameplayModOp::Additive, DamageDone));</span><br><span class="line">    &#125;</span><br><span class="line">#endif // #if WITH_SERVER_CODE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>实际上，伤害也可以直接通过GE的Modifiers来直接处理。<br>Execution提供了自定义的伤害计算方式，基于捕获的属性来计算伤害，以及自定义需求。如Lyra中的距离计算、爆头等等。<br>Lyra中的伤害： ULyraHealthSet - Damage,使用了宏来禁止直接在GE中使用Modifier修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Incoming damage. This is mapped directly to -Health</span><br><span class="line">UPROPERTY(BlueprintReadOnly, Category=&quot;Lyra|Health&quot;, Meta=(HideFromModifiers, AllowPrivateAccess=true))</span><br><span class="line">FGameplayAttributeData Damage;</span><br></pre></td></tr></table></figure>
<p>并自定义了伤害计算函数ULyraDamageExecution，捕获[Source]玩家的基础伤害值来做。</p>
<p>考虑到如果不需要做额外值处理，应该是可以直接从ASC拿属性去处理的。这里自己编写了不使用Capture方式来处理属性的计算：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//前面代码略</span><br><span class="line"></span><br><span class="line">float BaseDamage = 0.0f;</span><br><span class="line">//ExecutionParams.AttemptCalculateCapturedAttributeMagnitude(DamageStatics().BaseDamageDef, EvaluateParameters, BaseDamage);</span><br><span class="line">ULyraAbilitySystemComponent*sourceASC = Cast&lt;ULyraAbilitySystemComponent&gt;(Spec.GetEffectContext().GetOriginalInstigatorAbilitySystemComponent());</span><br><span class="line">if (sourceASC)</span><br><span class="line">&#123;</span><br><span class="line">    bool found = false;</span><br><span class="line">    BaseDamage = sourceASC-&gt;GetGameplayAttributeValue(ULyraCombatSet::GetBaseDamageAttribute(),found);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//后面代码略</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>GAS</tag>
        <tag>Lyra</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Theme</title>
    <url>/2025/03/03/HexoTheme/</url>
    <content><![CDATA[<h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><h2 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h2><p><a href="https://github.com/MaLuns/hexo-theme-async">GitHub</a>  </p>
<p><a href="https://hexo-theme-async.imalun.com/guide/">Introduction</a>  </p>
<h2 id="Butterfly"><a href="#Butterfly" class="headerlink" title="Butterfly"></a>Butterfly</h2><p><a href="https://butterfly.js.org/">Introduction</a>  </p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>UE5.5-GAS-ReadMe</title>
    <url>/2025/03/04/UE55GAS/</url>
    <content><![CDATA[<!-- - <meting-js id="13344900252" server="netease" type="playlist" type="playlist" mutex="true" preload="auto" theme="var(--anzhiyu-main)" order="list"></meting-js>   -->

<h3 id="GAS"><a href="#GAS" class="headerlink" title="GAS"></a>GAS</h3><h1 id="Purpose-of-this-Documentation"><a href="#Purpose-of-this-Documentation" class="headerlink" title="Purpose of this Documentation"></a>Purpose of this Documentation</h1><p>This documentation is meant to support and enhance the <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/gameplay-ability-system-for-unreal-engine">official Gameplay Ability System Unreal Developer Community documentation</a>.  In particular, this document lives in the code repository under <a href="./">Gameplay Ability System plug-in folder</a> and thus any user reading this documentation can submit a pull request to clarify functionality, update inaccurate information, or work with the community to flesh out areas that are missing.</p>
<p>It is worth noting there are extensive resources that the wider end-user developer community has written.  One such source of knowledge is the <a href="https://github.com/tranek/GASDocumentation">tranek GAS documentation</a> which is highly detailed and an excellent resource for implementation details, but risks falling out of date with new feature additions or changes.</p>
<h1 id="Overview-of-the-Gameplay-Ability-System"><a href="#Overview-of-the-Gameplay-Ability-System" class="headerlink" title="Overview of the Gameplay Ability System"></a>Overview of the Gameplay Ability System</h1><p>The Gameplay Ability System is a framework for building abilities and interactions that Actors can own and trigger. This system is designed mainly for RPGs, action-adventure games, MOBAs, and other types of games where characters have abilities that need to coordinate mechanics, visual effects, animations, sounds, and data-driven elements, although it can be adapted to a wide variety of projects. The Gameplay Ability System also supports replication for multiplayer games, and can save developers a lot of time scaling up their designs to support multiplayer.</p>
<p>The concepts that the Gameplay Ability System uses are:</p>
<ul>
<li><a href="#gameplay-attributes">Gameplay Attributes</a>:  An enhancement to float properties that allow them to be temporarily modified (buffed) and used in complex calculations such as damage.</li>
<li><a href="#gameplay-tags">Gameplay Tags</a>:  A hierarchical naming system that allows you to specify states of Actors, and properties of Assets.  A powerful query system allows designers to craft logic statements around these.</li>
<li><a href="#gameplay-cues">Gameplay Cues</a>:  A visual and audio effects system based on Gameplay Tags which allow decoupling of the FX and the implementation.</li>
<li><a href="#gameplay-abilities">Gameplay Abilities</a>:  The code that actually triggers when an action is performed.  Typically a Blueprint graph.</li>
<li><a href="#gameplay-effects">Gameplay Effects</a>:  Predefined rulesets about how to apply all of the above.</li>
</ul>
<p>One of the designers’ often mentioned goals of the Gameplay Ability System is to maintain a record of who triggered a complex set of interactions, so that we can keep proper account of which Actor did what.  For instance, if a Player activates a <a href="#gameplay-abilities">Gameplay Ability</a> that spawns a poison cloud (possibly represented with a <a href="#gameplay-cue">Gameplay Cue</a>) that then does damage-over-time using a <a href="#gameplay-effects">Gameplay Effect</a> which eventually reduces an Actor’s Health <a href="#gameplay-attributes">Gameplay Attribute</a> to zero, we should be able to award the kill to the initiating Player.</p>
<p>It is worth mentioning the damage system upfront, as it’s a pervasive example throughout the documentation.  You may be familiar with the <a href="https://www.unrealengine.com/blog/damage-in-ue4">AActor::TakeDamage function</a> which was used for many years.  At Epic, we no longer use that system internally; instead all damage is done through the Gameplay Ability System.  By using the Gameplay Ability System, we allow buffs&#x2F;debuffs and an extensive and ever-changing list of damage types based on Gameplay Tags.  You can look at <a href="https://dev.epicgames.com/documentation/unreal-engine/lyra-sample-game-in-unreal-engine">Lyra</a> as an example that uses the Gameplay Ability System extensively, as well as a rudimentary damage system.</p>
<hr>
<h1 id="Ability-System-Component-asc"><a href="#Ability-System-Component-asc" class="headerlink" title="Ability System Component asc}"></a>Ability System Component {#asc}</h1><p>The Ability System Component (commonly abbreviated ASC) is the top-level ActorComponent that you use to interface with the Gameplay Ability System (commonly abbreviated GAS).  It is a monolithic class that encapsulates almost all of the functionality GAS uses.  By funneling all of the functionality through the ASC, we are able to better encapsulate and enforce the rules about activation, replication, prediction, and side-effects.</p>
<p>While the Ability System Component <em>is</em> an ActorComponent, we typically recommend against putting it on a Player’s Pawn.  Instead, for a Player, it should be on the PlayerState.  The reason for this is that the Pawn is typically destroyed upon death in multiplayer games, and GAS typically has functionality (be it <a href="#gameplay-attributes">Gameplay Attributes</a>, <a href="#gameplay-tags">Gameplay Tags</a>, or <a href="#gameplay-abilities">Gameplay Abilities</a>) that should persist beyond death.  For non-player AI-driven characters (e.g. AI that are not bots), it is suitable to put the ASC on the Pawn because it needs to replicate data to <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/actor-role-and-remote-role-in-unreal-engine#actorrolestates">Simulated Proxies</a>.</p>
<hr>
<h1 id="Gameplay-Attributes-gameplay-attributes"><a href="#Gameplay-Attributes-gameplay-attributes" class="headerlink" title="Gameplay Attributes gameplay-attributes}"></a>Gameplay Attributes {#gameplay-attributes}</h1><p>Gameplay Attributes (often just referred to as simply <em>Attributes</em>) are essentially <em>float</em> properties that are wrapped in a FGameplayAttributeData instance.  The reason for doing so is to allow for a <em>BaseValue</em> which one can think of as an unaltered intrinsic value of the Actor, and a <em>CurrentValue</em> which one can think of as the value that currently applies, after all of the buffs and debuffs of the Actor are taken into account.  These <em>Attributes</em> must live in an <a href="#attribute-sets">AttributeSet</a>.  There is Editor tooling around the use of <em>Attributes</em> that allow them to be selected and used inside <a href="#gameplay-effects">Gameplay Effects</a> (and others) to ensure buffs and debuffs work correctly.</p>
<p>Attributes are often replicated, thus keeping the client in sync with the server values, but that does not <em>always</em> need to be the case.  For instance, certain <em>meta-Attributes</em> can be used to store temporary data used for calculations, allowing these intermediate results to have full buff&#x2F;debuff aggregation capabilities; these <em>meta-Attributes</em> are not replicated because they are typically reset after a calculation.</p>
<p>Since Gameplay Attributes are easily accessible through native or Blueprint code, it’s tempting to modify them directly.  However, the Gameplay Ability System is designed such that all modifications to the Attributes should be done through <a href="#gameplay-effects">Gameplay Effects</a> to ensure they can be network predicted and rolled-back gracefully.</p>
<p><a href="https://dev.epicgames.com/documentation/unreal-engine/gameplay-attributes-and-attribute-sets-for-the-gameplay-ability-system-in-unreal-engine">Developer Community Gameplay Attribute &amp; AttributeSet Docs</a></p>
<h2 id="AttributeSets-attribute-sets"><a href="#AttributeSets-attribute-sets" class="headerlink" title="AttributeSets attribute-sets}"></a>AttributeSets {#attribute-sets}</h2><p>AttributeSets are simply classes derived from <a href="./Source/GameplayAbilities/Public/AttributeSet.h">UAttributeSet class</a>.  The AttributeSets typically contain multiple Gameplay Attributes that encompass all properties for a specific game feature (such as a jetpack item, but the most commonly cited example is the damage system).  AttributeSets must be added to the <a href="#asc">Ability System Component</a> by the server.  AttributeSets are typically replicated to the client, but not all Attributes are replicated to the client (they are configured on a per-Attribute basis).</p>
<h2 id="Attribute-Modifiers-attribute-modifiers"><a href="#Attribute-Modifiers-attribute-modifiers" class="headerlink" title="Attribute Modifiers attribute-modifiers}"></a>Attribute Modifiers {#attribute-modifiers}</h2><p>Attribute Modifiers are how we buff and debuff Attributes.  These are setup through the <a href="#gameplay-effects">Gameplay Effects’</a> <code>Modifiers</code> property.  Once a modifier is ‘active’, it is stored in the <a href="#asc">Ability System Component</a> and all requests for the value go through a process called <em>aggregation</em>.</p>
<p>The rules for <em>aggregation</em> can be unexpected to a new user.  For instance, if there are multiple values that modify a single attribute, the modifiers are added together before the result is computed.  Let’s take an example of a multiplier of 10% added to damage, and another multiplier of 30% added to damage.  If one were purely looking at the numbers, one could think <code>Damage * 1.1 * 1.3 = 1.43</code> thus damage would be modified by <em>43%</em>.  However, the system takes these modifier operators into account and adds them separately before performing the final multiplier calculation, giving an expected result of <code>10% + 30% = 40%</code>.</p>
<hr>
<h1 id="Gameplay-Abilities-gameplay-abilities"><a href="#Gameplay-Abilities-gameplay-abilities" class="headerlink" title="Gameplay Abilities gameplay-abilities}"></a>Gameplay Abilities {#gameplay-abilities}</h1><p>Gameplay Abilities are derived from the <a href="./Source/GameplayAbilities/Public/GameplayAbility.h">UGameplayAbility class</a>.  They define what an in-game ability does, what (if anything) it costs to use, when or under what conditions it can be used, and so on.  Because Gameplay Abilities are implemented in native or Blueprints, it can do anything a Blueprint graph can do.  Unlike traditional Blueprints, they are capable of existing as instanced objects running asynchronously – so you can run specialized, multi-stage tasks (called <a href="#gameplay-ability-tasks">Gameplay Ability Tasks</a>.  Examples of Gameplay Abilities would be a character dash, or an attack.</p>
<p>Think of a Gameplay Ability as the bundle of functions that correspond to the action you’re performing.  There are complex rules about who can activate them, how they activate, and how they are predicted (locally executed ahead of the server acknowledgement).  You trigger them through the Ability System Component (typically through a TryActivate function).  But they can also be triggered through complex interactions (if desired) such as through Gameplay Events, <a href="#gameplay-tags">Gameplay Tags</a>, <a href="#gameplay-effects">Gameplay Effects</a>, and Input (which the <a href="#asc">ASC</a> handles internally).</p>
<p><a href="https://dev.epicgames.com/documentation/unreal-engine/using-gameplay-abilities-in-unreal-engine">Developer Community Gameplay Abilities docs</a></p>
<h2 id="Gameplay-Ability-Tasks-gameplay-ability-tasks"><a href="#Gameplay-Ability-Tasks-gameplay-ability-tasks" class="headerlink" title="Gameplay Ability Tasks gameplay-ability-tasks}"></a>Gameplay Ability Tasks {#gameplay-ability-tasks}</h2><p>Gameplay Abilities often make use of <a href="https://dev.epicgames.com/documentation/unreal-engine/gameplay-ability-tasks-in-unreal-engine">Gameplay Ability Tasks</a>.  Gameplay Ability Tasks are latent Blueprint nodes that allow your Gameplay Ability to ‘pause’ for the frame while it awaits some event.  They can also perform network functionality which hide complex implementation details from the Blueprint designer.</p>
<h2 id="Gameplay-Ability-Specs"><a href="#Gameplay-Ability-Specs" class="headerlink" title="Gameplay Ability Specs"></a>Gameplay Ability Specs</h2><p>The Gameplay Ability Specs are runtime-defined data which augment and tie together parameters used for the Gameplay Ability.  It serves two purposes:</p>
<ol>
<li>To configure the Gameplay Ability parameters prior to giving&#x2F;granting the ability.  For instance, it defines what ‘Level’ of the ability you are granting.</li>
<li>To store information about the granted Gameplay Ability that is shared between all instances of the Gameplay Ability.</li>
</ol>
<p>A lot of the <a href="#asc">Ability System Component</a>‘s interface deals with Gameplay Ability Specs, or after being granted, typically a Gameplay Ability Spec Handle.  The Handles are a way to succinctly refer to a Gameplay Ability Spec in both native and Blueprint code without worrying about the dangers of holding onto a pointer (and having that pointer be reallocated).  Whenever you want to refer to an already-granted Ability, use an Ability Spec Handle instead.</p>
<p>The corresponding class for <a href="./Source/GameplayAbilities/Public/GameplayAbilitySpec.h">FGameplayAbilitySpec</a> and <a href="./Source/GameplayAbilities/Public/GameplayAbilitySpecHandle.h">FGameplayAbilitySpecHandle</a>.</p>
<h2 id="Gameplay-Ability-Instancing-Policy"><a href="#Gameplay-Ability-Instancing-Policy" class="headerlink" title="Gameplay Ability Instancing Policy"></a>Gameplay Ability Instancing Policy</h2><p>The instancing policy determines when a Gameplay Ability is instanced (the Gameplay Ability object is created) and thus controls the lifetime of the GA.  The safest, and most feature-supported choice is InstancedPerActor.</p>
<h3 id="InstancedPerActor"><a href="#InstancedPerActor" class="headerlink" title="InstancedPerActor"></a>InstancedPerActor</h3><p>When choosing InstancedPerActor, the Gameplay Ability will be instanced when its corresponding Gameplay Ability Spec is first given (granted) to the Actor.  The instance lives until the Gameplay Ability Spec is removed from the Actor.  This lifetime mimics what most users expect:  You are granted an ability and immediately have an instance of it.</p>
<p>The lifetime semantics come with some pitfalls you should be aware of:</p>
<ul>
<li>Since the ability continues to exist after it has ended, none of the variables will be reset for next activation.  Thus it’s the user’s responsibility to reset the variables to the defaults in EndAbility.</li>
<li>Prior to UE5.5, you could receive function calls such as OnGiveAbility&#x2F;OnRemoveAbility on the <em>instance</em> immediately, before the ability had ever been activated.  This isn’t true of the other instancing types, which execute said functions on the CDO.  UE5.5 deprecates such functions in favor of explicit execution on the CDO.</li>
<li>There is a function you may see often called GetPrimaryInstance.  The Primary Instance refers to the InstancedPerActor’s one-and-only instance; it does not apply to other instancing types.</li>
</ul>
<h3 id="InstancedPerExecution"><a href="#InstancedPerExecution" class="headerlink" title="InstancedPerExecution"></a>InstancedPerExecution</h3><p>When choosing InstancedPerExecution, you receive a new instance of the Gameplay Ability for each and every activation.  Some things you should be aware of:</p>
<ul>
<li>The instancing happens on activation (not prior to it).  It is possible to Grant &amp; Revoke an InstancedPerExecution ability without ever instancing it.</li>
<li>Replicated Gameplay Abilities (GA’s which contain RPC’s or Replicated Variables) are relatively expensive, as a new GA must be sent for every activation.</li>
<li>Unlike InstancedPerActor, an individual instance is always active (otherwise it would have not been created).  It is garbage collected immediately upon ending.</li>
</ul>
<h3 id="NonInstanced-Deprecated"><a href="#NonInstanced-Deprecated" class="headerlink" title="NonInstanced (Deprecated)"></a>NonInstanced (Deprecated)</h3><p>Prior to UE5.5, we had functionality for Non-Instanced Gameplay Abilities.  Since these Gameplay Abilities were never instanced, they could not be replicated or even hold state (e.g. contain variables).  All functions were called on the ClassDefaultObject and thus all state had to be held on the Gameplay Ability Spec.  This made them very confusing to use.  The same functionality can be achieved by simply using InstancedPerActor and never revoking it; the cost is just a single allocation (instance) of a UGameplayAbility.</p>
<h2 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h2><p>There is a replication policy variable on the Gameplay Abilities.  The setting controls whether or not you are able to use Remote Procedure Calls (RPC’s) or Replicated Variables (now deprecated, see below).  It does <em>not</em> control if a Gameplay Ability will activate both on Server &amp; Client – that is controlled via the Execution Policy.</p>
<p>Keep in mind that Gameplay Abilities exist only on the locally controlled actors and on the server.  As such, you cannot replicate data meant to be visible on Simulated Proxies using Gameplay Abilities.  You would have to use other mechanisms, such as Attributes for replicated variables, or use RPC’s directly on the Actors.</p>
<h3 id="Replicated-Variables-in-Gameplay-Abilities"><a href="#Replicated-Variables-in-Gameplay-Abilities" class="headerlink" title="Replicated Variables in Gameplay Abilities"></a>Replicated Variables in Gameplay Abilities</h3><p>The usage of replicated variables is deprecated as of UE5.5.  The deprecation warning is controlled by a Console Variable “AbilitySystem.DeprecateReplicatedProperties”, so that users can turn off the warning and continue using the feature until they are ready to fix the issue.</p>
<p>The reasoning is to prevent users from stumbling upon an impossible-to-solve bug regarding replication ordering:</p>
<ul>
<li>Replicated variables are guaranteed to be delivered, but not in any particular order with respect to each other or RPC functions.</li>
<li>Gameplay Ability activation (and most synchronizing functions such as Target Data) rely on RPC’s exchanged between the Client and Server.</li>
<li>Therefore, when executing an RPC (e.g. Gameplay Ability Activation) and performing operations on a replicated variable, you would never be guaranteed to have an up-to-date or stale value.</li>
</ul>
<p>For more information, see the <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/replicated-object-execution-order-in-unreal-engine">EDC article on object replication order</a>.</p>
<p>If you believe you need a replicated variable, the solution is to instead use a Reliable RPC to send that data over.  Using a Reliable RPC will ensure proper ordering with the underlying synchronization mechanisms of GAS.</p>
<h3 id="Remote-Procedure-Calls-in-Gameplay-Abilities"><a href="#Remote-Procedure-Calls-in-Gameplay-Abilities" class="headerlink" title="Remote Procedure Calls in Gameplay Abilities"></a>Remote Procedure Calls in Gameplay Abilities</h3><p>Remote Procedure Calls (RPC’s) are the preferred method of communicating data between the client&#x2F;server.  By making a Reliable RPC, you can ensure proper ordering with the other Gameplay Ability functions that support replication such as Activation.  There is currently no restriction against Unreliable RPC’s, but know that order or delivery is not guaranteed.</p>
<p>Using a Multicast RPC will produce a validation warning (typically visible when compiling the Blueprint).  Since Gameplay Abilities never exist on Simulated Proxies, Multicast RPC’s make little sense in the context of a Gameplay Ability.</p>
<h3 id="RPC-Batching-to-Ensure-Proper-Activation-and-ReplicatedTargetData-Order"><a href="#RPC-Batching-to-Ensure-Proper-Activation-and-ReplicatedTargetData-Order" class="headerlink" title="RPC Batching to Ensure Proper Activation and ReplicatedTargetData Order"></a>RPC Batching to Ensure Proper Activation and ReplicatedTargetData Order</h3><p>There is a trick Epic uses internally to bundle the Gameplay Ability activation and Replicated Target Data.  Normally, if one were to implement a Locally Predicted Gameplay Ability that calls Activate() which in turn sets Replicated Target Data, the two would arrive at the Server in separate RPC’s:</p>
<ol>
<li>ServerTryActivateAbility (which will in turn call Activate)</li>
<li>ServerSetReplicatedTargetData (which will then set the data to the desired value – but Activate has already run!)</li>
</ol>
<p>There is a structure called <a href="./Source/GameplayAbilities/Public/GameplayAbilityTypes.h">FScopedServerAbilityRPCBatcher</a> which is designed to use a single RPC to send both Activation and Target Data.  To use it, do the following:</p>
<ol>
<li>In your <code>UAbilitySystemComponent</code>-derived class, override <code>ShouldDoServerAbilityRPCBatch</code> to return true.</li>
<li>In native code, Create an FScopedServerAbilityRPCBatcher on the stack.</li>
<li>Activate your Ability through your desired function (e.g. TryActivateAbility).</li>
<li>During the initial Activation of your ability, perform any CallServerSetReplicatedTargetData call.</li>
<li>When the destructor of the FScopedServerAbilityRPCBatcher executes (by going out of scope), it will call a batched RPC that contains both the Activation and the ReplicatedTargetData.</li>
</ol>
<p>By using this structure, you will be guaranteed that the Server has the desired RPC data prior to calling the Gameplay Ability’s activation function.</p>
<hr>
<h1 id="Gameplay-Effects-gameplay-effects"><a href="#Gameplay-Effects-gameplay-effects" class="headerlink" title="Gameplay Effects gameplay-effects}"></a>Gameplay Effects {#gameplay-effects}</h1><p>The purpose of Gameplay Effects is to modify an Actor in a predictable (and undoable) way.  Think of the verb Affect when you think of Gameplay Effects.  These are not Visual Effects or Sound Effects (those are called Gameplay Cues).  The Gameplay Effects are <em>applied</em> using <a href="#gameplay-effect-specs">Gameplay Effect Specs</a> through the Ability System Component.</p>
<ul>
<li>Gameplay Effects that have a Duration (non-Instant) will automatically undo any modifications to the Actor upon removal. Instant ones will modify the Attribute’s <em>BaseValue</em>.</li>
<li>These are typically data-only Blueprints, though native implementations are also supported.</li>
<li>They should be static after compile time; there is no way to modify them during runtime (Gameplay Effect Specs are the runtime version).</li>
<li>They are essentially a complex datatable of things that should occur to a Target Actor when ‘applied’.</li>
<li>Composed from these pieces:<ul>
<li>Duration &#x2F; Timing data (such as how long the Effect lasts for, or how it periodically executes).</li>
<li>Rules for Stacking the Gameplay Effects.</li>
<li>Attribute Modifiers (data that controls how a Gameplay Attribute is modified and thus can be undone).</li>
<li>Custom Executions (a user definable function that executes every time a Gameplay Effect is applied).</li>
<li>Gameplay Effect Components (fragments of code &#x2F; behavior to execute when applied).</li>
<li>Rules for applying Gameplay Cues (the VisualFX and AudioFX).</li>
</ul>
</li>
</ul>
<h2 id="Gameplay-Effect-Components-gameplay-effect-components"><a href="#Gameplay-Effect-Components-gameplay-effect-components" class="headerlink" title="Gameplay Effect Components gameplay-effect-components}"></a>Gameplay Effect Components {#gameplay-effect-components}</h2><p>Gameplay Effect Components are introduced in UE5.3 to declutter the Gameplay Effect user interface and allow users of the Engine to provide their own game-specific functionality to Gameplay Effects.  </p>
<p>Read the interface for <a href="./Source/GameplayAbilities/Public/GameplayEffectComponent.h">UGameplayEffectComponent</a></p>
<h2 id="Gameplay-Effect-Specs-gameplay-effect-specs"><a href="#Gameplay-Effect-Specs-gameplay-effect-specs" class="headerlink" title="Gameplay Effect Specs gameplay-effect-specs}"></a>Gameplay Effect Specs {#gameplay-effect-specs}</h2><p>These are the runtime wrapper structs for a Gameplay Effect.  They define the Gameplay Effect, any dynamic parameters (such as SetByCaller data), and the tags as they existed when the Spec was created.  The majority of the runtime API’s use a <em>GameplayEffectSpec</em> rather than a <em>GameplayEffect</em>.</p>
<h2 id="Gameplay-Effect-Executions-gameplay-effect-executions"><a href="#Gameplay-Effect-Executions-gameplay-effect-executions" class="headerlink" title="Gameplay Effect Executions gameplay-effect-executions}"></a>Gameplay Effect Executions {#gameplay-effect-executions}</h2><p>Gameplay Effect Executions are game-specific, user-written functions that are configured to execute when particular Gameplay Effects execute.  They typically read from and write to <a href="#gameplay-attributes">Gameplay Attributes</a>.  These are used when the calculations are much more complex than can be achieved with a simple attribute modifier.  Examples of this would be a damage system (see the <a href="https://dev.epicgames.com/documentation/unreal-engine/lyra-sample-game-in-unreal-engine">Lyra Example</a>).</p>
<hr>
<h1 id="Gameplay-Tags-gameplay-tags"><a href="#Gameplay-Tags-gameplay-tags" class="headerlink" title="Gameplay Tags gameplay-tags}"></a>Gameplay Tags {#gameplay-tags}</h1><p>The Gameplay Ability System uses Gameplay Tags extensively throughout.  See the <a href="https://dev.epicgames.com/documentation/unreal-engine/using-gameplay-tags-in-unreal-engine">official Developer Community documentation</a> for more details.</p>
<hr>
<h1 id="Gameplay-Cues-gameplay-cues"><a href="#Gameplay-Cues-gameplay-cues" class="headerlink" title="Gameplay Cues gameplay-cues}"></a>Gameplay Cues {#gameplay-cues}</h1><p>Gameplay Cues are a system for decoupling visual and audio fx from gameplay code.  On start-up, special Gameplay Cue asset folders are scanned for <a href="./Source/GameplayAbilities/Public/GameplayCueSet.h">Gameplay Cue Sets</a>, and <em>Gameplay Cue Notify</em> classes.</p>
<p>The implementer of a gameplay feature will either call the <a href="#asc">Ability System Component</a>‘s GameplayCue functions, or the <a href="./Source/GameplayAbilities/Public/GameplayCueManager.h">GameplayCueManager</a>‘s Gameplay Cue functions with a specific <a href="#gameplay-tag">Gameplay Tag</a>.  The effects artist will then create a <em>Gameplay Cue Notify</em> that corresponds to that tag.  The Gameplay Cue Manager is responsible for routing that specific tag to the proper <em>Gameplay Cue Notify</em>.</p>
<h2 id="Gameplay-Cue-replication"><a href="#Gameplay-Cue-replication" class="headerlink" title="Gameplay Cue replication"></a>Gameplay Cue replication</h2><p>The details of Gameplay Cue replication are complex and worth noting.  Because these are cosmetic-only, there are unreliable RPC’s that are used to communicate the execution of short-lived “<em>Burst</em>“ cues.  We also use variable replication to synchronize the existance of longer cues (typically referred to as <em>Looping</em> or <em>Actor Notfies</em>).  This two-tiered approach ensures that Gameplay Cues can be dropped as unimportant, but also ensures important cues can be visible to any clients that <em>become relevant</em> according to the network system.</p>
<p>Due to these Gameplay Cues needing to obey network relevancy (i.e. far away players should not replicate their Cues, but newly relevant ones should) and the fact that the PlayerState is <em>always relevant</em>, there is a <em>replication proxy</em> system.  The Player’s Pawn (who has its <a href="#asc">ASC</a> on the PlayerState) should implement the <a href="./Source/GameplayAbilities/Public/AbilitySystemReplicationProxyInterface.h">IAbilitySystemReplicationProxyInterface</a>.  When turning on the ASC’s ReplicationProxyEnabled variable, all unreliable Gameplay Cue RPC’s will go through the proxy interface (the Pawn, which properly represents relevancy).</p>
<p>An advanced form of replication proxies also exists for the property replication so it may follow the same relevancy rules.  See <code>FMinimalGameplayCueReplicationProxy</code> in the <a href="./Source/GameplayAbilities/Public/GameplayCueInterface.h">GameplayCueInterface</a>.</p>
<p>Due to the Burst Cues being replicated by RPC and the Looping Cues being replicated by replicated variables, one can run into an issue where the unreliable burst RPC gets dropped but the looping events (OnBecomeRelevant&#x2F;OnCeaseRelevant) arrive.  Less obvious, the unreliable OnBurst RPC can arrive but the OnBecomeRelevant&#x2F;OnCeaseRelevant can be dropped if the Cue is removed on the server quick enough to result in no state changes for network serialization.</p>
<p>See the section on <a href="#gc-events">Gameplay Cue Events</a> below for guidelines on how to implement your Gameplay Cue while taking into consideration network replication.</p>
<h2 id="Gameplay-Cue-Events-gc-events"><a href="#Gameplay-Cue-Events-gc-events" class="headerlink" title="Gameplay Cue Events gc-events}"></a>Gameplay Cue Events {#gc-events}</h2><p>When implementing a Gameplay Cue Notify Actor, the (legacy) naming of the functions may be confusing.  In UE5.5 the Blueprint (user-facing) names have changed in order to better represent what each function does.  They are laid out below.</p>
<h3 id="OnExecute"><a href="#OnExecute" class="headerlink" title="OnExecute"></a>OnExecute</h3><p>The execute function is the easiest to reason about:  It happens when you <em>Execute</em> a one-shot Gameplay Cue (aka a Static Notify &#x2F; non-Looping Gameplay Cue).  The code path to Execute a Gameplay Cue (for Static Notifies) is different than the code path to Add a Gameplay Cue (for Looping Gameplay Cues aka Actor Notifies).</p>
<p>Due to the code path for execution being different, the caller of the Gameplay Cue must know that the receiver of the Gameplay Cue is a Static Notify in order for this to execute properly.  The call should route through ExecuteGameplayCue see <a href="./Source/GameplayAbilities/Public/GameplayCueFunctionLibrary.h">GameplayCueFunctionLibrary</a>.</p>
<h3 id="OnBurst-native-OnActive"><a href="#OnBurst-native-OnActive" class="headerlink" title="OnBurst (native: OnActive)"></a>OnBurst (native: OnActive)</h3><p>This event executes only once when a <em>Looping Gameplay Cue</em> first fires.  Due to it being delivered by unreliable RPC, it can be dropped silently by a client.  You can use this to implement cosmetic effects that are only relevant if a client witnessed the Gameplay Cue triggering.</p>
<h3 id="OnBecomeRelevant-native-WhileActive"><a href="#OnBecomeRelevant-native-WhileActive" class="headerlink" title="OnBecomeRelevant (native: WhileActive)"></a>OnBecomeRelevant (native: WhileActive)</h3><p>This event executes when the <em>Looping Gameplay Cue</em> first comes into network relevancy (usually when it’s first added).  For instance, PawnA can have a Gameplay Cue activated, PawnB can join the game and still receive PawnA’s OnBecomeRelevant – but not receive OnBurst.</p>
<p>This is important to understand as OnBecomeRelevant and OnCeaseRelevant are both guaranteed to fire on the same Cue, whereas OnBurst is not guaranteed.</p>
<h3 id="OnCeaseRelevant-native-OnRemove"><a href="#OnCeaseRelevant-native-OnRemove" class="headerlink" title="OnCeaseRelevant (native: OnRemove)"></a>OnCeaseRelevant (native: OnRemove)</h3><p>This event executes when the <em>Looping Gameplay Cue</em> gets removed from network relevancy.  Usually that’s when the server executes the removal of the Cue, but could also be when the client loses relevancy (e.g. by distance) of the viewed Cue.</p>
<p>In UE5.5, a warning is introduced if a Gameplay Cue implements OnBurst and OnCeaseRelevant and not OnBecomeRelevant.  The reasoning is that the opposite of OnCeaseRelevant is OnBecomeRelevant, not OnBurst and it’s likely that the old naming scheme (OnActive&#x2F;OnRemove) was a source of confusion.</p>
<hr>
<h1 id="How-Gameplay-Prediction-Works"><a href="#How-Gameplay-Prediction-Works" class="headerlink" title="How Gameplay Prediction Works"></a>How Gameplay Prediction Works</h1><p>There is documentation for how the Gameplay Prediction mechanisms work at the top of <a href="./Source/GameplayAbilities/Public/GameplayPrediction.h">GameplayPrediction.h</a>.</p>
<hr>
<h1 id="Ability-System-Globals"><a href="#Ability-System-Globals" class="headerlink" title="Ability System Globals"></a>Ability System Globals</h1><p>There is a class called <a href="./Source/GameplayAbilities/Public/AbilitySystemGlobals.h">AbilitySystemGlobals</a> which provide project customization points for how to handle specific base Ability System scenarios.  For example, there a functions you can override to implement derived classes of types used throughout the code (such as <code>AllocGameplayEffectContext</code>).</p>
<p>In UE5.5, a lot of these settings have started migrating to the <a href="./Source/GameplayAbilities/Public/GameplayAbilitiesDeveloperSettings.h">GameplayAbilitiesDeveloperSettings</a> (which can be accessed using the Editor and choose the Project Settings menu item).  The rough division of responsibilities:  If it’s a global setting (like a variable) then it should be configurable through Gameplay Abilities Developer Settings; if it’s functionality (such as allocating project-specific classes) it should be in <a href="./Source/GameplayAbilities/Public/AbilitySystemGlobals.h">AbilitySystemGlobals</a>.</p>
<hr>
<h1 id="Debugging-the-Gameplay-Ability-System"><a href="#Debugging-the-Gameplay-Ability-System" class="headerlink" title="Debugging the Gameplay Ability System"></a>Debugging the Gameplay Ability System</h1><h2 id="Legacy-ShowDebug-Functionality"><a href="#Legacy-ShowDebug-Functionality" class="headerlink" title="Legacy ShowDebug Functionality"></a>Legacy ShowDebug Functionality</h2><p>Prior to UE5.4, the way to debug the Gameplay Ability System was to use the “ShowDebug AbilitySystem” command.  Once there, you can cycle through the categories using the command <code>AbilitySystem.Debug.NextCategory</code> or explicitly choose a category using <code>AbilitySystem.Debug.SetCategory</code>.  This system is no longer maintained and may be deprecated in future versions.  You should instead be looking at the <a href="#gameplay-debugger">Gameplay Debugger</a> functionality.</p>
<h2 id="Gameplay-Debugger-gameplay-debugger"><a href="#Gameplay-Debugger-gameplay-debugger" class="headerlink" title="Gameplay Debugger gameplay-debugger}"></a>Gameplay Debugger {#gameplay-debugger}</h2><p>New in UE5.4, there is enhanced Gameplay Debugger functionality for the Gameplay Ability System.  This functionality is preferred over the ShowDebug system and should be your first line of defense in debugging GAS.  To enable it, open the Gameplay Debugger typically by using <code>shift-apostrophe</code> (<code>shift-&#39;</code>) to select the locally controlled player, or simply the <code>apostrophe</code> (<code>&#39;</code>) key to select the Actor that is closest to your reticule.</p>
<p>The debugger will show you the AbilitySystemComponent’s current state as it pertains to Gameplay Tags, Gameplay Abilities, Gameplay Effects, and Gameplay Attributes.  In a networked game, the color coding helps to differentiate between how the server and client view their state.</p>
<h2 id="Console-Commands"><a href="#Console-Commands" class="headerlink" title="Console Commands"></a>Console Commands</h2><p>There are console commands that help both in developing and debugging GAS.  They are a great way to verify that your assumptions are correct about how abilities and effects should be activated, and coupled with the <a href="#gameplay-debugger">Gameplay Debugger</a>, what your state should be once executed.</p>
<p>All Ability System debug commands are prefixed with <code>AbilitySystem</code>.  The functionality we’re reviewing here exists in the <a href="./Source/GameplayAbilities/Private/AbilitySystemCheatManagerExtension.cpp">AbilitySystemCheatManagerExtension</a>.  The source code also serves as an excellent reference  how to properly trigger the Gameplay Abilities and Gameplay Effects in native code (and what the expected results would be, depending on their configurations).</p>
<p>By implementing these in a Cheat Manager Extension, you are able to properly execute them as a local player, or on the server.  Many of the commands allow such a distinction with the <code>-Server</code> argument (read the command documentation or source code for more information).</p>
<p>One of the gotchas when using these commands is that the assets should be loaded prior to their use.  This is easily done in the Editor by simply right-clicking on the assets you want to use and clicking “Load Assets”.</p>
<p><code>AbilitySystem.Ability.Grant &lt;ClassName/AssetName&gt;</code> Grants an Ability to the Player.  Granting only happens on the Authority, so this command will be sent to the Server.<br><code>AbilitySystem.Ability.Activate [-Server] &lt;TagName/ClassName/AssetName&gt;</code> Activate a Gameplay Ability.  Substring name matching works for Activation Tags (on already granted abilities), Asset Paths (on non-granted abilities), or Class Names on both.  Some Abilities can only be activated by the Client or the Server and you can control all of these activation options by specifying or ommitting the <code>-Server</code> argument.<br><code>AbilitySystem.Ability.Cancel [-Server] &lt;PartialName&gt;</code> Cancels (prematurely Ends) a currently executing Gameplay Ability.  Cancelation can be initiated by either the Client or Server.<br><code>AbilitySystem.Ability.ListGranted</code> List the Gameplay Abilities that are granted to the local player.  Since granting is done on the Server but replicated to the Client, these should always be in sync (so no option for -Server).</p>
<p><code>AbilitySystem.Effect.ListActive [-Server]</code> Lists all of the Gameplay Effects currently active on the Player.<br><code>AbilitySystem.Effect.Remove [-Server] &lt;Handle/Name&gt;</code> Remove a Gameplay Effect that is currently active on the Player.<br><code>AbilitySystem.Effect.Apply [-Server] &lt;Class/Assetname&gt; [Level]</code> Apply a Gameplay Effect on the Player.  Substring name matching works for Asset Tags, Asset Paths, or Class Names.  Use -Server to send to the server (default is apply locally).</p>
<p>Gameplay Cues have their own set of debug commands.</p>
<p><code>AbilitySystem.LogGameplayCueActorSpawning</code> Log when we create GameplayCueNotify_Actors.<br><code>AbilitySystem.DisplayGameplayCues</code> Display GameplayCue events in world as text.<br><code>AbilitySystem.GameplayCue.DisplayDuration</code> Configure the amount of time Gameplay Cues are drawn when <code>DisplayGameplayCues</code> is enabled.<br><code>AbilitySystem.DisableGameplayCues</code> Disables all GameplayCue events in the world.<br><code>AbilitySystem.GameplayCue.RunOnDedicatedServer</code> Run gameplay cue events on dedicated server.<br><code>AbilitySystem.GameplayCueActorRecycle</code> Allow recycling of GameplayCue Actors.<br><code>AbilitySystem.GameplayCueActorRecycleDebug</code> Prints logs for GC actor recycling debugging.<br><code>AbilitySystem.GameplayCueCheckForTooManyRPCs</code> Warns if gameplay cues are being throttled by network code.</p>
<h2 id="Visual-Logger"><a href="#Visual-Logger" class="headerlink" title="Visual Logger"></a>Visual Logger</h2><p>New in UE5.4, there has been extra care put into the <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/visual-logger-in-unreal-engine">Visual Logger</a> facilities for the Gameplay Ability System.  The <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/visual-logger-in-unreal-engine">Visual Logger</a> is useful to see the complex interactions of Gameplay Abilities and Gameplay Effects over time.  The Visual Logger always captures the verbose logs and saves a snapshot of the state of the Ability System Component on every frame there is a log entry.</p>
<p>In UE5.4, the <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/visual-logger-in-unreal-engine">Visual Logger</a> now correctly orders the events between clients and servers when using Play In Editor.  This makes the Visual Logger especially useful for debugging how the client and server interact when activating abilities, gameplay effects, and modifying attributes.</p>
]]></content>
      <categories>
        <category>UE Source</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>GAS</tag>
        <tag>UE Source</tag>
      </tags>
  </entry>
  <entry>
    <title>UE5.5-Lyra-1-Attribute</title>
    <url>/2025/03/16/UE55Lyra1/</url>
    <content><![CDATA[<p>基于官方Lyra的GAS学习。</p>
<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>首先就是ASC的位置。<br>Lyra项目将ASC放置于了LyraPlayerState中。<br>将ASC与PlayerState绑定。</p>
<p>此外 可以看到LyraCharacter。其也有获取ASC的接口。</p>
<p>从LyraCharacter获取ASC组件，依赖于其PawnExtComponent。<br>这里可以看到ULyraPawnExtensionComponent这个类。<br>该类会存放一个ASC指针。在函数InitializeAbilitySystem中进行设置。</p>
<p>LyraHeroComponent是唯一调用该方法的组件。<br>见ULyraHeroComponent::HandleChangeInitState。<br>这里的逻辑也是从PlayerState中拿到ASC，然后赋值给PawnExtComponent。</p>
<p>总而言之，该项目的ASC位于PlayerState。<br>整体的链条大概如下：<br>PlayerState -&gt; LyraHeroComp -&gt; PawnExtComponent -&gt; LyraCharacter。</p>
<p>再整理一下：</p>
<p>LyraCharacter - 包含PawnExtComp<br> ↓ 子类<br>Character_Default<br> ↓ 子类<br>B_Hero_Default - 新增组件 LyraHeroComp</p>
<p>因此 只需要在子类去调用InitializeAbilitySystem来设置PawnExtComp中的ASC指针即可。</p>
<p>实际上，Pawn本身就有GetPlayerState的方法。<br>LyraHeroComp只是调用该方法（转为Lyra的PlayerState）并由LyraPlayerState获取ASC而已。</p>
<p>这部分的一些设置可以看到B_LyraGameMode。</p>
<h1 id="LyraPlayerState"><a href="#LyraPlayerState" class="headerlink" title="LyraPlayerState"></a>LyraPlayerState</h1><p>先看到 PlayerState部分<br>LyraPlayerState - 继承自AModularPlayerState IAbilitySystemInterface ILyraTeamAgentInterface</p>
<h1 id="关于ASC的初始化"><a href="#关于ASC的初始化" class="headerlink" title="关于ASC的初始化"></a>关于ASC的初始化</h1><p>LyraPlayerState，后续简称为 LPS<br>LPS继承自PlayerState，继承自AInfo。构造函数有:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AInfo(const FObjectInitializer&amp; ObjectInitializer = FObjectInitializer::Get());</span><br></pre></td></tr></table></figure>
<p>在LPS中，使用ObjectInitializer来创建ASC:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AbilitySystemComponent = ObjectInitializer.CreateDefaultSubobject&lt;ULyraAbilitySystemComponent&gt;(this, TEXT(&quot;AbilitySystemComponent&quot;));</span><br><span class="line"></span><br><span class="line">//另外一种创建ASC</span><br><span class="line">//直接调用[感兴趣也可以看看底层实现。其实还是拿了FObjectInitializer]</span><br><span class="line">AbilitySystemComponent = CreateDefaultSubobject&lt;ULyraAbilitySystemComponent&gt;(TEXT(&quot;AbilitySystemComponent2&quot;));</span><br></pre></td></tr></table></figure>
<p>之后 设置ASC的复制模式,并创建所需要的AttributeSet</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AbilitySystemComponent-&gt;SetIsReplicated(true);</span><br><span class="line">AbilitySystemComponent-&gt;SetReplicationMode(EGameplayEffectReplicationMode::Mixed);</span><br><span class="line"></span><br><span class="line">// These attribute sets will be detected by AbilitySystemComponent::InitializeComponent. Keeping a reference so that the sets don&#x27;t get garbage collected before that.</span><br><span class="line">HealthSet = CreateDefaultSubobject&lt;ULyraHealthSet&gt;(TEXT(&quot;HealthSet&quot;));</span><br><span class="line">CombatSet = CreateDefaultSubobject&lt;ULyraCombatSet&gt;(TEXT(&quot;CombatSet&quot;));</span><br></pre></td></tr></table></figure>

<h1 id="AttributeSet"><a href="#AttributeSet" class="headerlink" title="AttributeSet"></a>AttributeSet</h1><p>首先 从AttributeSet和ASC都位于LPS上可以看到设计的一致性。<br>接下来看看属性集的设计：</p>
<h2 id="ULyraHealthSet"><a href="#ULyraHealthSet" class="headerlink" title="ULyraHealthSet"></a>ULyraHealthSet</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private:</span><br><span class="line"></span><br><span class="line">	// The current health attribute.  The health will be capped by the max health attribute.  Health is hidden from modifiers so only executions can modify it.</span><br><span class="line">	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_Health, Category = &quot;Lyra|Health&quot;, Meta = (HideFromModifiers, AllowPrivateAccess = true))</span><br><span class="line">	FGameplayAttributeData Health;</span><br><span class="line"></span><br><span class="line">	// The current max health attribute.  Max health is an attribute since gameplay effects can modify it.</span><br><span class="line">	UPROPERTY(BlueprintReadOnly, ReplicatedUsing = OnRep_MaxHealth, Category = &quot;Lyra|Health&quot;, Meta = (AllowPrivateAccess = true))</span><br><span class="line">	FGameplayAttributeData MaxHealth;</span><br><span class="line"></span><br><span class="line">	// Used to track when the health reaches 0.</span><br><span class="line">	bool bOutOfHealth;</span><br><span class="line"></span><br><span class="line">	// Store the health before any changes </span><br><span class="line">	float MaxHealthBeforeAttributeChange;</span><br><span class="line">	float HealthBeforeAttributeChange;</span><br><span class="line"></span><br><span class="line">	// -------------------------------------------------------------------</span><br><span class="line">	//	Meta Attribute (please keep attributes that aren&#x27;t &#x27;stateful&#x27; below </span><br><span class="line">	// -------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">	// Incoming healing. This is mapped directly to +Health</span><br><span class="line">	UPROPERTY(BlueprintReadOnly, Category=&quot;Lyra|Health&quot;, Meta=(AllowPrivateAccess=true))</span><br><span class="line">	FGameplayAttributeData Healing;</span><br><span class="line"></span><br><span class="line">	// Incoming damage. This is mapped directly to -Health</span><br><span class="line">	UPROPERTY(BlueprintReadOnly, Category=&quot;Lyra|Health&quot;, Meta=(HideFromModifiers, AllowPrivateAccess=true))</span><br><span class="line">	FGameplayAttributeData Damage;</span><br></pre></td></tr></table></figure>

<p>可以看到简简单单的一个生命属性集 不但有普通的最大生命值，当前生命值，还有两个额外的数值。Healing与Damage。</p>
<p>在基类LyraAttributeSet中 定义了对应的属性宏用于获取&#x2F;设置属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * This macro defines a set of helper functions for accessing and initializing attributes.</span><br><span class="line"> *</span><br><span class="line"> * The following example of the macro:</span><br><span class="line"> *		ATTRIBUTE_ACCESSORS(ULyraHealthSet, Health)</span><br><span class="line"> * will create the following functions:</span><br><span class="line"> *		static FGameplayAttribute GetHealthAttribute();</span><br><span class="line"> *		float GetHealth() const;</span><br><span class="line"> *		void SetHealth(float NewVal);</span><br><span class="line"> *		void InitHealth(float NewVal);</span><br><span class="line"> */</span><br><span class="line">#define ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \</span><br><span class="line">	GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \</span><br><span class="line">	GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \</span><br><span class="line">	GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \</span><br><span class="line">	GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)</span><br></pre></td></tr></table></figure>
<p>Healing与Damage只是中间处理，并不参与复制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void ULyraHealthSet::GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) const</span><br><span class="line">&#123;</span><br><span class="line">	Super::GetLifetimeReplicatedProps(OutLifetimeProps);</span><br><span class="line"></span><br><span class="line">	DOREPLIFETIME_CONDITION_NOTIFY(ULyraHealthSet, Health, COND_None, REPNOTIFY_Always);</span><br><span class="line">	DOREPLIFETIME_CONDITION_NOTIFY(ULyraHealthSet, MaxHealth, COND_None, REPNOTIFY_Always);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后看到三个属性关键函数：</p>
<ul>
<li>PreAttributeBaseChange &#x2F;&#x2F;before any modification happens to an attribute’s base value</li>
<li>PreAttributeChange &#x2F;&#x2F;before any modification happens to an attribute</li>
<li>PostAttributeChange &#x2F;&#x2F;just after any modification happens to an attribute</li>
</ul>
<p>这三个函数：</p>
<ul>
<li>可以做值的范围限制（Clamp），如限制当前生命值大于0，小于最大生命值。最大生命值最小为1。</li>
<li>可以做值修正。比如最大生命值改变后，限制当前生命值为最大生命值。这里的修正要注意写法。用ApplyModToAttribute。&#x2F;&#x2F;Not invoke Pre&#x2F;PostGameplayEffectExecute calls on the attribute set</li>
</ul>
<p>然后是两个重要的GE函数：</p>
<ul>
<li>PreGameplayEffectExecute &#x2F;&#x2F;just before modifying the value of an attribute</li>
<li>PostGameplayEffectExecute &#x2F;&#x2F;just after a GameplayEffect is executed to modify the base value of an attribute</li>
</ul>
<p>PreGameplayEffectExecute</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool ULyraHealthSet::PreGameplayEffectExecute(FGameplayEffectModCallbackData &amp;Data)</span><br><span class="line">&#123;</span><br><span class="line">	if (!Super::PreGameplayEffectExecute(Data))</span><br><span class="line">	&#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//可以看到这里的是用“伤害”属性来做伤害的</span><br><span class="line">	// Handle modifying incoming normal damage</span><br><span class="line">	if (Data.EvaluatedData.Attribute == GetDamageAttribute())</span><br><span class="line">	&#123;</span><br><span class="line">		if (Data.EvaluatedData.Magnitude &gt; 0.0f)</span><br><span class="line">		&#123;</span><br><span class="line">			//自毁伤害</span><br><span class="line">			const bool bIsDamageFromSelfDestruct = Data.EffectSpec.GetDynamicAssetTags().HasTagExact(TAG_Gameplay_DamageSelfDestruct);</span><br><span class="line"></span><br><span class="line">			//免疫伤害的能力</span><br><span class="line">			if (Data.Target.HasMatchingGameplayTag(TAG_Gameplay_DamageImmunity) &amp;&amp; !bIsDamageFromSelfDestruct)</span><br><span class="line">			&#123;</span><br><span class="line">				// Do not take away any health.</span><br><span class="line">				Data.EvaluatedData.Magnitude = 0.0f;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">#if !UE_BUILD_SHIPPING</span><br><span class="line">			//GM模式 - 不扣血</span><br><span class="line">			// Check GodMode cheat, unlimited health is checked below</span><br><span class="line">			if (Data.Target.HasMatchingGameplayTag(LyraGameplayTags::Cheat_GodMode) &amp;&amp; !bIsDamageFromSelfDestruct)</span><br><span class="line">			&#123;</span><br><span class="line">				// Do not take away any health.</span><br><span class="line">				Data.EvaluatedData.Magnitude = 0.0f;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">#endif // #if !UE_BUILD_SHIPPING</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//改变前记录目前的属性</span><br><span class="line">	// Save the current health</span><br><span class="line">	HealthBeforeAttributeChange = GetHealth();</span><br><span class="line">	MaxHealthBeforeAttributeChange = GetMaxHealth();</span><br><span class="line"></span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PostGameplayEffectExecute</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void ULyraHealthSet::PostGameplayEffectExecute(const FGameplayEffectModCallbackData&amp; Data)</span><br><span class="line">&#123;</span><br><span class="line">	Super::PostGameplayEffectExecute(Data);</span><br><span class="line"></span><br><span class="line">	const bool bIsDamageFromSelfDestruct = Data.EffectSpec.GetDynamicAssetTags().HasTagExact(TAG_Gameplay_DamageSelfDestruct);</span><br><span class="line">	float MinimumHealth = 0.0f;</span><br><span class="line"></span><br><span class="line">#if !UE_BUILD_SHIPPING</span><br><span class="line">	// GM模式下不死</span><br><span class="line">	// Godmode and unlimited health stop death unless it&#x27;s a self destruct</span><br><span class="line">	if (!bIsDamageFromSelfDestruct &amp;&amp;</span><br><span class="line">		(Data.Target.HasMatchingGameplayTag(LyraGameplayTags::Cheat_GodMode) || Data.Target.HasMatchingGameplayTag(LyraGameplayTags::Cheat_UnlimitedHealth) ))</span><br><span class="line">	&#123;</span><br><span class="line">		MinimumHealth = 1.0f;</span><br><span class="line">	&#125;</span><br><span class="line">#endif // #if !UE_BUILD_SHIPPING</span><br><span class="line"></span><br><span class="line">	const FGameplayEffectContextHandle&amp; EffectContext = Data.EffectSpec.GetEffectContext();</span><br><span class="line"></span><br><span class="line">	// “发起人” 链条源 - &quot;return the original instigator that started the whole chain&quot;</span><br><span class="line">	AActor* Instigator = EffectContext.GetOriginalInstigator();</span><br><span class="line"></span><br><span class="line">	// “引起者” - &quot;the physical actor tied to the application of this effect&quot;</span><br><span class="line">	AActor* Causer = EffectContext.GetEffectCauser();</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	*  玩家[Instigator]→技能→子弹[Causer]→敌人伤害</span><br><span class="line">	*/</span><br><span class="line"></span><br><span class="line">	if (Data.EvaluatedData.Attribute == GetDamageAttribute())</span><br><span class="line">	&#123;</span><br><span class="line">		// Send a standardized verb message that other systems can observe</span><br><span class="line">		if (Data.EvaluatedData.Magnitude &gt; 0.0f)</span><br><span class="line">		&#123;</span><br><span class="line">			//伤害事件 </span><br><span class="line">			FLyraVerbMessage Message;</span><br><span class="line">			Message.Verb = TAG_Lyra_Damage_Message;</span><br><span class="line">			Message.Instigator = Data.EffectSpec.GetEffectContext().GetEffectCauser();</span><br><span class="line">			Message.InstigatorTags = *Data.EffectSpec.CapturedSourceTags.GetAggregatedTags();</span><br><span class="line">			Message.Target = GetOwningActor();</span><br><span class="line">			Message.TargetTags = *Data.EffectSpec.CapturedTargetTags.GetAggregatedTags();</span><br><span class="line">			//@TODO: Fill out context tags, and any non-ability-system source/instigator tags</span><br><span class="line">			//@TODO: Determine if it&#x27;s an opposing team kill, self-own, team kill, etc...</span><br><span class="line">			Message.Magnitude = Data.EvaluatedData.Magnitude;</span><br><span class="line"></span><br><span class="line">			UGameplayMessageSubsystem&amp; MessageSystem = UGameplayMessageSubsystem::Get(GetWorld());</span><br><span class="line">			MessageSystem.BroadcastMessage(Message.Verb, Message);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//通过元属性Damage 来造成生命值的减少。</span><br><span class="line"></span><br><span class="line">		// Convert into -Health and then clamp</span><br><span class="line">		SetHealth(FMath::Clamp(GetHealth() - GetDamage(), MinimumHealth, GetMaxHealth()));</span><br><span class="line">		SetDamage(0.0f);</span><br><span class="line">	&#125;</span><br><span class="line">	else if (Data.EvaluatedData.Attribute == GetHealingAttribute())</span><br><span class="line">	&#123;</span><br><span class="line">		//治疗</span><br><span class="line">		// Convert into +Health and then clamp</span><br><span class="line">		SetHealth(FMath::Clamp(GetHealth() + GetHealing(), MinimumHealth, GetMaxHealth()));</span><br><span class="line">		SetHealing(0.0f);</span><br><span class="line">	&#125;</span><br><span class="line">	else if (Data.EvaluatedData.Attribute == GetHealthAttribute())</span><br><span class="line">	&#123;</span><br><span class="line">		// Clamp and fall into out of health handling below</span><br><span class="line">		SetHealth(FMath::Clamp(GetHealth(), MinimumHealth, GetMaxHealth()));</span><br><span class="line">	&#125;</span><br><span class="line">	else if (Data.EvaluatedData.Attribute == GetMaxHealthAttribute())</span><br><span class="line">	&#123;</span><br><span class="line">		// TODO clamp current health?</span><br><span class="line"></span><br><span class="line">		//这里HealthSet里面新增的广播</span><br><span class="line">		// Notify on any requested max health changes</span><br><span class="line">		OnMaxHealthChanged.Broadcast(Instigator, Causer, &amp;Data.EffectSpec, Data.EvaluatedData.Magnitude, MaxHealthBeforeAttributeChange, GetMaxHealth());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// If health has actually changed activate callbacks</span><br><span class="line">	if (GetHealth() != HealthBeforeAttributeChange)</span><br><span class="line">	&#123;</span><br><span class="line">		//这里HealthSet里面新增的广播</span><br><span class="line">		OnHealthChanged.Broadcast(Instigator, Causer, &amp;Data.EffectSpec, Data.EvaluatedData.Magnitude, HealthBeforeAttributeChange, GetHealth());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if ((GetHealth() &lt;= 0.0f) &amp;&amp; !bOutOfHealth)</span><br><span class="line">	&#123;</span><br><span class="line">		//这里HealthSet里面新增的广播</span><br><span class="line">		OnOutOfHealth.Broadcast(Instigator, Causer, &amp;Data.EffectSpec, Data.EvaluatedData.Magnitude, HealthBeforeAttributeChange, GetHealth());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Check health again in case an event above changed it.</span><br><span class="line">	bOutOfHealth = (GetHealth() &lt;= 0.0f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但实际的应用，应该还是要追溯到GE。<br>这部分放到后续来看。</p>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>GAS</tag>
        <tag>Lyra</tag>
      </tags>
  </entry>
  <entry>
    <title>UE Input输入</title>
    <url>/2025/03/15/UE_Input/</url>
    <content><![CDATA[<p><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/enhanced-input-in-unreal-engine#%E8%BE%93%E5%85%A5%E4%BF%AE%E9%A5%B0%E5%99%A8">官方文章Doc</a></p>
<h1 id="基础输入-Actor-Input"><a href="#基础输入-Actor-Input" class="headerlink" title="基础输入 [Actor Input]"></a>基础输入 [Actor Input]</h1><p>Acotr Input<br>响应玩家输入</p>
<p>启用ActorInput</p>
<ul>
<li>将PlayerController与对应的Actor绑定在一起 启用输入</li>
<li>配套的禁用输入 Disable Input</li>
</ul>
<p>使用事件来启用&#x2F;禁用输入</p>
<ul>
<li>CollisionComp的Overlap</li>
</ul>
<p>此外 输入是有优先级以及“消耗”这一说法的。 [见Consume Input]</p>
<h1 id="增强输入-Enhanced-Input"><a href="#增强输入-Enhanced-Input" class="headerlink" title="增强输入 [Enhanced Input]"></a>增强输入 [Enhanced Input]</h1><p>键输入的重新映射</p>
<p>概念：</p>
<ul>
<li>输入动作 Input Actions</li>
<li>输入映射上下文 Input Mapping Context</li>
<li>输入修饰器 Input Modifers</li>
<li>输入触发器 Input Tiggers</li>
</ul>
<h2 id="输入动作"><a href="#输入动作" class="headerlink" title="输入动作"></a>输入动作</h2><p>输入动作在概念上相当于 操作（Action） 和 轴（Axis） 映射名称，但它们是数据资产。</p>
<p>每个输入动作应该表示用户可以执行的某件事，例如”蹲伏”或”发射武器”。</p>
<p>你可以在蓝图或C++中添加 输入侦听器（Input Listeners） ，侦听输入动作的状态何时发生变化。</p>
<p>输入动作可以是多种不同的类型，这些类型将确定行为。</p>
<p>可以创建简单的布尔动作或更复杂的3D轴。动作类型将确定值。布尔动作采用简单的布尔值， Axis1D为浮点值， Axis2D为FVector2D， Axis3D 为整个Fvector。</p>
<p>布尔动作用于状态为开或关的输入。这相当于旧版输入系统中的较旧动作映射。<br>对于游戏手柄控制杆值等控制点，你可以使用2D轴动作来保存控制杆位置的X和Y值。<br>你可以使用3D轴保存更复杂的数据，例如运动控制器信息。</p>
<p>示例 IA_Move</p>
<h3 id="触发状态"><a href="#触发状态" class="headerlink" title="触发状态"></a>触发状态</h3><p>触发状态（Trigger State） 表示动作的当前状态。<br>通常，使用”已触发”状态。你可以绑定到C++和蓝图中的特定状态。</p>
<ul>
<li>已触发（Triggered）： 动作已触发。这意味着它完成了所有触发器要求的求值。例如，”按下并松开”触发器会在用户松开按键时发送。</li>
<li>已开始（Started）： 发生了开始触发器求值的某个事件。例如，”双击”触发器的第一次按键将调用一次”已开始”状态。</li>
<li>进行中（Ongoing）： 触发器仍在进行处理。例如，当用户按下按钮时，在达到指定持续时间之前，”按住”动作处于进行中状态。根据触发器，此事件将在收到输入值之后在对动作求值时，每次更新触发一次。</li>
<li>已完成（Completed）： 触发器求值过程已完成。</li>
<li>已取消（Canceled）： 触发已取消。例如，在”按住”动作还没触发之前，用户就松开了按钮。</li>
</ul>
<h3 id="输入侦听器"><a href="#输入侦听器" class="headerlink" title="输入侦听器"></a>输入侦听器</h3><p>如题所述，用于侦听对应的事件。</p>
<h2 id="输入映射上下文"><a href="#输入映射上下文" class="headerlink" title="输入映射上下文"></a>输入映射上下文</h2><p>主要还是起一个Mapping的作用</p>
<p>输入动作的集合，表示玩家可以处于的特定上下文。它们描述了给定输入动作的触发规则。映射上下文可以动态地为每个用户添加、移除或安排优先次序。<br>Input Action 以及 用户出发InputAction的方式。如键、按钮、动作轴等。</p>
<p>键下有对应的Triggers和Modifers。为各个用户输入的输入触发器和输入修饰器列表，可用于确定如何筛选或处理输入的原始值，以及它必须满足哪些限制才能驱动顶层的输入动作。</p>
<p>通过本地玩家的增强输入本地玩家子系统（Enhanced Input Local Player Subsystem）将一个或多个上下文应用到本地玩家，并安排它们的优先次序，避免多个操作由于尝试使用同一输入而发生冲突。</p>
<p>将实际的键与输入动作[InputAction]绑定，并为每个动作指定额外触发器或修饰器。将输入映射上下文添加到增强输入子系统时，你还可以指定其优先级。如果你有多个上下文映射到同一个输入动作，那么在触发输入动作时，将考虑优先级最高的上下文，而忽略其他上下文。</p>
<p>例如，你可以为一个可以游泳、行走、驾驶载具的角色提供多个输入映射上下文。一个用于通用动作（始终可用且始终映射到相同用户输入），其他分别用于各类移动模式。</p>
<p>开发人员随后可以将与载具相关的输入动作放入单独的输入映射上下文中，这些操作将在本地玩家进入载具时添加到玩家，并在退出载具时从本地玩家中移除。[使用多个输入映射上下文]</p>
<p>这样做有助于确保不合适的输入动作无法运行，从而优化并预防漏洞。此外，使用互斥的输入映射上下文还有助于避免输入冲突，因此当某个用户输入被用于不同的输入动作时，该输入绝不会意外触发错误的操作。</p>
<h2 id="输入修饰器"><a href="#输入修饰器" class="headerlink" title="输入修饰器"></a>输入修饰器</h2><p>InputModifiers<br>预处理器。</p>
<p>增强输入插件随附多种输入修饰器，可以执行各种任务，例如更改轴顺序、实现”死区”、将轴输入转换为世界空间。</p>
<p>很适合用于应用灵敏度设置，在多个帧上平滑输入，或基于玩家状态更改输入的行为。</p>
<p>比如可以实现反向操作的效果。<br>详细见Modify Raw函数。</p>
<h3 id="方向输入"><a href="#方向输入" class="headerlink" title="方向输入"></a>方向输入</h3><p>手柄 - 摇杆<br>键盘 - 由一维(键盘WASD输入)转为二维：</p>
<ul>
<li>默认情况下 单键为一维度 可以认为是X轴，值为0或1.0</li>
<li>使用Swizzle Input Axis Values 将其改为Y轴（适用于W与D键）</li>
<li>使用Negate负值来实现反方向</li>
</ul>
<p>不过这里有一点还是值得思考的：键盘单键输入就是0&#x2F;1.0 和摇杆还不太一样。</p>
<p>按鸣潮的做法，键鼠时，用ctrl来控制慢走&#x2F;快走，而摇杆就可以“轻推”。</p>
<h2 id="输入触发器"><a href="#输入触发器" class="headerlink" title="输入触发器"></a>输入触发器</h2><p>用于确定用户输入在经过一系列可选输入修饰器的处理后，是否会激活输入映射上下文中的相应输入动作。</p>
<p>大部分输入触发器都会分析输入本身，检查最小动作值并验证各种模式。</p>
<p>例如短暂点击、长时间按住或典型的”按下”或”释放”事件。</p>
<p>此规则的一个例外是”同时按键”输入触发器，该触发器仅通过另一个输入动作触发。</p>
<p>默认情况下，任意用户输入活动都会在每次更新时触发一次。</p>
<p>输入触发器有三种类型：</p>
<ul>
<li>显式（Explicit） 类型:将使输入在输入触发器成功时成功。</li>
<li>隐式（Implicit） 类型:将使输入仅在输入触发器和所有其他隐式类型输入触发器都成功时成功。</li>
<li>阻碍（Blocker） 类型：将使输入在输入触发器成功时失败。</li>
</ul>
<p>处理用户输入后，输入触发器可能返回以下三种状态之一：</p>
<ul>
<li>无（None） :表明未满足输入触发器的条件，因此输入触发器失败。</li>
<li>持续（Ongoing） :表明部分满足了输入触发器的条件，并且输入触发器正在处理，但尚未成功。</li>
<li>已触发（Triggered） :表明已满足输入触发器的所有条件，因此输入触发器成功。</li>
</ul>
<p>长按示例:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Input Trigger Timed Base 会检查输入是否已被按住一段时间，如是，则接受该输入并返回 持续（Ongoing） 状态。</span></span><br><span class="line"><span class="comment">插件提供的&quot;Input Trigger Timed Base&quot;类永远不会返回 已触发（Triggered） 状态。你要在新建的输入触发器子类中重载该函数，来确定它如何响应用户输入。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">**UInputTriggerHold.h**</span><br><span class="line"></span><br><span class="line"><span class="comment">/** UInputTriggerHold</span></span><br><span class="line"><span class="comment">    触发器会在输入保持激活状态达到HoldTimeThreshold秒之后触发。</span></span><br><span class="line"><span class="comment">    触发器可以选择触发一次或反复触发。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">UCLASS</span>(NotBlueprintable, MinimalAPI, meta = (DisplayName = <span class="string">&quot;Hold&quot;</span>))</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UInputTriggerHold</span> <span class="keyword">final</span> : <span class="keyword">public</span> UInputTriggerTimedBase</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> bTriggered = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ETriggerState <span class="title">UpdateState_Implementation</span><span class="params">(<span class="type">const</span> UEnhancedPlayerInput* PlayerInput, FInputActionValue ModifiedValue, <span class="type">float</span> DeltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ETriggerEventsSupported <span class="title">GetSupportedTriggerEvents</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> ETriggerEventsSupported::Ongoing; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入要保持多久才能导致触发？</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, Config, BlueprintReadWrite, Category = <span class="string">&quot;Trigger Settings&quot;</span>, meta = (ClampMin = <span class="string">&quot;0&quot;</span>))</span><br><span class="line">    <span class="type">float</span> HoldTimeThreshold = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此触发器应该仅触发一次，还是在满足保持时间阈值之后每帧触发？</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(EditAnywhere, Config, BlueprintReadWrite, Category = <span class="string">&quot;Trigger Settings&quot;</span>)</span><br><span class="line">    <span class="type">bool</span> bIsOneShot = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> FString <span class="title">GetDebugState</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> HeldDuration ? FString::<span class="built_in">Printf</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;Hold:%.2f/%.2f&quot;</span>), HeldDuration, HoldTimeThreshold) : <span class="built_in">FString</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> ~~~</span><br><span class="line">**UInputTriggerHold.<span class="function">cpp**</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">ETriggerState <span class="title">UInputTriggerHold::UpdateState_Implementation</span><span class="params">(<span class="type">const</span> UEnhancedPlayerInput* PlayerInput, FInputActionValue ModifiedValue, <span class="type">float</span> DeltaTime)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// 更新HeldDuration并派生基础状态 </span></span><br><span class="line">    ETriggerState State = Super::<span class="built_in">UpdateState_Implementation</span>(PlayerInput, ModifiedValue, DeltaTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在HeldDuration达到阈值时触发 </span></span><br><span class="line">    <span class="type">bool</span> bIsFirstTrigger = !bTriggered; </span><br><span class="line">    bTriggered = HeldDuration &gt;= HoldTimeThreshold; </span><br><span class="line">    <span class="keyword">if</span> (bTriggered) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">return</span> (bIsFirstTrigger || !bIsOneShot) ? ETriggerState::Triggered : ETriggerState::None; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> State; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="平台设置"><a href="#平台设置" class="headerlink" title="平台设置"></a>平台设置</h2><p>映射上下文重定向（Mapping Context Redirect）。<br>默认情况下，它包含输入映射上下文的映射，允许你将一个上下文重定向到另一个上下文。<br>要应用此重定向，请将其添加到你的 项目设置（Project Settings） &gt; 增强输入（Enhanced Input） &gt; 平台设置（Platform Settings） &gt; 输入数据（Input Data）。</p>
<h2 id="其他课题与思考"><a href="#其他课题与思考" class="headerlink" title="其他课题与思考"></a>其他课题与思考</h2><p>常见的一个游戏功能就是玩家按键自定义。<br>这一块应该通过输入映射上下文就可以实现了。<br>这块再做一个本地保存应该就好。</p>
]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>UE基础功能</tag>
      </tags>
  </entry>
  <entry>
    <title>GASPredictionKey自学简记</title>
    <url>/2025/03/06/UEGamplayPrediction%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="关键点：PredictionKey"><a href="#关键点：PredictionKey" class="headerlink" title="关键点：PredictionKey"></a>关键点：PredictionKey</h1><p>由GA激活生成的PKey，并由此去影响GAS系统中的各个其他部分。</p>
<p>客户端预测先行，在收到服务器校验结果后，执行对应的回滚操作。</p>
<h2 id="概念：预测窗口-Prediction-Window"><a href="#概念：预测窗口-Prediction-Window" class="headerlink" title="概念：预测窗口 Prediction Window"></a>概念：预测窗口 Prediction Window</h2><blockquote>
<p>“We do not predict over multiple frames”</p>
</blockquote>
<p>在多个行为激活形成链条时，每个行为有自己的PKey，但又和之前的PKey相关联。<br>服务端并不确定Reject某个PKey对应的行为，是否会导致后续的行为也被拒绝。这里在实现的时候可能需要额外注意下。</p>
<h2 id="关于预测窗口"><a href="#关于预测窗口" class="headerlink" title="关于预测窗口"></a>关于预测窗口</h2><p>GA如果依赖于外部事件，或者定时器，在异步等待过程中，可能会收到服务器的confirm&#x2F;reject回调。而PKey在ActivateAbility返回时就结束了。因此后面激活的内容是无法绑定到这个PKey上的。</p>
<p>【这里可以验证一下 PKey在下发回客户端执行的事情（比如说广播），如果是广播形式，那么确实后面的内容就有问题了。】</p>
<p>预测窗口和预测键不会跨帧。但是预测本身是可以支持跨帧的。这里主要处理的是异步的GATask等逻辑。为了实现跨多帧的预测逻辑，就需要多个预测窗口。每个帧内的操作都是独立的预测窗口，每个异步操作需要自己的同步执行块。</p>
<p>这里异步操作对应的预测窗口创建：<br>• Ability中去创建新的PredictionWindow - 见<code>FScopedPredictionWindow</code></p>
<h2 id="结合官方文档，给出一个Deepseek回答的样例【待考证】"><a href="#结合官方文档，给出一个Deepseek回答的样例【待考证】" class="headerlink" title="结合官方文档，给出一个Deepseek回答的样例【待考证】"></a>结合官方文档，给出一个Deepseek回答的样例【待考证】</h2><p>目前来看 CreateDependentKey 应该是由内部去维护的。<br>参考的样例还是看官方文档的AbilityTask_WaitInputRelease更为合适。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#region Deepseek样例和回答</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAbilityTask_WaitInputRelease::OnReleaseCallback</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建新的预测窗口</span></span><br><span class="line">    <span class="function">FScopedPredictionWindow <span class="title">ScopedPrediction</span><span class="params">(AbilitySystemComponent)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">//发送RPC时带上预测键</span></span></span><br><span class="line"><span class="function">    AbilitySystemComponent-&gt;<span class="title">ServerInputRelease</span><span class="params">(ScopedPrediction.ScopedPreditionKey)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//[在此作用域内所有副作用自动关联预测键]</span></span><br><span class="line">    <span class="built_in">ApplayGameplayEffect</span>(ChargeEffect)</span><br><span class="line">    <span class="built_in">PlayMontage</span>(ReleaseAnim)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">需要注意新键的创建可能以来于FScopedPredictionWindow。</span><br><span class="line">且依赖链条，可能需要显示创建。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UGA_Chain::ActivateAbility</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">FCopedPredictionWindow <span class="title">Window1</span><span class="params">(ASC)</span></span>; <span class="comment">//PKey1</span></span><br><span class="line">    <span class="built_in">ServerAction1</span>(PKey1);</span><br><span class="line">    <span class="comment">//显示创建依赖关系</span></span><br><span class="line">    FPredictionKey PKey2 = FPredictionKey::<span class="built_in">CreateDependentKey</span>(PKey1);</span><br><span class="line"></span><br><span class="line">    UAbilityTask_WaitGameplayEvent * Task = UAbilityTask_WaitGameplayEvent::<span class="built_in">WaitGameplayEvent</span>(<span class="keyword">this</span>);</span><br><span class="line">    Task-&gt;EventReceived.<span class="built_in">AddLambda</span>([<span class="keyword">this</span>,PKey2]()&#123;</span><br><span class="line">        FScopedPredictionWindow <span class="built_in">Window2</span>(ASC);<span class="comment">//实际生成Key3</span></span><br><span class="line">        PKey<span class="number">3.</span><span class="built_in">AddDependency</span>(PKey2);    <span class="comment">//建立依赖链</span></span><br><span class="line">        <span class="built_in">ServerAction2</span>(PKey3);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;依赖关系是基于键的当前状态而不是键本身的存在。&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#endregion Deepseek样例回答</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UE</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>GAS</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下的Git账号更换</title>
    <url>/2025/03/04/windows-change-git/</url>
    <content><![CDATA[<h3 id="Hexo更换指定Git账号问题"><a href="#Hexo更换指定Git账号问题" class="headerlink" title="Hexo更换指定Git账号问题"></a>Hexo更换指定Git账号问题</h3><ul>
<li><p>Git内设置对应的账号和密码</p>
</li>
<li><p>控制面板 - 用户 - 凭据管理器 - Windows凭据删除对应git的凭据 在使用时重新通过网页处理凭据 </p>
</li>
<li><p>使用新账号登陆即可</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
